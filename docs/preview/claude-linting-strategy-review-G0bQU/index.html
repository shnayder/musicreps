<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Music Reps</title>
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">

  <style>
    :root {
  /* Brand (sage) */
  --color-brand: hsl(90, 35%, 45%);
  --color-brand-dark: hsl(90, 35%, 35%);
  --color-brand-bg: hsl(90, 25%, 94%);

  /* Semantic colors */
  --color-success: #4CAF50;
  --color-success-dark: #388E3C;
  --color-success-bg: #e8f5e9;
  --color-success-text: #2e7d32;
  --color-error: #f44336;
  --color-error-bg: #ffebee;
  --color-error-text: #c62828;
  --color-focus: #2196F3;
  --color-focus-bg: #e3f2fd;
  --color-recommended: #FF9800;
  --color-highlight: #FFD700;

  /* UI accents */
  --color-toggle-active: hsl(90, 35%, 42%);
  --color-toggle-recommended: hsl(35, 80%, 55%);

  /* Text (warm neutrals) */
  --color-text: hsl(30, 5%, 20%);
  --color-text-muted: hsl(30, 3%, 40%);
  --color-text-light: hsl(30, 3%, 60%);

  /* Surfaces & backgrounds (warm neutrals) */
  --color-bg: #fff;
  --color-surface: hsl(30, 10%, 96%);
  --color-surface-hover: hsl(30, 8%, 93%);
  --color-surface-alt: hsl(30, 8%, 92%);
  --color-surface-pressed: hsl(30, 5%, 82%);
  --color-surface-accent: hsl(30, 8%, 90%);

  /* Borders (warm neutrals) */
  --color-border: hsl(30, 5%, 60%);
  --color-border-light: hsl(30, 5%, 80%);
  --color-border-lighter: hsl(30, 5%, 86%);

  /* Overlay */
  --color-overlay: rgba(0, 0, 0, 0.35);

  /* Heatmap scale (warm → sage, matches fretboard circle palette) */
  --heatmap-none: hsl(30, 4%, 85%);
  --heatmap-1: hsl(12, 48%, 65%);
  --heatmap-2: hsl(30, 48%, 58%);
  --heatmap-3: hsl(50, 40%, 50%);
  --heatmap-4: hsl(72, 38%, 42%);
  --heatmap-5: hsl(90, 45%, 35%);

  /* Typography scale */
  --text-xs: 0.75rem;
  --text-sm: 0.85rem;
  --text-base: 1rem;
  --text-md: 1.125rem;
  --text-lg: 1.3rem;
  --text-xl: 1.5rem;
  --text-2xl: 2rem;

  /* Spacing scale */
  --space-1: 0.125rem;
  --space-2: 0.25rem;
  --space-3: 0.5rem;
  --space-4: 0.75rem;
  --space-5: 1rem;
  --space-6: 1.5rem;
}

* { -webkit-tap-highlight-color: transparent; }
html {
  background: var(--color-surface);
  overscroll-behavior: none;
}
body {
  font-family: system-ui, -apple-system, sans-serif;
  max-width: 650px;
  margin: 0 auto;
  padding: 0 var(--space-5);
  padding-top: env(safe-area-inset-top, 0);
  padding-bottom: env(safe-area-inset-bottom, 0);
  padding-left: max(var(--space-5), env(safe-area-inset-left, 0));
  padding-right: max(var(--space-5), env(safe-area-inset-right, 0));
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  min-height: 100dvh;
  color: var(--color-text);
  background: var(--color-bg);
  border-left: 1px solid var(--color-border-lighter);
  border-right: 1px solid var(--color-border-lighter);
  overscroll-behavior: none;
}

/* --- Home screen --- */
.home-screen { display: flex; flex-direction: column; min-height: 100dvh;
  padding: var(--space-5); }
.home-screen.hidden { display: none; }
.home-header { text-align: center; padding: var(--space-6) 0 var(--space-4); }
.home-title { font-size: var(--text-2xl); font-weight: 700; color: var(--color-text); margin: 0; }
.home-modes { flex: 1; }
.home-group-label { font-size: var(--text-xs); font-weight: 600;
  text-transform: uppercase; color: var(--color-text-muted);
  letter-spacing: 0.05em; margin-top: var(--space-5);
  margin-bottom: var(--space-2); padding-left: var(--space-2); }
.home-group-label:first-child { margin-top: 0; }
.home-mode-btn { display: flex; flex-direction: column; width: 100%;
  text-align: left; padding: var(--space-4) var(--space-4);
  background: var(--color-bg); border: 1px solid var(--color-border-lighter);
  border-radius: 8px; margin-bottom: var(--space-2); cursor: pointer; }
.home-mode-btn:hover { background: var(--color-surface); }
.home-mode-btn:active { background: var(--color-surface-pressed); }
.home-mode-name { font-size: var(--text-base); font-weight: 600;
  color: var(--color-text); }
.home-mode-desc { font-size: var(--text-sm); color: var(--color-text-muted); }
.home-footer { display: flex; align-items: center; justify-content: space-between;
  padding: var(--space-4) 0; border-top: 1px solid var(--color-border-lighter);
  margin-top: var(--space-4); }
.home-settings-btn {
  background: none; border: 1px solid var(--color-border-light);
  border-radius: 6px; padding: var(--space-2) var(--space-4);
  font-size: var(--text-sm); color: var(--color-text-muted); cursor: pointer;
  margin: 0; min-height: 44px; display: flex; align-items: center;
}
.home-settings-btn:hover { background: var(--color-surface-hover); }
.home-settings-btn:active { background: var(--color-surface-pressed); }
.version {
  font-size: var(--text-xs);
  color: var(--color-text-light);
}

/* --- Mode top bar --- */
.mode-top-bar { display: flex; align-items: center; gap: var(--space-3);
  padding: var(--space-3) 0; margin-bottom: var(--space-3); }
.mode-back-btn { background: none; border: none; font-size: var(--text-xl);
  cursor: pointer; padding: var(--space-2); min-width: 44px; min-height: 44px;
  color: var(--color-text-muted); margin: 0; display: flex; align-items: center;
  justify-content: center; border-radius: 6px; }
.mode-back-btn:hover { background: var(--color-surface-hover); }
.mode-back-btn:active { background: var(--color-surface-pressed); }
.mode-title { margin: 0; font-size: var(--text-lg); font-weight: 600; flex: 1; }
/* Hide back button during active quiz and calibration; keep title visible */
.phase-active .mode-back-btn,
.phase-calibration .mode-back-btn,
.phase-round-complete .mode-back-btn { display: none; }
.phase-active .mode-top-bar,
.phase-calibration .mode-top-bar,
.phase-round-complete .mode-top-bar { margin-bottom: 0; }

/* --- Settings modal --- */
.settings-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--color-overlay);
  z-index: 200;
  justify-content: center;
  align-items: center;
}
.settings-overlay.open {
  display: flex;
}
.settings-modal {
  background: var(--color-bg);
  border-radius: 12px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
  width: 280px;
  max-width: 90vw;
  overflow: hidden;
}
.settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-4) var(--space-5);
  border-bottom: 1px solid var(--color-border);
}
.settings-title {
  font-weight: 600;
  font-size: var(--text-base);
}
.settings-close-btn {
  background: none;
  border: none;
  font-size: var(--text-xl);
  cursor: pointer;
  color: var(--color-text);
  padding: 0;
  line-height: 1;
  opacity: 0.6;
}
.settings-close-btn:hover {
  opacity: 1;
}
.settings-close-btn:active {
  opacity: 0.4;
}
.settings-body {
  padding: var(--space-5);
}
.settings-field {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}
.settings-label {
  font-size: var(--text-sm);
  font-weight: 500;
  color: var(--color-text-muted);
}
.settings-toggle-group {
  display: flex;
  gap: 0;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid var(--color-border);
}
.settings-toggle-btn {
  flex: 1;
  padding: var(--space-3) var(--space-4);
  border: none;
  background: var(--color-surface);
  cursor: pointer;
  font-size: var(--text-sm);
  font-weight: 500;
  color: var(--color-text);
  transition: background 0.15s ease, color 0.15s ease;
}
.settings-toggle-btn + .settings-toggle-btn {
  border-left: 1px solid var(--color-border);
}
.settings-toggle-btn.active {
  background: var(--color-brand);
  color: white;
}
.settings-toggle-btn:hover:not(.active) {
  background: var(--color-surface-hover);
}
.settings-toggle-btn:active {
  opacity: 0.8;
}


/* --- Mode screens --- */
.mode-screen {
  display: none;
  padding-top: var(--space-3);
  flex: 1;
}
.mode-screen.mode-active {
  display: block;
}

/* --- Phase-driven visibility --- */
.quiz-session { position: relative; }
.phase-idle .quiz-session { display: none; }

/* Hide tabs and tab content during non-idle phases */
/* .tab-content.active needs explicit override (higher specificity than .tab-content.active display:block) */
.phase-active .mode-tabs,
.phase-active .tab-content,
.phase-active .tab-content.active,
.phase-calibration .mode-tabs,
.phase-calibration .tab-content,
.phase-calibration .tab-content.active,
.phase-round-complete .mode-tabs,
.phase-round-complete .tab-content,
.phase-round-complete .tab-content.active { display: none; }

/* Element-level visibility (replaces inline style="display: none;") */
.mastery-message { display: none; }
.mastery-message.mastery-visible { display: block; }
.round-complete { display: none; }
.phase-round-complete .round-complete { display: block; }
.stats-container.stats-hidden { display: none; }
.fretboard-wrapper.fretboard-hidden { display: none; }

/* --- Mode tabs (Practice / Progress) --- */
.mode-tabs {
  display: flex;
  gap: 0;
  border-bottom: 2px solid var(--color-border-lighter);
  margin-bottom: var(--space-5);
}
.mode-tab {
  flex: 1;
  padding: var(--space-3) var(--space-5);
  border: none;
  border-bottom: 2px solid transparent;
  margin-bottom: -2px;
  background: none;
  font-size: var(--text-base);
  font-weight: 500;
  color: var(--color-text-muted);
  cursor: pointer;
  transition: color 0.15s ease, border-color 0.15s ease;
}
.mode-tab:hover {
  color: var(--color-text);
}
.mode-tab.active {
  color: var(--color-brand-dark);
  border-bottom-color: var(--color-brand);
  font-weight: 600;
}
.tab-content {
  display: none;
}
.tab-content.active {
  display: block;
}

/* --- Practice card --- */
.practice-card {
  margin-bottom: var(--space-4);
  padding: var(--space-4) var(--space-5);
  background: var(--color-surface);
  border-radius: 8px;
}
.practice-zone + .practice-zone {
  margin-top: var(--space-5);
  padding-top: var(--space-5);
  border-top: 1px solid var(--color-border-lighter);
}
.practice-status {
  margin-bottom: var(--space-3);
}
.practice-status:empty,
.practice-status-label:empty + .practice-status-detail:empty {
  display: none;
}
.practice-status-label {
  font-weight: 600;
  font-size: var(--text-base);
  color: var(--color-text);
}
.practice-status-detail {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-left: var(--space-3);
}
.practice-recommendation {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  flex-wrap: wrap;
}
.practice-recommendation:empty,
.practice-rec-text:empty ~ .practice-rec-btn {
  display: none;
}
.practice-rec-text {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
}
.practice-rec-text:empty {
  display: none;
}
.practice-rec-btn {
  font-size: var(--text-xs);
  font-weight: 500;
  padding: var(--space-2) var(--space-4);
  border: 1px solid var(--color-brand);
  border-radius: 6px;
  background: var(--color-brand-bg);
  color: var(--color-brand-dark);
  cursor: pointer;
  margin: 0;
  transition: background 0.15s ease;
}
.practice-rec-btn:hover {
  background: var(--color-brand);
  color: white;
}
.practice-rec-btn.hidden {
  display: none;
}

/* --- Practice scope (inside practice card) --- */
.practice-scope {
  margin-top: var(--space-4);
}
.practice-scope .settings-row {
  margin-bottom: 0;
}

/* --- Practice action zone (inside practice card) --- */
.practice-zone-action {
  text-align: center;
}
.session-summary-text {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-3);
}
.session-summary-text:empty {
  display: none;
}

/* --- Baseline info (Progress tab) --- */
.baseline-info {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  text-align: center;
  padding: var(--space-3) var(--space-4);
  margin-bottom: var(--space-3);
}
.baseline-info:empty {
  display: none;
}
.baseline-default-tag {
  font-style: italic;
  color: var(--color-text-light);
}
.baseline-rerun-btn {
  background: none;
  border: 1px solid var(--color-border-light);
  border-radius: 6px;
  padding: var(--space-2) var(--space-4);
  font-size: var(--text-xs);
  font-weight: 500;
  color: var(--color-text-muted);
  cursor: pointer;
  margin: 0;
  margin-left: var(--space-2);
  transition: background 0.15s ease, border-color 0.15s ease;
}
.baseline-rerun-btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-border);
}
.baseline-rerun-btn:active {
  background: var(--color-surface-pressed);
}

/* --- Progress tab stats controls (within tab) --- */
.tab-content .stats-controls {
  text-align: center;
  margin: var(--space-3) 0;
  padding-bottom: var(--space-2);
}

/* --- Fretboard --- */
.fretboard-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}
.string-toggles {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  justify-content: center;
}
.string-toggle {
  width: 36px;
  height: 36px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background: var(--color-surface);
  color: var(--color-border);
  font-size: var(--text-sm);
  font-weight: 500;
  cursor: pointer;
  padding: 0;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}
.string-toggle:hover {
  background: var(--color-surface-hover);
}
.string-toggle.active {
  background: var(--color-toggle-active);
  color: white;
  border-color: var(--color-toggle-active);
}
.string-toggle.recommended {
  box-shadow: 0 0 0 2px var(--color-toggle-recommended);
}
.string-toggle.active.recommended {
  border-color: var(--color-toggle-recommended);
}
.distance-toggles {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  justify-content: center;
}
.distance-toggle {
  height: 36px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background: var(--color-surface);
  color: var(--color-border);
  font-size: var(--text-xs);
  font-weight: 500;
  cursor: pointer;
  padding: 0 0.4rem;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}
.distance-toggle:hover {
  background: var(--color-surface-hover);
}
.distance-toggle.active {
  background: var(--color-toggle-active);
  color: white;
  border-color: var(--color-toggle-active);
}
.distance-toggle.recommended {
  box-shadow: 0 0 0 2px var(--color-toggle-recommended);
}
.distance-toggle.active.recommended {
  border-color: var(--color-toggle-recommended);
}
.notes-toggles {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  justify-content: center;
}
.notes-toggle {
  height: 36px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background: var(--color-surface);
  color: var(--color-border);
  font-size: var(--text-xs);
  font-weight: 500;
  cursor: pointer;
  padding: 0 0.6rem;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}
.notes-toggle:hover {
  background: var(--color-surface-hover);
}
.notes-toggle.active {
  background: var(--color-toggle-active);
  color: white;
  border-color: var(--color-toggle-active);
}
.fretboard-container {
  position: relative;
  width: 100%;
  min-width: 0;
  max-width: 1200px;
}
.fretboard {
  width: 100%;
  height: auto;
  display: block;
  background: var(--color-bg);
  touch-action: manipulation;
}
/* SVG fretboard — new circle-based design */
.fb-string { stroke: hsl(30, 8%, 72%); }
.fb-fret { stroke: hsl(30, 5%, 82%); }
.fb-nut { fill: hsl(30, 8%, 48%); }
.fb-marker { fill: hsl(30, 5%, 62%); }
.fb-pos {
  fill: hsl(30, 5%, 90%);
  stroke: none;
  cursor: pointer;
  transition: fill 0.15s;
}

/* Hover card */
.hover-card {
  position: absolute;
  pointer-events: none;
  z-index: 10;
  opacity: 0;
  transition: opacity 0.12s;
}
.hover-card.visible { opacity: 1; }
.hc-inner {
  background: var(--color-bg);
  border: 1px solid var(--color-border-light);
  border-radius: 8px;
  padding: 0.35rem 0.5rem;
  min-width: 65px;
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.12);
  text-align: center;
}
.hc-note { font-size: var(--text-sm); font-weight: 700; color: var(--color-text); }
.hc-string-fret { font-size: var(--text-xs); color: var(--color-text-muted); margin-top: 0.05rem; }
.hc-detail { font-size: var(--text-xs); color: var(--color-text-muted); margin-top: 0.12rem; }
.hc-bar { height: 3px; border-radius: 2px; background: hsl(30, 5%, 90%); margin-top: 0.25rem; overflow: hidden; }
.hc-bar-fill { height: 100%; border-radius: 2px; transition: width 0.2s; }

.settings-row {
  display: flex;
  align-items: center;
  gap: var(--space-5);
  justify-content: center;
  margin-bottom: var(--space-3);
}
button {
  padding: var(--space-3) var(--space-6);
  font-size: var(--text-base);
  cursor: pointer;
  margin: 0 var(--space-3);
}
.mastery-message {
  background: var(--color-success-bg);
  color: var(--color-success-text);
  font-weight: bold;
  font-size: var(--text-base);
  padding: var(--space-3) var(--space-5);
  margin-bottom: var(--space-3);
  border-radius: 6px;
  text-align: center;
}

/* --- Primary CTA (Start Quiz) --- */
.start-btn {
  background: var(--color-brand);
  color: white;
  border: 2px solid var(--color-brand);
  border-radius: 8px;
  font-weight: 600;
  font-size: var(--text-md);
  padding: var(--space-4) var(--space-6);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
  transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.1s ease;
}
.start-btn:hover {
  background: var(--color-brand-dark);
  border-color: var(--color-brand-dark);
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.18);
}
.start-btn:active {
  transform: scale(0.98);
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
}

/* --- Quiz countdown row — bar + timer side by side --- */
.quiz-countdown-row {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  margin-bottom: var(--space-2);
}
.quiz-countdown-bar {
  flex: 1;
  height: 4px;
  background: var(--color-surface-alt);
  margin-left: calc(-1 * var(--space-5));
}
.quiz-countdown-fill {
  height: 100%;
  background: var(--color-brand);
  transition: width 0.2s linear;
  width: 100%;
}
.round-timer-warning .quiz-countdown-fill,
.last-question .quiz-countdown-fill {
  background: var(--color-error);
}
.quiz-info-time {
  font-size: var(--text-xs);
  font-variant-numeric: tabular-nums;
  color: var(--color-text-muted);
  white-space: nowrap;
}

/* --- Quiz session info — single compact row --- */
.quiz-session-info {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  padding: 0 var(--space-6) var(--space-2) 0;
}
.quiz-info-context { flex: 1; }
.quiz-info-count { font-variant-numeric: tabular-nums; }
.quiz-header-close {
  position: absolute;
  top: var(--space-3);
  right: 0;
  background: none;
  border: none;
  font-size: var(--text-xl);
  color: var(--color-text-light);
  cursor: pointer;
  padding: 0 var(--space-2);
  line-height: 1;
  margin: 0;
  border-radius: 4px;
  transition: color 0.15s ease, background 0.15s ease;
  z-index: 1;
}
.quiz-header-close:hover {
  color: var(--color-text);
  background: var(--color-surface-hover);
}

/* --- Progress bar --- */
.progress-bar {
  width: 100%;
  max-width: 300px;
  height: 20px;
  background: var(--color-surface-alt);
  border-radius: 10px;
  margin: 0 auto var(--space-4);
  overflow: hidden;
  position: relative;
}
.phase-active .progress-bar,
.phase-round-complete .progress-bar { display: none; }
.progress-fill {
  height: 100%;
  background: var(--color-success);
  border-radius: 10px;
  transition: width 0.3s ease;
  min-width: 0;
}
.progress-text {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--text-xs);
  font-weight: 600;
  color: var(--color-text);
  pointer-events: none;
}

/* --- Quiz-active visual focus --- */
.phase-active,
.phase-round-complete,
.phase-calibration {
  background: var(--color-surface);
  margin: 0 calc(-1 * var(--space-5));
  padding: 0 var(--space-5);
}
.phase-active .quiz-area.active {
  border: 1px solid var(--color-border-lighter);
  padding: var(--space-3) var(--space-3);
}

/* --- Quiz area (subtle card containment) --- */
.quiz-area {
  display: none;
  text-align: center;
  margin: var(--space-5) 0;
  border: 2px solid transparent;
}
.quiz-area.active {
  display: block;
  background: var(--color-surface);
  border-radius: 12px;
  padding: var(--space-5);
}
/* --- Round complete --- */
.round-complete {
  text-align: center;
  padding: var(--space-6) 0;
}
.round-complete-context {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-4);
}
.round-complete-heading {
  font-size: var(--text-xl);
  font-weight: 700;
  color: var(--color-text);
  margin-bottom: var(--space-3);
}
.round-complete-stats {
  margin: var(--space-3) 0 var(--space-5);
}
.round-stat-line {
  font-size: var(--text-base);
  color: var(--color-text);
  line-height: 1.6;
}
.round-complete-actions {
  display: flex;
  gap: var(--space-3);
  justify-content: center;
}
.round-complete-continue {
  padding: var(--space-3) var(--space-5);
  background: var(--color-brand);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: var(--text-base);
  font-weight: 600;
  cursor: pointer;
}
.round-complete-continue:hover {
  opacity: 0.9;
}
.round-complete-continue:active {
  opacity: 0.8;
  transform: scale(0.98);
}
.round-complete-stop {
  padding: var(--space-3) var(--space-5);
  background: none;
  color: var(--color-text-muted);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  font-size: var(--text-base);
  cursor: pointer;
}
.round-complete-stop:hover {
  background: var(--color-surface-hover);
}
.round-complete-stop:active {
  background: var(--color-surface-pressed);
}
/* Hide quiz prompt, answer buttons, and feedback during round-complete */
.phase-round-complete .quiz-prompt-row,
.phase-round-complete .answer-buttons,
.phase-round-complete .note-buttons,
.phase-round-complete .chord-slots,
.phase-round-complete .feedback,
.phase-round-complete .hint,
.phase-round-complete .time-display,
.phase-round-complete .speed-tap-status,
.phase-round-complete .fretboard-wrapper,
.phase-round-complete .quiz-countdown-row,
.phase-round-complete .quiz-session-info,
.phase-round-complete .quiz-header-close { display: none; }

/* --- Note buttons (piano-style layout) --- */
.note-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  margin: var(--space-3) auto;
}
.note-row-naturals,
.note-row-accidentals {
  display: grid;
  grid-template-columns: repeat(14, 1fr);
  column-gap: 2px; /* sub-column separator; --space-1 too wide for 14-col grid */
}
.note-row-accidentals.hidden {
  display: none;
}
/* Natural notes: each spans 2 of 14 sub-columns */
.note-row-naturals .note-btn:nth-child(1) { grid-column: 1 / 3; }
.note-row-naturals .note-btn:nth-child(2) { grid-column: 3 / 5; }
.note-row-naturals .note-btn:nth-child(3) { grid-column: 5 / 7; }
.note-row-naturals .note-btn:nth-child(4) { grid-column: 7 / 9; }
.note-row-naturals .note-btn:nth-child(5) { grid-column: 9 / 11; }
.note-row-naturals .note-btn:nth-child(6) { grid-column: 11 / 13; }
.note-row-naturals .note-btn:nth-child(7) { grid-column: 13 / 15; }
/* Accidentals: piano black-key positioning between naturals */
.note-row-accidentals .note-btn:nth-child(1) { grid-column: 2 / 4; }
.note-row-accidentals .note-btn:nth-child(2) { grid-column: 4 / 6; }
.note-row-accidentals .note-btn:nth-child(3) { grid-column: 8 / 10; }
.note-row-accidentals .note-btn:nth-child(4) { grid-column: 10 / 12; }
.note-row-accidentals .note-btn:nth-child(5) { grid-column: 12 / 14; }
.note-btn {
  min-width: 0;
  height: 48px;
  font-size: var(--text-md);
  font-weight: 500;
  border: 2px solid var(--color-text-muted);
  border-radius: 8px;
  background: var(--color-bg);
  cursor: pointer;
  padding: 0;
  touch-action: manipulation;
  transition: background 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
}
.note-btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-text);
}
.note-btn.accidental {
  background: var(--color-surface-accent);
}
.note-btn.accidental:hover {
  background: var(--color-surface-pressed);
}
.note-btn:active {
  background: var(--color-surface-pressed);
  transform: scale(0.97);
}
.note-btn:disabled {
  opacity: 0.5;
  cursor: default;
}
.note-btn:disabled:hover {
  background: var(--color-bg);
  border-color: var(--color-text-muted);
  transform: none;
}
.note-btn.hidden {
  display: none;
}

/* --- Quiz prompt (text modes) --- */
.quiz-prompt-row {
  display: flex;
  align-items: baseline;
  justify-content: center;
  gap: var(--space-2);
  margin: var(--space-5) 0;
  min-height: 2.5rem;
}
.quiz-prompt {
  font-size: var(--text-2xl);
  font-weight: 600;
}
.quiz-prompt:empty {
  display: none;
}
.quiz-last-question {
  font-size: var(--text-sm);
  color: var(--color-error);
  font-weight: 500;
}
.quiz-last-question:empty {
  display: none;
}

/* --- Answer buttons grid (shared by new modes) --- */
.answer-buttons {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.4rem;
  max-width: 360px;
  margin: var(--space-3) auto;
}
.answer-btn {
  height: 48px;
  font-size: var(--text-md);
  font-weight: 500;
  border: 2px solid var(--color-text-muted);
  border-radius: 8px;
  background: var(--color-bg);
  cursor: pointer;
  padding: 0 var(--space-2);
  touch-action: manipulation;
  transition: background 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
}
.answer-btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-text);
}
.answer-btn:active {
  background: var(--color-surface-pressed);
  transform: scale(0.97);
}
.answer-btn:disabled {
  opacity: 0.5;
  cursor: default;
}
.answer-btn:disabled:hover {
  background: var(--color-bg);
  border-color: var(--color-text-muted);
  transform: none;
}
.answer-buttons-intervals {
  grid-template-columns: repeat(3, 1fr);
}

/* --- Answer group visibility (toggled by mode JS for bidirectional questions) --- */
.answer-group-hidden {
  display: none;
}

/* --- Calibration overlay: inside quiz-area, hide non-calibration content --- */
.phase-calibration .answer-buttons:not(.calibration-active),
.phase-calibration .note-buttons:not(.calibration-active) {
  display: none;
}
.phase-calibration .answer-buttons.calibration-active {
  display: grid;
}
.phase-calibration .note-buttons.calibration-active {
  display: flex;
}
.phase-calibration .speed-tap-status,
.phase-calibration .fretboard-wrapper {
  display: none;
}
.phase-calibration .chord-slots {
  display: none;
}
/* Calibration: hide quiz info (progress bar shows trial count instead) */
.phase-calibration .quiz-session-info {
  display: none;
}
/* Intro + results: hide buttons and progress */
.phase-calibration.calibration-intro .calibration-active,
.phase-calibration.calibration-results .calibration-active {
  display: none;
}
.phase-calibration.calibration-intro .progress-bar,
.phase-calibration.calibration-results .progress-bar {
  display: none;
}

/* --- Calibration highlight --- */
.calibration-target {
  background: var(--color-success) !important;
  border-color: var(--color-success-dark) !important;
  color: white !important;
  box-shadow: 0 0 12px rgba(76, 175, 80, 0.6);
}
.calibration-progress {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-top: var(--space-3);
}
.calibration-action-btn {
  display: block;
  margin: var(--space-6) auto 0;
  padding: var(--space-4) 2.5rem;
  font-size: var(--text-md);
  font-weight: 600;
  background: var(--color-brand);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.15s ease;
}
.calibration-action-btn:hover {
  background: var(--color-brand-dark);
}
.calibration-action-btn:active {
  background: var(--color-brand-dark);
}
.calibration-results {
  text-align: center;
  margin: var(--space-5) auto;
  max-width: 420px;
}
.calibration-baseline {
  font-size: var(--text-md);
  font-weight: 600;
  margin: var(--space-3) 0 var(--space-5);
}
.calibration-thresholds {
  border-collapse: collapse;
  margin: 0 auto var(--space-5);
  font-size: var(--text-sm);
  width: 100%;
}
.calibration-thresholds th,
.calibration-thresholds td {
  border: 1px solid var(--color-border-light);
  padding: 0.35rem var(--space-3);
  text-align: left;
}
.calibration-thresholds th {
  background: var(--color-surface);
  font-weight: 600;
}
.calibration-thresholds td:first-child {
  font-weight: 600;
  white-space: nowrap;
}
.calibration-thresholds td:nth-child(2) {
  white-space: nowrap;
  font-variant-numeric: tabular-nums;
}

/* --- Feedback --- */
.feedback {
  font-size: var(--text-xl);
  margin: var(--space-5) 0;
  min-height: 2rem;
}
.correct {
  color: var(--color-success);
}
.incorrect {
  color: var(--color-error);
}
.time-display {
  color: var(--color-text-muted);
  font-size: var(--text-sm);
  margin-top: var(--space-3);
}
.hint {
  color: var(--color-text-muted);
  font-size: var(--text-base);
  margin-top: var(--space-5);
}
.stats {
  margin-top: var(--space-5);
  font-size: var(--text-sm);
  color: var(--color-text-muted);
}

/* --- Heatmap legends --- */
.heatmap-legend {
  display: none;
  justify-content: center;
  gap: var(--space-3);
  flex-wrap: wrap;
  margin: var(--space-4) 0;
}
.heatmap-legend.active {
  display: flex;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 0.2rem;
  font-size: var(--text-xs);
  color: var(--color-text-muted);
}
.legend-swatch {
  width: 12px;
  height: 12px;
  border-radius: 3px;
  border: 1px solid var(--color-border);
}
.setting-group {
  display: flex;
  align-items: center;
  gap: 0.3rem;
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  cursor: pointer;
}
.toggle-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-1);
}
.toggle-group-label {
  font-size: var(--text-xs);
  color: var(--color-text-muted);
  font-weight: 500;
}

/* --- Stats tables (lookup modes) --- */
.stats-container {
  text-align: center;
  margin: var(--space-3) 0;
}
.stats-table {
  border-collapse: collapse;
  margin: var(--space-3) auto;
  font-size: var(--text-sm);
}
.stats-table th, .stats-table td {
  border: 1px solid var(--color-border-light);
  padding: 0.4rem 0.7rem;
  text-align: center;
}
.stats-table th {
  background: var(--color-surface);
  font-weight: 600;
}
.stats-cell {
  width: 40px;
  height: 28px;
  border-radius: 4px;
  padding: 0;
  box-sizing: border-box;
}

/* --- Stats grids (math modes) --- */
.stats-grid-wrapper {
  overflow-x: auto;
  margin: var(--space-3) 0;
}
.stats-grid {
  border-collapse: collapse;
  margin: 0 auto;
  font-size: var(--text-sm);
}
.stats-grid th, .stats-grid td {
  border: 1px solid var(--color-border-light);
  padding: 0.2rem 0.3rem;
  text-align: center;
}
.stats-grid th {
  background: var(--color-surface);
  font-weight: 600;
  font-size: var(--text-xs);
}
.stats-grid .stats-cell {
  width: 30px;
  height: 24px;
}
.stats-grid-row-label {
  font-weight: 600;
  background: var(--color-surface);
  padding: 0.2rem 0.4rem;
}

/* --- Speed Tap mode --- */
.speed-tap-status {
  display: flex;
  justify-content: center;
  gap: var(--space-6);
  font-size: var(--text-lg);
  margin: var(--space-3) 0;
}
.speed-tap-progress {
  font-weight: 500;
}
.speed-tap-stats {
  font-size: var(--text-xs);
}
.speed-tap-stats th, .speed-tap-stats td {
  padding: 0.2rem 0.3rem;
}
.speed-tap-stats .stats-cell {
  width: 24px;
  height: 20px;
}

/* --- Stats controls (toggle above chart) --- */
.stats-controls {
  text-align: center;
  margin: var(--space-3) 0;
  padding-bottom: var(--space-2);
}

/* --- Stats mode toggle (Recall / Speed) --- */
.stats-toggle {
  display: inline-flex;
  border: 2px solid var(--color-border);
  border-radius: 6px;
  overflow: hidden;
}
.stats-toggle-btn {
  padding: 0.35rem var(--space-5);
  font-size: var(--text-sm);
  font-weight: 500;
  border: none;
  border-radius: 0;
  background: var(--color-bg);
  color: var(--color-text-muted);
  cursor: pointer;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease;
}
.stats-toggle-btn + .stats-toggle-btn {
  border-left: 1px solid var(--color-border-light);
}
.stats-toggle-btn.active {
  background: var(--color-brand);
  color: white;
}
.stats-toggle-btn:not(.active):hover {
  background: var(--color-surface-hover);
}

/* --- Key signature answer buttons --- */
.answer-buttons-keysig {
  grid-template-columns: repeat(4, 1fr);
}

/* --- Degree answer buttons --- */
.answer-buttons-degrees {
  grid-template-columns: repeat(4, 1fr);
}

/* --- Roman numeral answer buttons --- */
.answer-buttons-numerals {
  grid-template-columns: repeat(4, 1fr);
}

/* --- Chord spelling slots --- */
.chord-slots {
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  margin: var(--space-4) 0;
  min-height: 2.5rem;
}
.chord-slot {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 3rem;
  height: 2.5rem;
  border: 2px solid var(--color-border);
  border-radius: 6px;
  font-size: var(--text-md);
  font-weight: 600;
  background: var(--color-surface);
  transition: border-color 0.15s ease, background 0.15s ease;
}
.chord-slot.active {
  border-color: var(--color-focus);
  background: var(--color-focus-bg);
}
.chord-slot.correct {
  border-color: var(--color-success);
  background: var(--color-success-bg);
  color: var(--color-success-text);
}
.chord-slot.wrong {
  border-color: var(--color-error);
  background: var(--color-error-bg);
  color: var(--color-error-text);
}

/* --- Focus-visible (keyboard navigation) --- */
:focus-visible {
  outline: 2px solid var(--color-brand);
  outline-offset: 2px;
}
/* Remove default outline for mouse/touch users */
:focus:not(:focus-visible) {
  outline: none;
}
/* Specific overrides for elements that need different focus styling */
.start-btn:focus-visible {
  outline-color: var(--color-brand-dark);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12), 0 0 0 4px rgba(209, 147, 27, 0.3);
}
.home-mode-btn:focus-visible {
  outline-offset: -2px;
}

/* --- Reduced motion --- */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Mobile layout */
@media (max-width: 599px) {
  body {
    margin: 0;
    padding: 0 var(--space-1);
    padding-top: env(safe-area-inset-top, 0);
    padding-bottom: env(safe-area-inset-bottom, 0);
    padding-left: max(var(--space-1), env(safe-area-inset-left, 0));
    padding-right: max(var(--space-1), env(safe-area-inset-right, 0));
    border-left: none;
    border-right: none;
  }

  .quiz-countdown-bar {
    margin-left: calc(-1 * var(--space-1));
  }

  .phase-active,
  .phase-round-complete,
  .phase-calibration {
    margin: 0 calc(-1 * var(--space-1));
    padding: 0 var(--space-1);
  }

  .fretboard-container {
    width: 100%;
    max-width: none;
  }

  .answer-buttons {
    grid-template-columns: repeat(3, 1fr);
    max-width: 280px;
  }

  .quiz-prompt {
    font-size: 1.6rem;
  }

  /* Prevent iOS zoom on input focus */
  input, button { font-size: 16px; }
}

  </style>
</head>
<body>
  <!-- Home screen -->
  <div class="home-screen" id="home-screen">
    <div class="home-header">
      <h1 class="home-title">Music Reps</h1>
    </div>
    <div class="home-modes">
      <div class="home-group-label">Fretboard</div>
      <button data-mode="fretboard" class="home-mode-btn">
        <span class="home-mode-name">Guitar Fretboard</span>
        <span class="home-mode-desc">Name notes on the guitar neck</span>
      </button>
      <button data-mode="ukulele" class="home-mode-btn">
        <span class="home-mode-name">Ukulele Fretboard</span>
        <span class="home-mode-desc">Name notes on the ukulele</span>
      </button>
      <button data-mode="speedTap" class="home-mode-btn">
        <span class="home-mode-name">Speed Tap</span>
        <span class="home-mode-desc">Find all positions of a note</span>
      </button>
      <div class="home-group-label">Theory Lookup</div>
      <button data-mode="noteSemitones" class="home-mode-btn">
        <span class="home-mode-name">Note ↔ Semitones</span>
        <span class="home-mode-desc">Convert between notes and semitone numbers</span>
      </button>
      <button data-mode="intervalSemitones" class="home-mode-btn">
        <span class="home-mode-name">Interval ↔ Semitones</span>
        <span class="home-mode-desc">Convert between intervals and semitone counts</span>
      </button>
      <div class="home-group-label">Calculation</div>
      <button data-mode="semitoneMath" class="home-mode-btn">
        <span class="home-mode-name">Semitone Math</span>
        <span class="home-mode-desc">Add or subtract semitones from a note</span>
      </button>
      <button data-mode="intervalMath" class="home-mode-btn">
        <span class="home-mode-name">Interval Math</span>
        <span class="home-mode-desc">Apply intervals up or down from a note</span>
      </button>
      <div class="home-group-label">Keys &amp; Chords</div>
      <button data-mode="keySignatures" class="home-mode-btn">
        <span class="home-mode-name">Key Signatures</span>
        <span class="home-mode-desc">Match keys to their sharps and flats</span>
      </button>
      <button data-mode="scaleDegrees" class="home-mode-btn">
        <span class="home-mode-name">Scale Degrees</span>
        <span class="home-mode-desc">Name notes by scale degree in any key</span>
      </button>
      <button data-mode="diatonicChords" class="home-mode-btn">
        <span class="home-mode-name">Diatonic Chords</span>
        <span class="home-mode-desc">Identify chords built on each scale degree</span>
      </button>
      <button data-mode="chordSpelling" class="home-mode-btn">
        <span class="home-mode-name">Chord Spelling</span>
        <span class="home-mode-desc">Spell out the notes in any chord</span>
      </button>
    </div>
    <div class="home-footer">
      <button class="home-settings-btn" type="button">Settings</button>
      <span class="version">v6.9</span>
    </div>
  </div>

  <!-- Guitar Fretboard mode -->
  <div class="mode-screen phase-idle" id="mode-fretboard">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Guitar Fretboard</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group">
          <span class="toggle-group-label">Strings</span>
          <div class="string-toggles">
            <button class="string-toggle" data-string="0" data-string-note="e">e</button>
            <button class="string-toggle" data-string="1" data-string-note="B">B</button>
            <button class="string-toggle" data-string="2" data-string-note="G">G</button>
            <button class="string-toggle" data-string="3" data-string-note="D">D</button>
            <button class="string-toggle" data-string="4" data-string-note="A">A</button>
            <button class="string-toggle active" data-string="5" data-string-note="E">E</button>
          </div>
        </div>
          <div class="toggle-group">
            <span class="toggle-group-label">Notes</span>
            <div class="notes-toggles">
              <button class="notes-toggle active" data-notes="natural">natural</button>
              <button class="notes-toggle" data-notes="sharps-flats">sharps &amp; flats</button>
            </div>
          </div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      <div class="fretboard-wrapper">
      <div class="fretboard-container">
        <svg class="fretboard" viewBox="0 0 600 226">
          <!-- Fret marker dots (inlays) -->
          <circle class="fb-marker" cx="210" cy="113" r="4"/>
      <circle class="fb-marker" cx="312" cy="113" r="4"/>
      <circle class="fb-marker" cx="402" cy="113" r="4"/>
      <circle class="fb-marker" cx="481.5" cy="113" r="4"/>
      <circle class="fb-marker" cx="584" cy="75" r="4"/><circle class="fb-marker" cx="584" cy="151" r="4"/>
          <!-- Nut (wide bar at fret 0) -->
          <rect class="fb-nut" x="63" y="0" width="4" height="226" rx="1"/>
          <!-- Frets (vertical lines) -->
          <line class="fb-fret" x1="126" y1="0" x2="126" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="183" y1="0" x2="183" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="237" y1="0" x2="237" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="288" y1="0" x2="288" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="336" y1="0" x2="336" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="381" y1="0" x2="381" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="423" y1="0" x2="423" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="463" y1="0" x2="463" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="500" y1="0" x2="500" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="535" y1="0" x2="535" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="568" y1="0" x2="568" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="600" y1="0" x2="600" y2="226" stroke-width="1"/>
          <!-- Strings (horizontal lines) -->
          <line class="fb-string" x1="0" y1="18" x2="600" y2="18" stroke-width="1"/>
      <line class="fb-string" x1="0" y1="56" x2="600" y2="56" stroke-width="1.4"/>
      <line class="fb-string" x1="0" y1="94" x2="600" y2="94" stroke-width="1.8"/>
      <line class="fb-string" x1="0" y1="132" x2="600" y2="132" stroke-width="2.2"/>
      <line class="fb-string" x1="0" y1="170" x2="600" y2="170" stroke-width="2.6"/>
      <line class="fb-string" x1="0" y1="208" x2="600" y2="208" stroke-width="3"/>
          <!-- Position circles -->
          <circle class="fb-pos" data-string="0" data-fret="0" cx="32.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="1" cx="95.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="2" cx="154.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="3" cx="210" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="4" cx="262.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="5" cx="312" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="6" cx="358.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="7" cx="402" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="8" cx="443" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="9" cx="481.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="10" cx="517.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="11" cx="551.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="12" cx="584" cy="18" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="0" cx="32.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="1" cx="95.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="2" cx="154.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="3" cx="210" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="4" cx="262.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="5" cx="312" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="6" cx="358.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="7" cx="402" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="8" cx="443" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="9" cx="481.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="10" cx="517.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="11" cx="551.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="12" cx="584" cy="56" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="0" cx="32.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="1" cx="95.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="2" cx="154.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="3" cx="210" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="4" cx="262.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="5" cx="312" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="6" cx="358.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="7" cx="402" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="8" cx="443" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="9" cx="481.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="10" cx="517.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="11" cx="551.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="12" cx="584" cy="94" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="0" cx="32.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="1" cx="95.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="2" cx="154.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="3" cx="210" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="4" cx="262.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="5" cx="312" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="6" cx="358.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="7" cx="402" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="8" cx="443" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="9" cx="481.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="10" cx="517.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="11" cx="551.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="12" cx="584" cy="132" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="0" cx="32.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="1" cx="95.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="2" cx="154.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="3" cx="210" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="4" cx="262.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="5" cx="312" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="6" cx="358.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="7" cx="402" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="8" cx="443" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="9" cx="481.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="10" cx="517.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="11" cx="551.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="12" cx="584" cy="170" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="0" cx="32.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="1" cx="95.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="2" cx="154.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="3" cx="210" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="4" cx="262.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="5" cx="312" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="6" cx="358.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="7" cx="402" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="8" cx="443" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="9" cx="481.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="10" cx="517.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="11" cx="551.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="12" cx="584" cy="208" r="10"/>
        </svg>
        <div class="hover-card"><div class="hc-inner">
          <div class="hc-note"></div>
          <div class="hc-string-fret"></div>
          <div class="hc-detail"></div>
          <div class="hc-bar"><div class="hc-bar-fill"></div></div>
        </div></div>
      </div>
    </div>
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="fretboard-wrapper">
      <div class="fretboard-container">
        <svg class="fretboard" viewBox="0 0 600 226">
          <!-- Fret marker dots (inlays) -->
          <circle class="fb-marker" cx="210" cy="113" r="4"/>
      <circle class="fb-marker" cx="312" cy="113" r="4"/>
      <circle class="fb-marker" cx="402" cy="113" r="4"/>
      <circle class="fb-marker" cx="481.5" cy="113" r="4"/>
      <circle class="fb-marker" cx="584" cy="75" r="4"/><circle class="fb-marker" cx="584" cy="151" r="4"/>
          <!-- Nut (wide bar at fret 0) -->
          <rect class="fb-nut" x="63" y="0" width="4" height="226" rx="1"/>
          <!-- Frets (vertical lines) -->
          <line class="fb-fret" x1="126" y1="0" x2="126" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="183" y1="0" x2="183" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="237" y1="0" x2="237" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="288" y1="0" x2="288" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="336" y1="0" x2="336" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="381" y1="0" x2="381" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="423" y1="0" x2="423" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="463" y1="0" x2="463" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="500" y1="0" x2="500" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="535" y1="0" x2="535" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="568" y1="0" x2="568" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="600" y1="0" x2="600" y2="226" stroke-width="1"/>
          <!-- Strings (horizontal lines) -->
          <line class="fb-string" x1="0" y1="18" x2="600" y2="18" stroke-width="1"/>
      <line class="fb-string" x1="0" y1="56" x2="600" y2="56" stroke-width="1.4"/>
      <line class="fb-string" x1="0" y1="94" x2="600" y2="94" stroke-width="1.8"/>
      <line class="fb-string" x1="0" y1="132" x2="600" y2="132" stroke-width="2.2"/>
      <line class="fb-string" x1="0" y1="170" x2="600" y2="170" stroke-width="2.6"/>
      <line class="fb-string" x1="0" y1="208" x2="600" y2="208" stroke-width="3"/>
          <!-- Position circles -->
          <circle class="fb-pos" data-string="0" data-fret="0" cx="32.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="1" cx="95.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="2" cx="154.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="3" cx="210" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="4" cx="262.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="5" cx="312" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="6" cx="358.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="7" cx="402" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="8" cx="443" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="9" cx="481.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="10" cx="517.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="11" cx="551.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="12" cx="584" cy="18" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="0" cx="32.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="1" cx="95.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="2" cx="154.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="3" cx="210" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="4" cx="262.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="5" cx="312" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="6" cx="358.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="7" cx="402" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="8" cx="443" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="9" cx="481.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="10" cx="517.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="11" cx="551.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="12" cx="584" cy="56" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="0" cx="32.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="1" cx="95.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="2" cx="154.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="3" cx="210" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="4" cx="262.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="5" cx="312" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="6" cx="358.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="7" cx="402" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="8" cx="443" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="9" cx="481.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="10" cx="517.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="11" cx="551.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="12" cx="584" cy="94" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="0" cx="32.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="1" cx="95.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="2" cx="154.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="3" cx="210" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="4" cx="262.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="5" cx="312" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="6" cx="358.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="7" cx="402" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="8" cx="443" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="9" cx="481.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="10" cx="517.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="11" cx="551.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="12" cx="584" cy="132" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="0" cx="32.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="1" cx="95.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="2" cx="154.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="3" cx="210" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="4" cx="262.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="5" cx="312" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="6" cx="358.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="7" cx="402" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="8" cx="443" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="9" cx="481.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="10" cx="517.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="11" cx="551.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="12" cx="584" cy="170" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="0" cx="32.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="1" cx="95.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="2" cx="154.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="3" cx="210" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="4" cx="262.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="5" cx="312" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="6" cx="358.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="7" cx="402" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="8" cx="443" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="9" cx="481.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="10" cx="517.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="11" cx="551.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="12" cx="584" cy="208" r="10"/>
        </svg>
        <div class="hover-card"><div class="hc-inner">
          <div class="hc-note"></div>
          <div class="hc-string-fret"></div>
          <div class="hc-detail"></div>
          <div class="hc-bar"><div class="hc-bar-fill"></div></div>
        </div></div>
      </div>
    </div>
      <div class="note-buttons">
        <div class="note-row-accidentals">
          <button class="note-btn accidental" data-note="C#">C#</button>
          <button class="note-btn accidental" data-note="D#">D#</button>
          <button class="note-btn accidental" data-note="F#">F#</button>
          <button class="note-btn accidental" data-note="G#">G#</button>
          <button class="note-btn accidental" data-note="A#">A#</button>
        </div>
        <div class="note-row-naturals">
          <button class="note-btn" data-note="C">C</button>
          <button class="note-btn" data-note="D">D</button>
          <button class="note-btn" data-note="E">E</button>
          <button class="note-btn" data-note="F">F</button>
          <button class="note-btn" data-note="G">G</button>
          <button class="note-btn" data-note="A">A</button>
          <button class="note-btn" data-note="B">B</button>
        </div>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Ukulele Fretboard mode -->
  <div class="mode-screen phase-idle" id="mode-ukulele">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Ukulele Fretboard</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group">
          <span class="toggle-group-label">Strings</span>
          <div class="string-toggles">
            <button class="string-toggle" data-string="0" data-string-note="A">A</button>
            <button class="string-toggle" data-string="1" data-string-note="E">E</button>
            <button class="string-toggle active" data-string="2" data-string-note="C">C</button>
            <button class="string-toggle" data-string="3" data-string-note="G">G</button>
          </div>
        </div>
          <div class="toggle-group">
            <span class="toggle-group-label">Notes</span>
            <div class="notes-toggles">
              <button class="notes-toggle active" data-notes="natural">natural</button>
              <button class="notes-toggle" data-notes="sharps-flats">sharps &amp; flats</button>
            </div>
          </div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      <div class="fretboard-wrapper">
      <div class="fretboard-container">
        <svg class="fretboard" viewBox="0 0 600 150">
          <!-- Fret marker dots (inlays) -->
          <circle class="fb-marker" cx="210" cy="75" r="4"/>
      <circle class="fb-marker" cx="312" cy="75" r="4"/>
      <circle class="fb-marker" cx="402" cy="75" r="4"/>
      <circle class="fb-marker" cx="517.5" cy="75" r="4"/>
      <circle class="fb-marker" cx="584" cy="56" r="4"/><circle class="fb-marker" cx="584" cy="94" r="4"/>
          <!-- Nut (wide bar at fret 0) -->
          <rect class="fb-nut" x="63" y="0" width="4" height="150" rx="1"/>
          <!-- Frets (vertical lines) -->
          <line class="fb-fret" x1="126" y1="0" x2="126" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="183" y1="0" x2="183" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="237" y1="0" x2="237" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="288" y1="0" x2="288" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="336" y1="0" x2="336" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="381" y1="0" x2="381" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="423" y1="0" x2="423" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="463" y1="0" x2="463" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="500" y1="0" x2="500" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="535" y1="0" x2="535" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="568" y1="0" x2="568" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="600" y1="0" x2="600" y2="150" stroke-width="1"/>
          <!-- Strings (horizontal lines) -->
          <line class="fb-string" x1="0" y1="18" x2="600" y2="18" stroke-width="1"/>
      <line class="fb-string" x1="0" y1="56" x2="600" y2="56" stroke-width="1.4"/>
      <line class="fb-string" x1="0" y1="94" x2="600" y2="94" stroke-width="1.8"/>
      <line class="fb-string" x1="0" y1="132" x2="600" y2="132" stroke-width="2.2"/>
          <!-- Position circles -->
          <circle class="fb-pos" data-string="0" data-fret="0" cx="32.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="1" cx="95.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="2" cx="154.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="3" cx="210" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="4" cx="262.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="5" cx="312" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="6" cx="358.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="7" cx="402" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="8" cx="443" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="9" cx="481.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="10" cx="517.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="11" cx="551.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="12" cx="584" cy="18" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="0" cx="32.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="1" cx="95.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="2" cx="154.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="3" cx="210" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="4" cx="262.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="5" cx="312" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="6" cx="358.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="7" cx="402" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="8" cx="443" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="9" cx="481.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="10" cx="517.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="11" cx="551.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="12" cx="584" cy="56" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="0" cx="32.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="1" cx="95.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="2" cx="154.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="3" cx="210" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="4" cx="262.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="5" cx="312" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="6" cx="358.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="7" cx="402" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="8" cx="443" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="9" cx="481.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="10" cx="517.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="11" cx="551.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="12" cx="584" cy="94" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="0" cx="32.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="1" cx="95.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="2" cx="154.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="3" cx="210" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="4" cx="262.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="5" cx="312" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="6" cx="358.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="7" cx="402" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="8" cx="443" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="9" cx="481.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="10" cx="517.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="11" cx="551.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="12" cx="584" cy="132" r="10"/>
        </svg>
        <div class="hover-card"><div class="hc-inner">
          <div class="hc-note"></div>
          <div class="hc-string-fret"></div>
          <div class="hc-detail"></div>
          <div class="hc-bar"><div class="hc-bar-fill"></div></div>
        </div></div>
      </div>
    </div>
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="fretboard-wrapper">
      <div class="fretboard-container">
        <svg class="fretboard" viewBox="0 0 600 150">
          <!-- Fret marker dots (inlays) -->
          <circle class="fb-marker" cx="210" cy="75" r="4"/>
      <circle class="fb-marker" cx="312" cy="75" r="4"/>
      <circle class="fb-marker" cx="402" cy="75" r="4"/>
      <circle class="fb-marker" cx="517.5" cy="75" r="4"/>
      <circle class="fb-marker" cx="584" cy="56" r="4"/><circle class="fb-marker" cx="584" cy="94" r="4"/>
          <!-- Nut (wide bar at fret 0) -->
          <rect class="fb-nut" x="63" y="0" width="4" height="150" rx="1"/>
          <!-- Frets (vertical lines) -->
          <line class="fb-fret" x1="126" y1="0" x2="126" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="183" y1="0" x2="183" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="237" y1="0" x2="237" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="288" y1="0" x2="288" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="336" y1="0" x2="336" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="381" y1="0" x2="381" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="423" y1="0" x2="423" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="463" y1="0" x2="463" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="500" y1="0" x2="500" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="535" y1="0" x2="535" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="568" y1="0" x2="568" y2="150" stroke-width="1"/>
      <line class="fb-fret" x1="600" y1="0" x2="600" y2="150" stroke-width="1"/>
          <!-- Strings (horizontal lines) -->
          <line class="fb-string" x1="0" y1="18" x2="600" y2="18" stroke-width="1"/>
      <line class="fb-string" x1="0" y1="56" x2="600" y2="56" stroke-width="1.4"/>
      <line class="fb-string" x1="0" y1="94" x2="600" y2="94" stroke-width="1.8"/>
      <line class="fb-string" x1="0" y1="132" x2="600" y2="132" stroke-width="2.2"/>
          <!-- Position circles -->
          <circle class="fb-pos" data-string="0" data-fret="0" cx="32.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="1" cx="95.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="2" cx="154.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="3" cx="210" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="4" cx="262.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="5" cx="312" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="6" cx="358.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="7" cx="402" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="8" cx="443" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="9" cx="481.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="10" cx="517.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="11" cx="551.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="12" cx="584" cy="18" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="0" cx="32.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="1" cx="95.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="2" cx="154.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="3" cx="210" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="4" cx="262.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="5" cx="312" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="6" cx="358.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="7" cx="402" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="8" cx="443" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="9" cx="481.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="10" cx="517.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="11" cx="551.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="12" cx="584" cy="56" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="0" cx="32.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="1" cx="95.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="2" cx="154.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="3" cx="210" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="4" cx="262.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="5" cx="312" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="6" cx="358.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="7" cx="402" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="8" cx="443" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="9" cx="481.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="10" cx="517.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="11" cx="551.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="12" cx="584" cy="94" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="0" cx="32.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="1" cx="95.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="2" cx="154.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="3" cx="210" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="4" cx="262.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="5" cx="312" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="6" cx="358.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="7" cx="402" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="8" cx="443" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="9" cx="481.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="10" cx="517.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="11" cx="551.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="12" cx="584" cy="132" r="10"/>
        </svg>
        <div class="hover-card"><div class="hc-inner">
          <div class="hc-note"></div>
          <div class="hc-string-fret"></div>
          <div class="hc-detail"></div>
          <div class="hc-bar"><div class="hc-bar-fill"></div></div>
        </div></div>
      </div>
    </div>
      <div class="note-buttons">
        <div class="note-row-accidentals">
          <button class="note-btn accidental" data-note="C#">C#</button>
          <button class="note-btn accidental" data-note="D#">D#</button>
          <button class="note-btn accidental" data-note="F#">F#</button>
          <button class="note-btn accidental" data-note="G#">G#</button>
          <button class="note-btn accidental" data-note="A#">A#</button>
        </div>
        <div class="note-row-naturals">
          <button class="note-btn" data-note="C">C</button>
          <button class="note-btn" data-note="D">D</button>
          <button class="note-btn" data-note="E">E</button>
          <button class="note-btn" data-note="F">F</button>
          <button class="note-btn" data-note="G">G</button>
          <button class="note-btn" data-note="A">A</button>
          <button class="note-btn" data-note="B">B</button>
        </div>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Speed Tap mode -->
  <div class="mode-screen phase-idle" id="mode-speedTap">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Speed Tap</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group">
            <span class="toggle-group-label">Notes</span>
            <div class="notes-toggles">
              <button class="notes-toggle active" data-notes="natural">natural</button>
              <button class="notes-toggle" data-notes="sharps-flats">sharps &amp; flats</button>
            </div>
          </div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="speed-tap-status">
        <span class="speed-tap-progress"></span>
      </div>
      <div class="fretboard-wrapper">
      <div class="fretboard-container">
        <svg class="fretboard" viewBox="0 0 600 226">
          <!-- Fret marker dots (inlays) -->
          <circle class="fb-marker" cx="210" cy="113" r="4"/>
      <circle class="fb-marker" cx="312" cy="113" r="4"/>
      <circle class="fb-marker" cx="402" cy="113" r="4"/>
      <circle class="fb-marker" cx="481.5" cy="113" r="4"/>
      <circle class="fb-marker" cx="584" cy="75" r="4"/><circle class="fb-marker" cx="584" cy="151" r="4"/>
          <!-- Nut (wide bar at fret 0) -->
          <rect class="fb-nut" x="63" y="0" width="4" height="226" rx="1"/>
          <!-- Frets (vertical lines) -->
          <line class="fb-fret" x1="126" y1="0" x2="126" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="183" y1="0" x2="183" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="237" y1="0" x2="237" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="288" y1="0" x2="288" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="336" y1="0" x2="336" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="381" y1="0" x2="381" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="423" y1="0" x2="423" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="463" y1="0" x2="463" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="500" y1="0" x2="500" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="535" y1="0" x2="535" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="568" y1="0" x2="568" y2="226" stroke-width="1"/>
      <line class="fb-fret" x1="600" y1="0" x2="600" y2="226" stroke-width="1"/>
          <!-- Strings (horizontal lines) -->
          <line class="fb-string" x1="0" y1="18" x2="600" y2="18" stroke-width="1"/>
      <line class="fb-string" x1="0" y1="56" x2="600" y2="56" stroke-width="1.4"/>
      <line class="fb-string" x1="0" y1="94" x2="600" y2="94" stroke-width="1.8"/>
      <line class="fb-string" x1="0" y1="132" x2="600" y2="132" stroke-width="2.2"/>
      <line class="fb-string" x1="0" y1="170" x2="600" y2="170" stroke-width="2.6"/>
      <line class="fb-string" x1="0" y1="208" x2="600" y2="208" stroke-width="3"/>
          <!-- Position circles -->
          <circle class="fb-pos" data-string="0" data-fret="0" cx="32.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="1" cx="95.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="2" cx="154.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="3" cx="210" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="4" cx="262.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="5" cx="312" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="6" cx="358.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="7" cx="402" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="8" cx="443" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="9" cx="481.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="10" cx="517.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="11" cx="551.5" cy="18" r="10"/>
      <circle class="fb-pos" data-string="0" data-fret="12" cx="584" cy="18" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="0" cx="32.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="1" cx="95.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="2" cx="154.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="3" cx="210" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="4" cx="262.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="5" cx="312" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="6" cx="358.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="7" cx="402" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="8" cx="443" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="9" cx="481.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="10" cx="517.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="11" cx="551.5" cy="56" r="10"/>
      <circle class="fb-pos" data-string="1" data-fret="12" cx="584" cy="56" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="0" cx="32.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="1" cx="95.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="2" cx="154.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="3" cx="210" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="4" cx="262.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="5" cx="312" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="6" cx="358.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="7" cx="402" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="8" cx="443" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="9" cx="481.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="10" cx="517.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="11" cx="551.5" cy="94" r="10"/>
      <circle class="fb-pos" data-string="2" data-fret="12" cx="584" cy="94" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="0" cx="32.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="1" cx="95.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="2" cx="154.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="3" cx="210" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="4" cx="262.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="5" cx="312" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="6" cx="358.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="7" cx="402" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="8" cx="443" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="9" cx="481.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="10" cx="517.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="11" cx="551.5" cy="132" r="10"/>
      <circle class="fb-pos" data-string="3" data-fret="12" cx="584" cy="132" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="0" cx="32.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="1" cx="95.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="2" cx="154.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="3" cx="210" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="4" cx="262.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="5" cx="312" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="6" cx="358.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="7" cx="402" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="8" cx="443" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="9" cx="481.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="10" cx="517.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="11" cx="551.5" cy="170" r="10"/>
      <circle class="fb-pos" data-string="4" data-fret="12" cx="584" cy="170" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="0" cx="32.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="1" cx="95.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="2" cx="154.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="3" cx="210" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="4" cx="262.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="5" cx="312" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="6" cx="358.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="7" cx="402" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="8" cx="443" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="9" cx="481.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="10" cx="517.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="11" cx="551.5" cy="208" r="10"/>
      <circle class="fb-pos" data-string="5" data-fret="12" cx="584" cy="208" r="10"/>
        </svg>
        <div class="hover-card"><div class="hc-inner">
          <div class="hc-note"></div>
          <div class="hc-string-fret"></div>
          <div class="hc-detail"></div>
          <div class="hc-bar"><div class="hc-bar-fill"></div></div>
        </div></div>
      </div>
    </div>
      <div class="answer-buttons answer-buttons-notes answer-group-hidden">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Note Semitones mode -->
  <div class="mode-screen phase-idle" id="mode-noteSemitones">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Note ↔ Semitones</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="answer-buttons answer-buttons-notes">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="answer-buttons answer-buttons-numbers">
        <button class="answer-btn answer-btn-num" data-num="0">0</button>
        <button class="answer-btn answer-btn-num" data-num="1">1</button>
        <button class="answer-btn answer-btn-num" data-num="2">2</button>
        <button class="answer-btn answer-btn-num" data-num="3">3</button>
        <button class="answer-btn answer-btn-num" data-num="4">4</button>
        <button class="answer-btn answer-btn-num" data-num="5">5</button>
        <button class="answer-btn answer-btn-num" data-num="6">6</button>
        <button class="answer-btn answer-btn-num" data-num="7">7</button>
        <button class="answer-btn answer-btn-num" data-num="8">8</button>
        <button class="answer-btn answer-btn-num" data-num="9">9</button>
        <button class="answer-btn answer-btn-num" data-num="10">10</button>
        <button class="answer-btn answer-btn-num" data-num="11">11</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Interval Semitones mode -->
  <div class="mode-screen phase-idle" id="mode-intervalSemitones">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Interval ↔ Semitones</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="answer-buttons answer-buttons-intervals">
        <button class="answer-btn answer-btn-interval" data-interval="m2">m2</button>
        <button class="answer-btn answer-btn-interval" data-interval="M2">M2</button>
        <button class="answer-btn answer-btn-interval" data-interval="m3">m3</button>
        <button class="answer-btn answer-btn-interval" data-interval="M3">M3</button>
        <button class="answer-btn answer-btn-interval" data-interval="P4">P4</button>
        <button class="answer-btn answer-btn-interval" data-interval="TT">TT</button>
        <button class="answer-btn answer-btn-interval" data-interval="P5">P5</button>
        <button class="answer-btn answer-btn-interval" data-interval="m6">m6</button>
        <button class="answer-btn answer-btn-interval" data-interval="M6">M6</button>
        <button class="answer-btn answer-btn-interval" data-interval="m7">m7</button>
        <button class="answer-btn answer-btn-interval" data-interval="M7">M7</button>
        <button class="answer-btn answer-btn-interval" data-interval="P8">P8</button>
      </div>
      <div class="answer-buttons answer-buttons-numbers">
        <button class="answer-btn answer-btn-num" data-num="1">1</button>
        <button class="answer-btn answer-btn-num" data-num="2">2</button>
        <button class="answer-btn answer-btn-num" data-num="3">3</button>
        <button class="answer-btn answer-btn-num" data-num="4">4</button>
        <button class="answer-btn answer-btn-num" data-num="5">5</button>
        <button class="answer-btn answer-btn-num" data-num="6">6</button>
        <button class="answer-btn answer-btn-num" data-num="7">7</button>
        <button class="answer-btn answer-btn-num" data-num="8">8</button>
        <button class="answer-btn answer-btn-num" data-num="9">9</button>
        <button class="answer-btn answer-btn-num" data-num="10">10</button>
        <button class="answer-btn answer-btn-num" data-num="11">11</button>
        <button class="answer-btn answer-btn-num" data-num="12">12</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Semitone Math mode -->
  <div class="mode-screen phase-idle" id="mode-semitoneMath">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Semitone Math</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group"><span class="toggle-group-label">Groups</span><div class="distance-toggles"></div></div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="answer-buttons answer-buttons-notes">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Interval Math mode -->
  <div class="mode-screen phase-idle" id="mode-intervalMath">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Interval Math</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group"><span class="toggle-group-label">Groups</span><div class="distance-toggles"></div></div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="answer-buttons answer-buttons-notes">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Key Signatures mode -->
  <div class="mode-screen phase-idle" id="mode-keySignatures">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Key Signatures</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group"><span class="toggle-group-label">Groups</span><div class="distance-toggles"></div></div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="answer-buttons answer-buttons-keysig">
        <button class="answer-btn answer-btn-keysig" data-sig="0">0</button>
        <button class="answer-btn answer-btn-keysig" data-sig="1#">1#</button>
        <button class="answer-btn answer-btn-keysig" data-sig="2#">2#</button>
        <button class="answer-btn answer-btn-keysig" data-sig="3#">3#</button>
        <button class="answer-btn answer-btn-keysig" data-sig="4#">4#</button>
        <button class="answer-btn answer-btn-keysig" data-sig="5#">5#</button>
        <button class="answer-btn answer-btn-keysig" data-sig="6#">6#</button>
        <button class="answer-btn answer-btn-keysig" data-sig="7#">7#</button>
        <button class="answer-btn answer-btn-keysig" data-sig="1b">1b</button>
        <button class="answer-btn answer-btn-keysig" data-sig="2b">2b</button>
        <button class="answer-btn answer-btn-keysig" data-sig="3b">3b</button>
        <button class="answer-btn answer-btn-keysig" data-sig="4b">4b</button>
        <button class="answer-btn answer-btn-keysig" data-sig="5b">5b</button>
        <button class="answer-btn answer-btn-keysig" data-sig="6b">6b</button>
        <button class="answer-btn answer-btn-keysig" data-sig="7b">7b</button>
      </div>
      <div class="answer-buttons answer-buttons-notes answer-group-hidden">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Scale Degrees mode -->
  <div class="mode-screen phase-idle" id="mode-scaleDegrees">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Scale Degrees</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group"><span class="toggle-group-label">Groups</span><div class="distance-toggles"></div></div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="answer-buttons answer-buttons-notes">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="answer-buttons answer-buttons-degrees answer-group-hidden">
        <button class="answer-btn answer-btn-degree" data-degree="1">1st</button>
        <button class="answer-btn answer-btn-degree" data-degree="2">2nd</button>
        <button class="answer-btn answer-btn-degree" data-degree="3">3rd</button>
        <button class="answer-btn answer-btn-degree" data-degree="4">4th</button>
        <button class="answer-btn answer-btn-degree" data-degree="5">5th</button>
        <button class="answer-btn answer-btn-degree" data-degree="6">6th</button>
        <button class="answer-btn answer-btn-degree" data-degree="7">7th</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Diatonic Chords mode -->
  <div class="mode-screen phase-idle" id="mode-diatonicChords">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Diatonic Chords</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group"><span class="toggle-group-label">Groups</span><div class="distance-toggles"></div></div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="answer-buttons answer-buttons-notes">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="answer-buttons answer-buttons-numerals answer-group-hidden">
        <button class="answer-btn answer-btn-numeral" data-numeral="I">I</button>
        <button class="answer-btn answer-btn-numeral" data-numeral="ii">ii</button>
        <button class="answer-btn answer-btn-numeral" data-numeral="iii">iii</button>
        <button class="answer-btn answer-btn-numeral" data-numeral="IV">IV</button>
        <button class="answer-btn answer-btn-numeral" data-numeral="V">V</button>
        <button class="answer-btn answer-btn-numeral" data-numeral="vi">vi</button>
        <button class="answer-btn answer-btn-numeral" data-numeral="vii°">vii°</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Chord Spelling mode -->
  <div class="mode-screen phase-idle" id="mode-chordSpelling">
    <div class="mode-top-bar">
      <button class="mode-back-btn" aria-label="Back to home">←</button>
      <h1 class="mode-title">Chord Spelling</h1>
    </div>
    <div class="mode-tabs">
      <button class="mode-tab active" data-tab="practice">Practice</button>
      <button class="mode-tab" data-tab="progress">Progress</button>
    </div>
    <div class="tab-content tab-practice active">
      <div class="practice-card">
        <div class="practice-zone practice-zone-status">
          <div class="practice-status">
            <span class="practice-status-label"></span>
            <span class="practice-status-detail"></span>
          </div>
        </div>
        <div class="practice-zone practice-zone-scope">
          <div class="practice-recommendation">
            <span class="practice-rec-text"></span>
            <button class="practice-rec-btn">Use suggestion</button>
          </div>
      <div class="practice-scope">
        <div class="settings-row">
          <div class="toggle-group"><span class="toggle-group-label">Groups</span><div class="distance-toggles"></div></div>
        </div>
      </div>
          <div class="mastery-message">Looks like you've got this!</div>
        </div>
        <div class="practice-zone practice-zone-action">
          <div class="session-summary-text"></div>
          <button class="start-btn">Start Quiz</button>
        </div>
      </div>
    </div>
    <div class="tab-content tab-progress">
      
      <div class="baseline-info"></div>
      <div class="stats-controls">
        <div class="stats-toggle"><button class="stats-toggle-btn active" data-mode="retention">Recall</button><button class="stats-toggle-btn" data-mode="speed">Speed</button></div>
        <span class="stats"></span>
      </div>
      <div class="stats-container"></div>
    </div>
    <div class="quiz-session">
      <div class="quiz-countdown-row">
        <div class="quiz-countdown-bar">
          <div class="quiz-countdown-fill"></div>
        </div>
        <span class="quiz-info-time"></span>
      </div>
      <div class="quiz-session-info">
        <span class="quiz-info-context"></span>
        <span class="quiz-info-count"></span>
      </div>
      <button class="quiz-header-close" aria-label="Stop quiz">×</button>
      <div class="progress-bar">
        <div class="progress-fill" style="width: 0%"></div>
        <div class="progress-text">0 / 0 fluent</div>
      </div>
    </div>
    <div class="quiz-area">
      <div class="quiz-prompt-row">
        <div class="quiz-prompt"></div>
        <div class="quiz-last-question"></div>
      </div>
      <div class="chord-slots"></div>
      <div class="answer-buttons answer-buttons-notes">
        <button class="answer-btn answer-btn-note" data-note="C">C</button>
        <button class="answer-btn answer-btn-note" data-note="C#">C#</button>
        <button class="answer-btn answer-btn-note" data-note="D">D</button>
        <button class="answer-btn answer-btn-note" data-note="D#">D#</button>
        <button class="answer-btn answer-btn-note" data-note="E">E</button>
        <button class="answer-btn answer-btn-note" data-note="F">F</button>
        <button class="answer-btn answer-btn-note" data-note="F#">F#</button>
        <button class="answer-btn answer-btn-note" data-note="G">G</button>
        <button class="answer-btn answer-btn-note" data-note="G#">G#</button>
        <button class="answer-btn answer-btn-note" data-note="A">A</button>
        <button class="answer-btn answer-btn-note" data-note="A#">A#</button>
        <button class="answer-btn answer-btn-note" data-note="B">B</button>
      </div>
      <div class="feedback"></div>
      <div class="time-display"></div>
      <div class="hint"></div>
      <div class="round-complete">
        <div class="round-complete-context"></div>
        <div class="round-complete-heading"></div>
        <div class="round-complete-stats">
          <div class="round-stat-line round-stat-correct"></div>
          <div class="round-stat-line round-stat-median"></div>
        </div>
        <div class="round-complete-actions">
          <button class="round-complete-continue">Keep Going</button>
          <button class="round-complete-stop">Stop</button>
        </div>
      </div>
    </div>
  </div>

  <script>
(() => {
  // src/music-data.js
  var NOTES = [
    { name: "C", displayName: "C", num: 0, accepts: ["c"] },
    { name: "C#", displayName: "C#/Db", num: 1, accepts: ["c#", "db"] },
    { name: "D", displayName: "D", num: 2, accepts: ["d"] },
    { name: "D#", displayName: "D#/Eb", num: 3, accepts: ["d#", "eb"] },
    { name: "E", displayName: "E", num: 4, accepts: ["e"] },
    { name: "F", displayName: "F", num: 5, accepts: ["f"] },
    { name: "F#", displayName: "F#/Gb", num: 6, accepts: ["f#", "gb"] },
    { name: "G", displayName: "G", num: 7, accepts: ["g"] },
    { name: "G#", displayName: "G#/Ab", num: 8, accepts: ["g#", "ab"] },
    { name: "A", displayName: "A", num: 9, accepts: ["a"] },
    { name: "A#", displayName: "A#/Bb", num: 10, accepts: ["a#", "bb"] },
    { name: "B", displayName: "B", num: 11, accepts: ["b"] }
  ];
  var NATURAL_NOTES = ["C", "D", "E", "F", "G", "A", "B"];
  var INTERVALS = [
    { name: "minor 2nd", num: 1, abbrev: "m2" },
    { name: "Major 2nd", num: 2, abbrev: "M2" },
    { name: "minor 3rd", num: 3, abbrev: "m3" },
    { name: "Major 3rd", num: 4, abbrev: "M3" },
    { name: "Perfect 4th", num: 5, abbrev: "P4" },
    { name: "Tritone", num: 6, abbrev: "TT", altAbbrevs: ["A4", "d5"] },
    { name: "Perfect 5th", num: 7, abbrev: "P5" },
    { name: "minor 6th", num: 8, abbrev: "m6" },
    { name: "Major 6th", num: 9, abbrev: "M6" },
    { name: "minor 7th", num: 10, abbrev: "m7" },
    { name: "Major 7th", num: 11, abbrev: "M7" },
    { name: "Octave", num: 12, abbrev: "P8" }
  ];
  function noteByNum(num) {
    return NOTES[(num % 12 + 12) % 12];
  }
  function noteAdd(noteNum, semitones) {
    return noteByNum(noteNum + semitones);
  }
  function noteSub(noteNum, semitones) {
    return noteByNum(noteNum - semitones);
  }
  function pickAccidentalName(displayName, useFlats) {
    if (!displayName.includes("/")) return displayName;
    const [sharp, flat] = displayName.split("/");
    return useFlats ? flat : sharp;
  }
  function pickRandomAccidental(displayName) {
    if (!displayName.includes("/")) return displayName;
    const [sharp, flat] = displayName.split("/");
    return Math.random() < 0.5 ? sharp : flat;
  }
  function noteMatchesInput(note, input) {
    return note.accepts.includes(input.toLowerCase());
  }
  function intervalMatchesInput(interval, input) {
    if (input === interval.abbrev) return true;
    if (interval.altAbbrevs && interval.altAbbrevs.includes(input)) return true;
    return false;
  }
  var LETTER_NAMES = ["C", "D", "E", "F", "G", "A", "B"];
  var NATURAL_SEMITONES = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };
  var MAJOR_SCALE_STEPS = [0, 2, 4, 5, 7, 9, 11];
  function parseSpelledNote(name) {
    if (!name) return { letter: "", accidental: 0 };
    const letter = name[0].toUpperCase();
    let acc = 0;
    for (let i = 1; i < name.length; i++) {
      if (name[i] === "#") acc++;
      else if (name[i] === "b") acc--;
    }
    return { letter, accidental: acc };
  }
  function spelledNoteName(letter, accidental) {
    if (accidental === 0) return letter;
    if (accidental > 0) return letter + "#".repeat(accidental);
    return letter + "b".repeat(-accidental);
  }
  function spelledNoteSemitone(name) {
    const { letter, accidental } = parseSpelledNote(name);
    return ((NATURAL_SEMITONES[letter] + accidental) % 12 + 12) % 12;
  }
  function getScaleDegreeNote(keyRoot, degree) {
    const root = parseSpelledNote(keyRoot);
    const rootLetterIdx = LETTER_NAMES.indexOf(root.letter);
    const rootSemitone = ((NATURAL_SEMITONES[root.letter] + root.accidental) % 12 + 12) % 12;
    const targetLetterIdx = (rootLetterIdx + degree - 1) % 7;
    const targetLetter = LETTER_NAMES[targetLetterIdx];
    const targetSemitone = (rootSemitone + MAJOR_SCALE_STEPS[degree - 1]) % 12;
    const naturalSemitone = NATURAL_SEMITONES[targetLetter];
    let acc = (targetSemitone - naturalSemitone + 12) % 12;
    if (acc > 6) acc -= 12;
    return spelledNoteName(targetLetter, acc);
  }
  var MAJOR_KEYS = [
    { root: "C", sharps: 0, flats: 0, accidentalCount: 0, accidentalType: "none" },
    { root: "G", sharps: 1, flats: 0, accidentalCount: 1, accidentalType: "sharps" },
    { root: "D", sharps: 2, flats: 0, accidentalCount: 2, accidentalType: "sharps" },
    { root: "A", sharps: 3, flats: 0, accidentalCount: 3, accidentalType: "sharps" },
    { root: "E", sharps: 4, flats: 0, accidentalCount: 4, accidentalType: "sharps" },
    { root: "B", sharps: 5, flats: 0, accidentalCount: 5, accidentalType: "sharps" },
    { root: "F#", sharps: 6, flats: 0, accidentalCount: 6, accidentalType: "sharps" },
    { root: "F", sharps: 0, flats: 1, accidentalCount: 1, accidentalType: "flats" },
    { root: "Bb", sharps: 0, flats: 2, accidentalCount: 2, accidentalType: "flats" },
    { root: "Eb", sharps: 0, flats: 3, accidentalCount: 3, accidentalType: "flats" },
    { root: "Ab", sharps: 0, flats: 4, accidentalCount: 4, accidentalType: "flats" },
    { root: "Db", sharps: 0, flats: 5, accidentalCount: 5, accidentalType: "flats" }
  ];
  function keySignatureLabel(key) {
    if (key.accidentalCount === 0) return "0";
    if (key.accidentalType === "sharps") return key.accidentalCount + "#";
    return key.accidentalCount + "b";
  }
  var DIATONIC_CHORDS = [
    { degree: 1, numeral: "I", quality: "major", qualityLabel: "" },
    { degree: 2, numeral: "ii", quality: "minor", qualityLabel: "m" },
    { degree: 3, numeral: "iii", quality: "minor", qualityLabel: "m" },
    { degree: 4, numeral: "IV", quality: "major", qualityLabel: "" },
    { degree: 5, numeral: "V", quality: "major", qualityLabel: "" },
    { degree: 6, numeral: "vi", quality: "minor", qualityLabel: "m" },
    { degree: 7, numeral: "vii\xB0", quality: "diminished", qualityLabel: "dim" }
  ];
  var ROMAN_NUMERALS = DIATONIC_CHORDS.map((c) => c.numeral);
  var DEGREE_LETTER_OFFSETS = {
    "R": 0,
    "2": 1,
    "b3": 2,
    "3": 2,
    "4": 3,
    "b5": 4,
    "5": 4,
    "#5": 4,
    "6": 5,
    "b7": 6,
    "7": 6
  };
  var CHORD_TYPES = [
    { name: "major", symbol: "", intervals: [0, 4, 7], degrees: ["R", "3", "5"], group: 0 },
    { name: "minor", symbol: "m", intervals: [0, 3, 7], degrees: ["R", "b3", "5"], group: 1 },
    { name: "dom7", symbol: "7", intervals: [0, 4, 7, 10], degrees: ["R", "3", "5", "b7"], group: 2 },
    { name: "maj7", symbol: "maj7", intervals: [0, 4, 7, 11], degrees: ["R", "3", "5", "7"], group: 3 },
    { name: "min7", symbol: "m7", intervals: [0, 3, 7, 10], degrees: ["R", "b3", "5", "b7"], group: 4 },
    { name: "dim", symbol: "dim", intervals: [0, 3, 6], degrees: ["R", "b3", "b5"], group: 5 },
    { name: "aug", symbol: "aug", intervals: [0, 4, 8], degrees: ["R", "3", "#5"], group: 5 },
    { name: "halfdim", symbol: "m7b5", intervals: [0, 3, 6, 10], degrees: ["R", "b3", "b5", "b7"], group: 5 },
    { name: "sus2", symbol: "sus2", intervals: [0, 2, 7], degrees: ["R", "2", "5"], group: 6 },
    { name: "sus4", symbol: "sus4", intervals: [0, 5, 7], degrees: ["R", "4", "5"], group: 6 },
    { name: "6", symbol: "6", intervals: [0, 4, 7, 9], degrees: ["R", "3", "5", "6"], group: 6 }
  ];
  var CHORD_ROOTS = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
  function getChordTones(rootName, chordType) {
    const root = parseSpelledNote(rootName);
    const rootLetterIdx = LETTER_NAMES.indexOf(root.letter);
    const rootSemitone = ((NATURAL_SEMITONES[root.letter] + root.accidental) % 12 + 12) % 12;
    return chordType.intervals.map((interval, i) => {
      const degreeLabel = chordType.degrees[i];
      const letterOffset = DEGREE_LETTER_OFFSETS[degreeLabel];
      const targetLetter = LETTER_NAMES[(rootLetterIdx + letterOffset) % 7];
      const targetSemitone = (rootSemitone + interval) % 12;
      const naturalSemitone = NATURAL_SEMITONES[targetLetter];
      let acc = (targetSemitone - naturalSemitone + 12) % 12;
      if (acc > 6) acc -= 12;
      return spelledNoteName(targetLetter, acc);
    });
  }
  function spelledNoteMatchesInput(expectedName, input) {
    const expected = parseSpelledNote(expectedName);
    const given = parseSpelledNote(input);
    return given.letter.toUpperCase() === expected.letter.toUpperCase() && given.accidental === expected.accidental;
  }
  function spelledNoteMatchesSemitone(expectedName, input) {
    return spelledNoteSemitone(expectedName) === spelledNoteSemitone(input);
  }
  var GUITAR = {
    id: "fretboard",
    // mode ID (preserved for backward compat)
    name: "Guitar Fretboard",
    storageNamespace: "fretboard",
    stringCount: 6,
    fretCount: 13,
    // frets 0–12
    stringNames: ["e", "B", "G", "D", "A", "E"],
    stringOffsets: [4, 11, 7, 2, 9, 4],
    // semitones from C per string
    defaultString: 5,
    // low E
    fretMarkers: [3, 5, 7, 9, 12]
  };
  var UKULELE = {
    id: "ukulele",
    name: "Ukulele Fretboard",
    storageNamespace: "ukulele",
    stringCount: 4,
    fretCount: 13,
    // frets 0–12
    stringNames: ["A", "E", "C", "G"],
    // 1st (top) to 4th (bottom)
    stringOffsets: [9, 4, 0, 7],
    // A=9, E=4, C=0, G=7
    defaultString: 2,
    // C string (lowest pitch)
    fretMarkers: [3, 5, 7, 10, 12]
  };
  var STRING_NAMES = GUITAR.stringNames;
  var STRING_OFFSETS = GUITAR.stringOffsets;
  var SOLFEGE_MAP = {
    C: "Do",
    D: "Re",
    E: "Mi",
    F: "Fa",
    G: "Sol",
    A: "La",
    B: "Si"
  };
  var _useSolfege = false;
  function getUseSolfege() {
    return _useSolfege;
  }
  function setUseSolfege(v) {
    _useSolfege = v;
    try {
      localStorage.setItem("fretboard_notation", v ? "solfege" : "letter");
    } catch (_) {
    }
  }
  try {
    _useSolfege = localStorage.getItem("fretboard_notation") === "solfege";
  } catch (_) {
  }
  function displayNote(name) {
    if (!name) return name;
    const letter = name[0].toUpperCase();
    const acc = name.slice(1).replace(/#/g, "\u266F").replace(/b/g, "\u266D");
    if (!_useSolfege) {
      return name[0] + acc;
    }
    const syl = SOLFEGE_MAP[letter];
    if (!syl) return name[0] + acc;
    const out = name[0] === name[0].toLowerCase() ? syl.toLowerCase() : syl;
    return out + acc;
  }

  // src/adaptive.js
  var DEFAULT_CONFIG = {
    minTime: 1e3,
    unseenBoost: 3,
    ewmaAlpha: 0.3,
    maxStoredTimes: 10,
    maxResponseTime: 9e3,
    // Forgetting model
    initialStability: 4,
    // hours — half-life after first correct answer
    maxStability: 336,
    // hours (14 days) — stability ceiling
    stabilityGrowthBase: 2,
    // multiplier on each correct answer
    stabilityDecayOnWrong: 0.3,
    // multiplier on wrong answer
    recallThreshold: 0.5,
    // P(recall) below this = "due"
    expansionThreshold: 0.7,
    // fraction of seen items that must be retained before suggesting new strings
    speedBonusMax: 1.5,
    // fast answers grow stability up to this extra factor
    selfCorrectionThreshold: 1500,
    // ms — response time below this triggers self-correction
    automaticityTarget: 3e3,
    // ms — response time at which speedScore ≈ 0.5
    automaticityThreshold: 0.8
    // automaticity above this = "automatic" (matches stats heatmap)
  };
  function computeEwma(oldEwma, newTime, alpha) {
    return alpha * newTime + (1 - alpha) * oldEwma;
  }
  function computeRecall(stabilityHours, elapsedHours) {
    if (stabilityHours == null || elapsedHours == null) return null;
    if (stabilityHours <= 0) return 0;
    if (elapsedHours <= 0) return 1;
    return Math.pow(2, -elapsedHours / stabilityHours);
  }
  function computeSpeedScore(ewmaMs, cfg, responseCount = 1) {
    if (ewmaMs == null) return null;
    const effectiveTarget = cfg.automaticityTarget * responseCount;
    const effectiveMin = cfg.minTime * responseCount;
    const k = Math.LN2 / (effectiveTarget - effectiveMin);
    return Math.exp(-k * Math.max(0, ewmaMs - effectiveMin));
  }
  function computeAutomaticity(recall, speedScore) {
    if (recall == null || speedScore == null) return null;
    return recall * speedScore;
  }
  function computeAutomaticityForDisplay(recall, speedScore, hasSeen) {
    const value = computeAutomaticity(recall, speedScore);
    if (value == null && hasSeen) return 0;
    return value;
  }
  function updateStability(oldStability, responseTimeMs, elapsedHours, cfg) {
    if (oldStability == null) {
      return cfg.initialStability;
    }
    const range = cfg.maxResponseTime - cfg.minTime;
    const clamped = Math.max(cfg.minTime, Math.min(responseTimeMs, cfg.maxResponseTime));
    const t = range > 0 ? (cfg.maxResponseTime - clamped) / range : 0.5;
    const speedFactor = 0.5 + t * (cfg.speedBonusMax - 0.5);
    let newStability = oldStability * cfg.stabilityGrowthBase * speedFactor;
    if (elapsedHours > 0 && responseTimeMs < cfg.selfCorrectionThreshold) {
      newStability = Math.max(newStability, elapsedHours * 1.5);
    }
    return Math.min(newStability, cfg.maxStability);
  }
  function computeStabilityAfterWrong(oldStability, cfg) {
    if (oldStability == null) return cfg.initialStability;
    return Math.max(cfg.initialStability, oldStability * cfg.stabilityDecayOnWrong);
  }
  function computeWeight(stats, cfg) {
    if (!stats) {
      return cfg.unseenBoost;
    }
    const speedWeight = Math.max(stats.ewma, cfg.minTime) / cfg.minTime;
    if (stats.stability != null && stats.lastCorrectAt != null) {
      const elapsedHours = (Date.now() - stats.lastCorrectAt) / 36e5;
      const recall = computeRecall(stats.stability, elapsedHours);
      const recallWeight = recall != null ? 1 + (1 - recall) : 1;
      return speedWeight * recallWeight;
    }
    return speedWeight;
  }
  function selectWeighted(items, weights, rand) {
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    if (totalWeight === 0) {
      return items[Math.floor(rand * items.length)];
    }
    let remaining = rand * totalWeight;
    for (let i = 0; i < items.length; i++) {
      remaining -= weights[i];
      if (remaining <= 0) return items[i];
    }
    return items[items.length - 1];
  }
  function deriveScaledConfig(motorBaseline, baseCfg = DEFAULT_CONFIG) {
    const scale = motorBaseline / 1e3;
    return {
      ...baseCfg,
      minTime: Math.round(baseCfg.minTime * scale),
      automaticityTarget: Math.round(baseCfg.automaticityTarget * scale),
      selfCorrectionThreshold: Math.round(baseCfg.selfCorrectionThreshold * scale),
      maxResponseTime: Math.round(baseCfg.maxResponseTime * scale)
    };
  }
  function computeMedian(values) {
    if (values.length === 0) return null;
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 1) return sorted[mid];
    return (sorted[mid - 1] + sorted[mid]) / 2;
  }
  function createAdaptiveSelector(storage, cfg = DEFAULT_CONFIG, randomFn = Math.random, responseCountFn = null) {
    function getResponseCount(itemId) {
      return responseCountFn ? responseCountFn(itemId) : 1;
    }
    function scaledConfig(itemId) {
      const rc = getResponseCount(itemId);
      if (rc <= 1) return cfg;
      return {
        ...cfg,
        minTime: cfg.minTime * rc,
        automaticityTarget: cfg.automaticityTarget * rc,
        maxResponseTime: cfg.maxResponseTime * rc,
        selfCorrectionThreshold: cfg.selfCorrectionThreshold * rc
      };
    }
    function recordResponse(itemId, timeMs, correct = true) {
      const itemCfg = scaledConfig(itemId);
      const clamped = Math.min(timeMs, itemCfg.maxResponseTime);
      const existing = storage.getStats(itemId);
      const now = Date.now();
      if (correct) {
        const elapsedHours = existing && existing.lastCorrectAt ? (now - existing.lastCorrectAt) / 36e5 : null;
        if (existing) {
          const newEwma = computeEwma(existing.ewma, clamped, cfg.ewmaAlpha);
          const newTimes = [...existing.recentTimes, clamped].slice(
            -cfg.maxStoredTimes
          );
          const newStability = updateStability(
            existing.stability ?? null,
            clamped,
            elapsedHours,
            itemCfg
          );
          storage.saveStats(itemId, {
            recentTimes: newTimes,
            ewma: newEwma,
            sampleCount: existing.sampleCount + 1,
            lastSeen: now,
            stability: newStability,
            lastCorrectAt: now
          });
        } else {
          storage.saveStats(itemId, {
            recentTimes: [clamped],
            ewma: clamped,
            sampleCount: 1,
            lastSeen: now,
            stability: cfg.initialStability,
            lastCorrectAt: now
          });
        }
      } else {
        if (existing) {
          const newStability = computeStabilityAfterWrong(
            existing.stability ?? null,
            cfg
          );
          storage.saveStats(itemId, {
            ...existing,
            lastSeen: now,
            stability: newStability
          });
        } else {
          storage.saveStats(itemId, {
            recentTimes: [],
            ewma: itemCfg.maxResponseTime,
            sampleCount: 0,
            lastSeen: now,
            stability: cfg.initialStability,
            lastCorrectAt: null
          });
        }
      }
    }
    function getWeight(itemId) {
      return computeWeight(storage.getStats(itemId), scaledConfig(itemId));
    }
    function getStats(itemId) {
      return storage.getStats(itemId);
    }
    function selectNext(validItems) {
      if (validItems.length === 0) {
        throw new Error("validItems cannot be empty");
      }
      if (validItems.length === 1) {
        storage.setLastSelected(validItems[0]);
        return validItems[0];
      }
      const lastSelected = storage.getLastSelected();
      const weights = validItems.map(
        (id) => id === lastSelected ? 0 : getWeight(id)
      );
      const selected = selectWeighted(validItems, weights, randomFn());
      storage.setLastSelected(selected);
      return selected;
    }
    function getRecall(itemId) {
      const stats = storage.getStats(itemId);
      if (!stats || stats.stability == null || stats.lastCorrectAt == null) {
        return null;
      }
      const elapsedHours = (Date.now() - stats.lastCorrectAt) / 36e5;
      return computeRecall(stats.stability, elapsedHours);
    }
    function getAutomaticity(itemId) {
      const stats = storage.getStats(itemId);
      if (!stats) return null;
      const recall = getRecall(itemId);
      const speed = computeSpeedScore(stats.ewma, scaledConfig(itemId));
      return computeAutomaticityForDisplay(recall, speed, true);
    }
    function getStringRecommendations(stringIndices, getItemIds) {
      const results = stringIndices.map((s) => {
        const items = getItemIds(s);
        let dueCount = 0;
        let unseenCount = 0;
        let masteredCount = 0;
        for (const id of items) {
          const recall = getRecall(id);
          if (recall === null) {
            unseenCount++;
          } else if (recall < cfg.recallThreshold) {
            dueCount++;
          } else {
            masteredCount++;
          }
        }
        return { string: s, dueCount, unseenCount, masteredCount, totalCount: items.length };
      });
      results.sort((a, b) => b.dueCount + b.unseenCount - (a.dueCount + a.unseenCount));
      return results;
    }
    function checkAllMastered(items) {
      for (const id of items) {
        const recall = getRecall(id);
        if (recall === null || recall < cfg.recallThreshold) return false;
      }
      return items.length > 0;
    }
    function checkAllAutomatic(items) {
      for (const id of items) {
        const auto = getAutomaticity(id);
        if (auto === null || auto <= cfg.automaticityThreshold) return false;
      }
      return items.length > 0;
    }
    function checkNeedsReview(items) {
      if (items.length === 0) return false;
      let hasDueItem = false;
      for (const id of items) {
        const stats = storage.getStats(id);
        if (!stats || stats.lastCorrectAt == null || stats.sampleCount < 2) return false;
        const rc = getResponseCount(id);
        const speed = computeSpeedScore(stats.ewma, cfg, rc);
        if (speed == null || speed < 0.5) return false;
        const recall = getRecall(id);
        if (recall !== null && recall < cfg.recallThreshold) hasDueItem = true;
      }
      return hasDueItem;
    }
    function updateConfig(newCfg) {
      cfg = { ...cfg, ...newCfg };
    }
    function getConfig() {
      return cfg;
    }
    return { recordResponse, selectNext, getStats, getWeight, getRecall, getAutomaticity, getStringRecommendations, checkAllMastered, checkAllAutomatic, checkNeedsReview, updateConfig, getConfig };
  }
  function createLocalStorageAdapter(namespace) {
    const cache = {};
    const mkKey = (itemId) => `adaptive_${namespace}_${itemId}`;
    const dlKey = (itemId) => `deadline_${namespace}_${itemId}`;
    const lastKey = `adaptive_${namespace}_lastSelected`;
    return {
      getStats(itemId) {
        const k = mkKey(itemId);
        if (!(k in cache)) {
          const data = localStorage.getItem(k);
          try {
            cache[k] = data ? JSON.parse(data) : null;
          } catch {
            cache[k] = null;
          }
        }
        return cache[k];
      },
      saveStats(itemId, stats) {
        const k = mkKey(itemId);
        cache[k] = stats;
        localStorage.setItem(k, JSON.stringify(stats));
      },
      getLastSelected() {
        return localStorage.getItem(lastKey);
      },
      setLastSelected(itemId) {
        localStorage.setItem(lastKey, itemId);
      },
      getDeadline(itemId) {
        const k = dlKey(itemId);
        if (!(k in cache)) {
          const data = localStorage.getItem(k);
          cache[k] = data ? Number(data) : null;
        }
        return cache[k];
      },
      saveDeadline(itemId, deadline) {
        const k = dlKey(itemId);
        cache[k] = deadline;
        localStorage.setItem(k, String(deadline));
      },
      /** Pre-populate cache to avoid localStorage reads during gameplay. */
      preload(itemIds) {
        for (const itemId of itemIds) {
          this.getStats(itemId);
        }
      }
    };
  }

  // src/quiz-engine-state.js
  function initialEngineState() {
    return {
      phase: "idle",
      // 'idle' | 'active' | 'round-complete' | 'calibration-intro' | 'calibrating' | 'calibration-results'
      currentItemId: null,
      answered: false,
      questionStartTime: null,
      // Session tracking
      questionCount: 0,
      quizStartTime: null,
      // Round tracking
      roundNumber: 0,
      roundAnswered: 0,
      roundCorrect: 0,
      roundTimerExpired: false,
      roundResponseTimes: [],
      roundDurationMs: 0,
      // Progress tracking
      masteredCount: 0,
      totalEnabledCount: 0,
      // Feedback
      feedbackText: "",
      feedbackClass: "feedback",
      timeDisplayText: "",
      hintText: "",
      // Mastery message
      masteryText: "",
      showMastery: false,
      // Calibration
      calibrationBaseline: null,
      // UI visibility
      quizActive: false,
      answersEnabled: false
    };
  }
  function engineStart(state) {
    return {
      ...state,
      phase: "active",
      questionCount: 0,
      quizStartTime: Date.now(),
      quizActive: true,
      showMastery: false,
      roundNumber: 1,
      roundAnswered: 0,
      roundCorrect: 0,
      roundTimerExpired: false,
      roundResponseTimes: []
    };
  }
  function engineNextQuestion(state, nextItemId, nowMs) {
    return {
      ...state,
      currentItemId: nextItemId,
      answered: false,
      questionStartTime: nowMs,
      questionCount: state.questionCount + 1,
      feedbackText: "",
      feedbackClass: "feedback",
      timeDisplayText: "",
      hintText: "",
      answersEnabled: true
    };
  }
  function engineSubmitAnswer(state, isCorrect, correctAnswer) {
    return {
      ...state,
      answered: true,
      answersEnabled: false,
      feedbackText: isCorrect ? "Correct!" : "Incorrect \u2014 " + correctAnswer,
      feedbackClass: isCorrect ? "feedback correct" : "feedback incorrect",
      timeDisplayText: "",
      hintText: "Tap anywhere or press Space for next",
      roundAnswered: state.roundAnswered + 1,
      roundCorrect: state.roundCorrect + (isCorrect ? 1 : 0)
    };
  }
  function engineRoundTimerExpired(state) {
    return {
      ...state,
      roundTimerExpired: true
    };
  }
  function engineRoundComplete(state) {
    return {
      ...state,
      phase: "round-complete",
      answered: false,
      answersEnabled: false,
      currentItemId: null,
      feedbackText: "",
      feedbackClass: "feedback",
      hintText: ""
    };
  }
  function engineContinueRound(state) {
    return {
      ...state,
      phase: "active",
      roundNumber: state.roundNumber + 1,
      roundAnswered: 0,
      roundCorrect: 0,
      roundTimerExpired: false,
      roundResponseTimes: []
    };
  }
  function engineCalibrationIntro(state, hintOverride) {
    return {
      ...state,
      phase: "calibration-intro",
      showMastery: false,
      quizActive: true,
      answersEnabled: false,
      feedbackText: "Quick Speed Check",
      feedbackClass: "feedback",
      hintText: hintOverride !== void 0 ? hintOverride : "We\u2019ll measure your tap speed to set personalized targets. Tap each highlighted button as fast as you can \u2014 10 taps total.",
      timeDisplayText: "",
      calibrationBaseline: null
    };
  }
  function engineCalibrating(state, hintOverride) {
    return {
      ...state,
      phase: "calibrating",
      answersEnabled: true,
      feedbackText: "Speed check!",
      hintText: hintOverride !== void 0 ? hintOverride : "Tap the highlighted button as fast as you can"
    };
  }
  function engineCalibrationResults(state, baseline) {
    return {
      ...state,
      phase: "calibration-results",
      answersEnabled: false,
      feedbackText: "Speed Check Complete",
      feedbackClass: "feedback",
      hintText: "",
      timeDisplayText: "",
      calibrationBaseline: baseline
    };
  }
  function engineStop(state) {
    return initialEngineState();
  }
  function engineUpdateIdleMessage(state, allMastered, needsReview) {
    if (state.phase !== "idle") return state;
    if (allMastered) {
      return { ...state, masteryText: "Looks like you\u2019ve got this!", showMastery: true };
    }
    if (needsReview) {
      return { ...state, masteryText: "Time to review?", showMastery: true };
    }
    return { ...state, masteryText: "", showMastery: false };
  }
  function engineUpdateMasteryAfterAnswer(state, allMastered) {
    if (allMastered) {
      return { ...state, masteryText: "Looks like you\u2019ve got this!", showMastery: true };
    }
    return { ...state, showMastery: false };
  }
  function engineUpdateProgress(state, masteredCount, totalEnabledCount) {
    return { ...state, masteredCount, totalEnabledCount };
  }
  function engineRouteKey(state, key) {
    if (state.phase === "idle") return { action: "ignore" };
    if (key === "Escape") return { action: "stop" };
    if (state.phase === "round-complete") {
      if (key === " " || key === "Enter") return { action: "continue" };
      return { action: "ignore" };
    }
    if (state.phase !== "active") return { action: "ignore" };
    if ((key === " " || key === "Enter") && state.answered) return { action: "next" };
    if (!state.answered) return { action: "delegate" };
    return { action: "ignore" };
  }

  // src/quiz-engine.js
  function createNoteKeyHandler(submitAnswer, allowAccidentals = () => true) {
    let pendingNote = null;
    let pendingTimeout = null;
    function reset() {
      if (pendingTimeout) clearTimeout(pendingTimeout);
      pendingNote = null;
      pendingTimeout = null;
    }
    function handleKey(e) {
      const key = e.key.toUpperCase();
      if (pendingNote && allowAccidentals()) {
        if (e.key === "#" || e.key === "s" || e.key === "S" || e.shiftKey && e.key === "3") {
          e.preventDefault();
          clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "#");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
        if (e.key === "b" || e.key === "B") {
          e.preventDefault();
          clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "b");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
      }
      if ("CDEFGAB".includes(key)) {
        e.preventDefault();
        if (pendingTimeout) clearTimeout(pendingTimeout);
        if (!allowAccidentals()) {
          submitAnswer(key);
        } else {
          pendingNote = key;
          pendingTimeout = setTimeout(() => {
            submitAnswer(pendingNote);
            pendingNote = null;
            pendingTimeout = null;
          }, 400);
        }
        return true;
      }
      return false;
    }
    return { handleKey, reset };
  }
  function createSolfegeKeyHandler(submitAnswer, allowAccidentals = () => true) {
    const SOLFEGE_TO_NOTE = {
      "do": "C",
      "re": "D",
      "mi": "E",
      "fa": "F",
      "so": "G",
      "la": "A",
      "si": "B"
    };
    const FIRST_CHARS = /* @__PURE__ */ new Set(["d", "r", "m", "f", "s", "l"]);
    let buffer = "";
    let pendingNote = null;
    let pendingTimeout = null;
    function reset() {
      buffer = "";
      if (pendingTimeout) clearTimeout(pendingTimeout);
      pendingTimeout = null;
      pendingNote = null;
    }
    function submitPending() {
      if (pendingNote) {
        clearTimeout(pendingTimeout);
        submitAnswer(pendingNote);
        pendingNote = null;
        pendingTimeout = null;
      }
    }
    function handleKey(e) {
      const key = e.key.toLowerCase();
      if (pendingNote && allowAccidentals()) {
        if (e.key === "#" || e.shiftKey && e.key === "3") {
          e.preventDefault();
          clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "#");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
        if (key === "b") {
          e.preventDefault();
          clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "b");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
      }
      if (pendingNote && FIRST_CHARS.has(key)) {
        submitPending();
      }
      if (buffer.length > 0) {
        e.preventDefault();
        buffer += key;
        const note = SOLFEGE_TO_NOTE[buffer];
        if (note) {
          buffer = "";
          if (!allowAccidentals()) {
            submitAnswer(note);
          } else {
            pendingNote = note;
            pendingTimeout = setTimeout(() => {
              submitAnswer(pendingNote);
              pendingNote = null;
              pendingTimeout = null;
            }, 400);
          }
        } else if (buffer.length >= 2) {
          buffer = "";
        }
        return true;
      }
      if (FIRST_CHARS.has(key)) {
        e.preventDefault();
        submitPending();
        buffer = key;
        return true;
      }
      return false;
    }
    return { handleKey, reset };
  }
  function createAdaptiveKeyHandler(submitAnswer, allowAccidentals = () => true) {
    const letterHandler = createNoteKeyHandler(submitAnswer, allowAccidentals);
    const solfegeHandler = createSolfegeKeyHandler(submitAnswer, allowAccidentals);
    return {
      handleKey(e) {
        return getUseSolfege() ? solfegeHandler.handleKey(e) : letterHandler.handleKey(e);
      },
      reset() {
        letterHandler.reset();
        solfegeHandler.reset();
      }
    };
  }
  function refreshNoteButtonLabels(container) {
    container.querySelectorAll(".answer-btn-note").forEach(function(btn) {
      var note = NOTES.find(function(n) {
        return n.name === btn.dataset.note;
      });
      if (note) btn.textContent = displayNote(note.name);
    });
    container.querySelectorAll(".note-btn").forEach(function(btn) {
      var noteName = btn.dataset.note;
      if (noteName) btn.textContent = displayNote(noteName);
    });
    container.querySelectorAll(".string-toggle").forEach(function(btn) {
      var stringNote = btn.dataset.stringNote;
      if (stringNote) btn.textContent = displayNote(stringNote);
    });
  }
  function getCalibrationThresholds(baseline) {
    return [
      { label: "Automatic", maxMs: Math.round(baseline * 1.5), meaning: "Fully memorized \u2014 instant recall" },
      { label: "Good", maxMs: Math.round(baseline * 3), meaning: "Solid recall, minor hesitation" },
      { label: "Developing", maxMs: Math.round(baseline * 4.5), meaning: "Working on it \u2014 needs practice" },
      { label: "Slow", maxMs: Math.round(baseline * 6), meaning: "Significant hesitation" },
      { label: "Very slow", maxMs: null, meaning: "Not yet learned" }
    ];
  }
  function getKeyForButton(btn) {
    const note = btn.dataset.note;
    if (note && note.length === 1 && "CDEFGAB".includes(note.toUpperCase())) return note.toUpperCase();
    const num = btn.dataset.num;
    if (num !== void 0 && num.length === 1) return num;
    return null;
  }
  function pickCalibrationButton(buttons, prevBtn, rng) {
    const rand = rng || Math.random;
    const sharpBtns = buttons.filter((b) => {
      const note = b.dataset.note;
      return note && note.includes("#");
    });
    const naturalBtns = buttons.filter((b) => {
      const note = b.dataset.note;
      return note && !note.includes("#");
    });
    const useSharp = sharpBtns.length > 0 && rand() < 0.35;
    const pool = useSharp ? sharpBtns : naturalBtns.length > 0 ? naturalBtns : buttons;
    let btn;
    do {
      btn = pool[Math.floor(rand() * pool.length)];
    } while (btn === prevBtn && pool.length > 1);
    return btn;
  }
  function runCalibration(opts) {
    const { buttons, els, container, onComplete, getTrialConfig } = opts;
    const TRIAL_COUNT = 10;
    const PAUSE_MS = 400;
    const WARMUP_TRIALS = 2;
    const times = [];
    let trialIndex = 0;
    let targetBtn = null;
    let trialStartTime = null;
    let prevBtn = null;
    let canceled = false;
    let pendingTimeout = null;
    let trialConfig = null;
    let targetIndex = 0;
    let pressStartTime = null;
    let pendingNote = null;
    let pendingNoteTimeout = null;
    function isSearchMode() {
      return !!getTrialConfig;
    }
    function startTrial() {
      if (canceled) return;
      if (trialIndex >= TRIAL_COUNT) {
        cleanup();
        const median = computeMedian(times);
        onComplete(median);
        return;
      }
      if (isSearchMode()) {
        trialConfig = getTrialConfig(buttons, prevBtn);
        targetIndex = 0;
        targetBtn = trialConfig.targetButtons[0];
        pressStartTime = Date.now();
        trialStartTime = Date.now();
        if (els.quizPrompt) els.quizPrompt.textContent = trialConfig.prompt;
      } else {
        let idx;
        let prevBtnIndex = prevBtn ? buttons.indexOf(prevBtn) : -1;
        do {
          idx = Math.floor(Math.random() * buttons.length);
        } while (idx === prevBtnIndex && buttons.length > 1);
        targetBtn = buttons[idx];
        targetBtn.classList.add("calibration-target");
        trialStartTime = Date.now();
      }
      prevBtn = targetBtn;
      if (els.progressText) els.progressText.textContent = trialIndex + " / " + TRIAL_COUNT;
      if (els.progressFill) els.progressFill.style.width = Math.round(trialIndex / TRIAL_COUNT * 100) + "%";
    }
    function recordPress() {
      const now = Date.now();
      const elapsed = now - (isSearchMode() ? pressStartTime : trialStartTime);
      if (trialIndex >= WARMUP_TRIALS) {
        times.push(elapsed);
      }
      if (isSearchMode() && trialConfig && targetIndex < trialConfig.targetButtons.length - 1) {
        targetIndex++;
        targetBtn = trialConfig.targetButtons[targetIndex];
        pressStartTime = now;
        return;
      }
      if (!isSearchMode() && targetBtn) {
        targetBtn.classList.remove("calibration-target");
      }
      targetBtn = null;
      trialConfig = null;
      trialIndex++;
      pendingTimeout = setTimeout(startTrial, PAUSE_MS);
    }
    function handleCalibrationClick(e) {
      if (!targetBtn) return;
      const clicked = e.target.closest(".note-btn, .answer-btn");
      if (clicked === targetBtn) {
        clearPendingNote();
        recordPress();
      }
    }
    function clearPendingNote() {
      if (pendingNoteTimeout) clearTimeout(pendingNoteTimeout);
      pendingNote = null;
      pendingNoteTimeout = null;
    }
    function checkNoteMatch(noteName) {
      if (!targetBtn) return false;
      const targetNote = targetBtn.dataset.note;
      return targetNote && targetNote.toUpperCase() === noteName.toUpperCase();
    }
    function handleCalibrationKey(e) {
      if (!targetBtn) return;
      if (isSearchMode()) {
        const key = e.key.toUpperCase();
        if (pendingNote) {
          if (e.key === "#" || e.key === "s" || e.key === "S" || e.shiftKey && e.key === "3") {
            e.preventDefault();
            clearTimeout(pendingNoteTimeout);
            const combined = pendingNote + "#";
            pendingNote = null;
            pendingNoteTimeout = null;
            if (checkNoteMatch(combined)) recordPress();
            return;
          }
          if (e.key === "b" || e.key === "B") {
            if (pendingNote !== "B") {
              e.preventDefault();
              clearTimeout(pendingNoteTimeout);
              const combined = pendingNote + "b";
              pendingNote = null;
              pendingNoteTimeout = null;
              if (checkNoteMatch(combined)) recordPress();
              return;
            }
          }
        }
        if ("CDEFGAB".includes(key)) {
          e.preventDefault();
          clearPendingNote();
          const targetNote = targetBtn.dataset.note;
          if (targetNote && !targetNote.includes("#")) {
            if (checkNoteMatch(key)) recordPress();
          } else {
            pendingNote = key;
            pendingNoteTimeout = setTimeout(() => {
              if (checkNoteMatch(pendingNote)) recordPress();
              pendingNote = null;
              pendingNoteTimeout = null;
            }, 400);
          }
          return;
        }
      } else {
        const expectedKey = getKeyForButton(targetBtn);
        if (expectedKey && e.key.toUpperCase() === expectedKey) {
          e.preventDefault();
          recordPress();
        }
      }
    }
    function cleanup() {
      canceled = true;
      clearPendingNote();
      if (pendingTimeout !== null) {
        clearTimeout(pendingTimeout);
        pendingTimeout = null;
      }
      container.removeEventListener("click", handleCalibrationClick);
      document.removeEventListener("keydown", handleCalibrationKey);
      if (targetBtn && !isSearchMode()) {
        targetBtn.classList.remove("calibration-target");
      }
      targetBtn = null;
      trialConfig = null;
    }
    container.addEventListener("click", handleCalibrationClick);
    document.addEventListener("keydown", handleCalibrationKey);
    startTrial();
    return cleanup;
  }
  var ROUND_DURATION_MS = 6e4;
  function createQuizEngine(mode, container) {
    const storage = createLocalStorageAdapter(mode.storageNamespace);
    const responseCountFn = mode.getExpectedResponseCount ? (itemId) => mode.getExpectedResponseCount(itemId) : null;
    const selector = createAdaptiveSelector(storage, DEFAULT_CONFIG, Math.random, responseCountFn);
    const provider = mode.calibrationProvider || "button";
    const baselineKey = "motorBaseline_" + provider;
    const legacyBaselineKey = "motorBaseline_" + mode.storageNamespace;
    let motorBaseline = null;
    let calibrationCleanup = null;
    let calibrationContentEl = null;
    let storedBaseline = localStorage.getItem(baselineKey);
    if (!storedBaseline && legacyBaselineKey !== baselineKey) {
      storedBaseline = localStorage.getItem(legacyBaselineKey);
      if (storedBaseline) {
        localStorage.setItem(baselineKey, storedBaseline);
      }
    }
    if (storedBaseline) {
      const parsed = parseInt(storedBaseline, 10);
      if (parsed > 0) {
        motorBaseline = parsed;
        const scaledConfig = deriveScaledConfig(motorBaseline, DEFAULT_CONFIG);
        selector.updateConfig(scaledConfig);
      }
    }
    let state = initialEngineState();
    let roundTimerInterval = null;
    let roundTimerStart = null;
    let autoAdvanceTimer = null;
    const els = {
      feedback: container.querySelector(".feedback"),
      timeDisplay: container.querySelector(".time-display"),
      hint: container.querySelector(".hint"),
      stats: container.querySelector(".stats"),
      quizArea: container.querySelector(".quiz-area"),
      quizPrompt: container.querySelector(".quiz-prompt"),
      masteryMessage: container.querySelector(".mastery-message"),
      baselineInfo: container.querySelector(".baseline-info"),
      quizHeaderClose: container.querySelector(".quiz-header-close"),
      countdownFill: container.querySelector(".quiz-countdown-fill"),
      countdownBar: container.querySelector(".quiz-countdown-bar"),
      quizInfoContext: container.querySelector(".quiz-info-context"),
      quizInfoTime: container.querySelector(".quiz-info-time"),
      quizLastQuestion: container.querySelector(".quiz-last-question"),
      quizInfoCount: container.querySelector(".quiz-info-count"),
      progressFill: container.querySelector(".progress-fill"),
      progressText: container.querySelector(".progress-text"),
      roundCompleteEl: container.querySelector(".round-complete")
    };
    function clearCalibrationContent() {
      if (calibrationContentEl) {
        calibrationContentEl.remove();
        calibrationContentEl = null;
      }
    }
    function insertAfterHint(el) {
      if (els.hint && els.hint.parentNode) {
        els.hint.parentNode.insertBefore(el, els.hint.nextSibling);
      }
    }
    function renderCalibrationIntro() {
      clearCalibrationContent();
      const btn = document.createElement("button");
      btn.textContent = "Start";
      btn.className = "calibration-action-btn";
      btn.addEventListener("click", beginCalibrationTrials);
      calibrationContentEl = btn;
      insertAfterHint(btn);
    }
    function renderCalibrationResults() {
      clearCalibrationContent();
      const baseline = state.calibrationBaseline;
      const thresholds = getCalibrationThresholds(baseline);
      const div = document.createElement("div");
      div.className = "calibration-results";
      const baselineP = document.createElement("p");
      baselineP.className = "calibration-baseline";
      baselineP.textContent = "Your baseline response time: " + formatMs(baseline);
      div.appendChild(baselineP);
      const table = document.createElement("table");
      table.className = "calibration-thresholds";
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      ["Speed", "Response time", "Meaning"].forEach((text) => {
        const th = document.createElement("th");
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement("tbody");
      thresholds.forEach((t) => {
        const tr = document.createElement("tr");
        const tdLabel = document.createElement("td");
        tdLabel.textContent = t.label;
        tr.appendChild(tdLabel);
        const tdTime = document.createElement("td");
        tdTime.textContent = t.maxMs !== null ? "< " + formatMs(t.maxMs) : "> " + formatMs(thresholds[thresholds.length - 2].maxMs);
        tr.appendChild(tdTime);
        const tdMeaning = document.createElement("td");
        tdMeaning.textContent = t.meaning;
        tr.appendChild(tdMeaning);
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      div.appendChild(table);
      const doneBtn = document.createElement("button");
      doneBtn.textContent = "Done";
      doneBtn.className = "calibration-action-btn";
      doneBtn.addEventListener("click", finishCalibration);
      div.appendChild(doneBtn);
      calibrationContentEl = div;
      insertAfterHint(div);
    }
    function isCalibrationPhase(phase) {
      return phase === "calibration-intro" || phase === "calibrating" || phase === "calibration-results";
    }
    function renderPhaseClass() {
      var inCalibration = isCalibrationPhase(state.phase);
      if (state.phase !== "calibration-intro" && state.phase !== "calibration-results") {
        clearCalibrationContent();
      }
      var phaseClass = inCalibration ? "phase-calibration" : state.phase === "active" ? "phase-active" : state.phase === "round-complete" ? "phase-round-complete" : "phase-idle";
      container.classList.remove("phase-idle", "phase-active", "phase-calibration", "phase-round-complete");
      container.classList.add(phaseClass);
      return { inCalibration, phaseClass };
    }
    function renderCalibrationMarking(inCalibration) {
      if (inCalibration && !container.querySelector(".calibration-active")) {
        var buttons = getCalibrationButtons();
        if (buttons.length > 0) {
          var parent = buttons[0].closest(".answer-buttons, .note-buttons");
          if (parent) parent.classList.add("calibration-active");
        }
      }
      if (!inCalibration) {
        var activeEl = container.querySelector(".calibration-active");
        if (activeEl) activeEl.classList.remove("calibration-active");
      }
      container.classList.remove("calibration-intro", "calibration-results");
      if (state.phase === "calibration-intro") container.classList.add("calibration-intro");
      if (state.phase === "calibration-results") container.classList.add("calibration-results");
    }
    function renderHeader(inCalibration) {
      if (els.quizArea) els.quizArea.classList.toggle("active", state.quizActive);
    }
    function renderFeedback(inCalibration) {
      if (inCalibration) {
        if (els.quizPrompt) els.quizPrompt.textContent = state.feedbackText;
        if (els.feedback) {
          els.feedback.textContent = "";
          els.feedback.className = "feedback";
        }
      } else {
        if (els.feedback) {
          els.feedback.textContent = state.feedbackText;
          els.feedback.className = state.feedbackClass;
        }
        if (els.quizPrompt && state.phase === "idle") {
          els.quizPrompt.textContent = "";
        }
      }
      if (els.timeDisplay) els.timeDisplay.textContent = state.timeDisplayText;
      if (els.hint) els.hint.textContent = state.hintText;
    }
    function renderMessages() {
      if (els.masteryMessage) {
        els.masteryMessage.textContent = state.masteryText;
        els.masteryMessage.classList.toggle("mastery-visible", state.showMastery);
      }
    }
    function renderSessionStats() {
      if (state.phase === "active") {
        if (els.quizInfoContext) {
          var label = mode.getPracticingLabel ? mode.getPracticingLabel() : "";
          els.quizInfoContext.textContent = label;
        }
        if (els.quizInfoCount) {
          var count = state.roundAnswered;
          els.quizInfoCount.textContent = count + (count === 1 ? " answer" : " answers");
        }
      }
    }
    function renderProgress() {
      if (els.progressFill) {
        var pct = state.totalEnabledCount > 0 ? Math.round(state.masteredCount / state.totalEnabledCount * 100) : 0;
        els.progressFill.style.width = pct + "%";
      }
      if (els.progressText) {
        els.progressText.textContent = state.masteredCount + " / " + state.totalEnabledCount + " fluent";
      }
    }
    function renderRoundComplete() {
      if (els.roundCompleteEl && state.phase === "round-complete") {
        var contextEl = els.roundCompleteEl.querySelector(".round-complete-context");
        if (contextEl) {
          var label = mode.getPracticingLabel ? mode.getPracticingLabel() : "";
          var fluencyText = state.masteredCount + " / " + state.totalEnabledCount + " fluent";
          contextEl.textContent = label ? label + " \xB7 " + fluencyText : fluencyText;
        }
        var heading = els.roundCompleteEl.querySelector(".round-complete-heading");
        if (heading) heading.textContent = "Round complete";
        var correctEl = els.roundCompleteEl.querySelector(".round-stat-correct");
        if (correctEl) {
          var durationSec = Math.round((state.roundDurationMs || 0) / 1e3);
          correctEl.textContent = state.roundCorrect + " / " + state.roundAnswered + " correct \xB7 " + durationSec + "s";
        }
        var medianEl = els.roundCompleteEl.querySelector(".round-stat-median");
        if (medianEl) {
          if (state.roundResponseTimes && state.roundResponseTimes.length > 0) {
            var sorted = state.roundResponseTimes.slice().sort(function(a, b) {
              return a - b;
            });
            var mid = Math.floor(sorted.length / 2);
            var median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
            medianEl.textContent = (median / 1e3).toFixed(1) + "s median response time";
          } else {
            medianEl.textContent = "";
          }
        }
      }
    }
    function renderCalibrationContent() {
      if (state.phase === "calibration-intro" && !calibrationContentEl) {
        renderCalibrationIntro();
      } else if (state.phase === "calibration-results" && !calibrationContentEl) {
        renderCalibrationResults();
      }
    }
    function renderBaselineInfo() {
      if (!els.baselineInfo) return;
      els.baselineInfo.textContent = "";
      var text = document.createElement("span");
      var btn = document.createElement("button");
      btn.className = "baseline-rerun-btn";
      btn.addEventListener("click", function() {
        startCalibration();
      });
      if (motorBaseline) {
        text.textContent = "Response time baseline: " + formatMs(motorBaseline) + " ";
        btn.textContent = "Rerun speed check";
      } else {
        text.textContent = "Response time baseline: 1s (default). Do a speed check (10 taps, ~15s) to track progress more accurately. ";
        btn.textContent = "Speed check";
      }
      els.baselineInfo.appendChild(text);
      els.baselineInfo.appendChild(btn);
    }
    function render() {
      var ctx = renderPhaseClass();
      renderCalibrationMarking(ctx.inCalibration);
      renderHeader(ctx.inCalibration);
      renderFeedback(ctx.inCalibration);
      renderMessages();
      renderSessionStats();
      renderProgress();
      setAnswerButtonsEnabled(state.answersEnabled);
      renderRoundComplete();
      renderCalibrationContent();
    }
    function formatRoundTime(ms) {
      const totalSec = Math.max(0, Math.ceil(ms / 1e3));
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return min + ":" + (sec < 10 ? "0" : "") + sec;
    }
    function startRoundTimer() {
      if (roundTimerInterval) clearInterval(roundTimerInterval);
      roundTimerStart = Date.now();
      if (els.countdownFill) els.countdownFill.style.width = "100%";
      if (els.countdownBar) els.countdownBar.classList.remove("round-timer-warning");
      if (els.quizInfoTime) els.quizInfoTime.textContent = formatRoundTime(ROUND_DURATION_MS);
      roundTimerInterval = setInterval(() => {
        const elapsed = Date.now() - roundTimerStart;
        const remaining = ROUND_DURATION_MS - elapsed;
        const pct = Math.max(0, remaining / ROUND_DURATION_MS * 100);
        if (els.countdownFill) els.countdownFill.style.width = pct + "%";
        if (els.quizInfoTime) els.quizInfoTime.textContent = formatRoundTime(remaining);
        if (els.countdownBar) {
          els.countdownBar.classList.toggle("round-timer-warning", remaining <= 1e4 && remaining > 0);
        }
        if (remaining <= 0) {
          clearInterval(roundTimerInterval);
          roundTimerInterval = null;
          if (els.countdownFill) els.countdownFill.style.width = "0%";
          if (els.quizInfoTime) els.quizInfoTime.textContent = "0:00";
          if (els.countdownBar) els.countdownBar.classList.remove("round-timer-warning");
          handleRoundTimerExpiry();
        }
      }, 200);
    }
    function stopRoundTimer() {
      if (roundTimerInterval) {
        clearInterval(roundTimerInterval);
        roundTimerInterval = null;
      }
      roundTimerStart = null;
      if (els.countdownFill) els.countdownFill.style.width = "100%";
      if (els.countdownBar) {
        els.countdownBar.classList.remove("round-timer-warning");
        els.countdownBar.classList.remove("last-question");
      }
      if (els.quizInfoTime) els.quizInfoTime.textContent = "";
      if (els.quizLastQuestion) els.quizLastQuestion.textContent = "";
    }
    function handleRoundTimerExpiry() {
      if (state.phase !== "active") return;
      state = engineRoundTimerExpired(state);
      if (state.answered) {
        transitionToRoundComplete();
      } else {
        if (els.quizLastQuestion) els.quizLastQuestion.textContent = "Last question";
        if (els.countdownBar) els.countdownBar.classList.add("last-question");
      }
    }
    function transitionToRoundComplete() {
      var roundDurationMs = roundTimerStart ? Date.now() - roundTimerStart : 0;
      stopRoundTimer();
      state = engineRoundComplete(state);
      state = { ...state, roundDurationMs };
      render();
    }
    function getResponseCount(itemId) {
      return mode.getExpectedResponseCount ? mode.getExpectedResponseCount(itemId) : 1;
    }
    function setAnswerButtonsEnabled(enabled) {
      container.querySelectorAll(".answer-btn, .note-btn").forEach((btn) => {
        btn.disabled = !enabled;
        btn.style.pointerEvents = enabled ? "" : "none";
      });
    }
    function syncBaselineFromStorage() {
      if (motorBaseline) return;
      const stored = localStorage.getItem(baselineKey);
      if (stored) {
        const parsed = parseInt(stored, 10);
        if (parsed > 0) {
          applyBaseline(parsed);
        }
      }
    }
    function applyBaseline(baseline) {
      motorBaseline = baseline;
      localStorage.setItem(baselineKey, String(baseline));
      const scaledConfig = deriveScaledConfig(baseline, DEFAULT_CONFIG);
      selector.updateConfig(scaledConfig);
      renderBaselineInfo();
    }
    function getCalibrationButtons() {
      if (mode.getCalibrationButtons) return mode.getCalibrationButtons();
      return Array.from(container.querySelectorAll(".note-btn:not(.hidden), .answer-btn"));
    }
    function formatMs(ms) {
      return (ms / 1e3).toFixed(1) + "s";
    }
    function hasSearchCalibration() {
      return typeof mode.getCalibrationTrialConfig === "function";
    }
    function getCalibrationIntroHint() {
      if (mode.calibrationIntroHint) return mode.calibrationIntroHint;
      if (hasSearchCalibration()) {
        return "We\u2019ll measure your response speed to set personalized targets. Press the button shown in the prompt \u2014 10 rounds total.";
      }
      return void 0;
    }
    function getCalibrationTrialHint() {
      if (hasSearchCalibration()) return "";
      return void 0;
    }
    function startCalibration() {
      if (mode.onStart) mode.onStart();
      state = engineCalibrationIntro(state, getCalibrationIntroHint());
      render();
    }
    function beginCalibrationTrials() {
      const buttons = getCalibrationButtons();
      if (buttons.length < 2) {
        stop();
        return;
      }
      state = engineCalibrating(state, getCalibrationTrialHint());
      render();
      const getTrialConfig = hasSearchCalibration() ? (btns, prevBtn) => mode.getCalibrationTrialConfig(btns, prevBtn) : void 0;
      calibrationCleanup = runCalibration({
        buttons,
        els,
        container,
        getTrialConfig,
        onComplete: (median) => {
          calibrationCleanup = null;
          if (!Number.isFinite(median) || median <= 0) {
            stop();
            return;
          }
          const baseline = Math.round(median);
          applyBaseline(baseline);
          state = engineCalibrationResults(state, baseline);
          render();
        }
      });
    }
    function finishCalibration() {
      stop();
    }
    function computeProgress() {
      const items = mode.getEnabledItems();
      let mastered = 0;
      const threshold = selector.getConfig().automaticityThreshold;
      for (const id of items) {
        const auto = selector.getAutomaticity(id);
        if (auto !== null && auto > threshold) {
          mastered++;
        }
      }
      return { masteredCount: mastered, totalEnabledCount: items.length };
    }
    function nextQuestion() {
      if (autoAdvanceTimer) {
        clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
      if (state.roundTimerExpired) {
        transitionToRoundComplete();
        return;
      }
      const items = mode.getEnabledItems();
      if (items.length === 0) return;
      const nextItemId = selector.selectNext(items);
      state = engineNextQuestion(state, nextItemId, Date.now());
      render();
      mode.presentQuestion(state.currentItemId);
    }
    function submitAnswer(input) {
      if (state.phase !== "active" || state.answered) return;
      const responseTime = Date.now() - state.questionStartTime;
      const result = mode.checkAnswer(state.currentItemId, input);
      selector.recordResponse(state.currentItemId, responseTime, result.correct);
      state = engineSubmitAnswer(state, result.correct, result.correctAnswer);
      state = { ...state, roundResponseTimes: [...state.roundResponseTimes, responseTime] };
      const allMastered = selector.checkAllAutomatic(mode.getEnabledItems());
      state = engineUpdateMasteryAfterAnswer(state, allMastered);
      const progress = computeProgress();
      state = engineUpdateProgress(state, progress.masteredCount, progress.totalEnabledCount);
      render();
      if (mode.onAnswer) {
        mode.onAnswer(state.currentItemId, result, responseTime);
      }
      if (state.roundTimerExpired) {
        setTimeout(() => {
          if (state.phase === "active") transitionToRoundComplete();
        }, 600);
      } else {
        autoAdvanceTimer = setTimeout(() => {
          if (state.phase === "active" && state.answered) nextQuestion();
        }, 1e3);
      }
    }
    function start() {
      state = engineStart(state);
      if (mode.onStart) mode.onStart();
      const progress = computeProgress();
      state = engineUpdateProgress(state, progress.masteredCount, progress.totalEnabledCount);
      render();
      startRoundTimer();
      nextQuestion();
    }
    function continueQuiz() {
      state = engineContinueRound(state);
      render();
      startRoundTimer();
      nextQuestion();
    }
    function updateIdleMessage() {
      if (state.phase !== "idle") return;
      const items = mode.getEnabledItems();
      state = engineUpdateIdleMessage(
        state,
        selector.checkAllAutomatic(items),
        selector.checkNeedsReview(items)
      );
      render();
    }
    function stop() {
      if (autoAdvanceTimer) {
        clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
      if (calibrationCleanup) {
        calibrationCleanup();
        calibrationCleanup = null;
      }
      stopRoundTimer();
      state = engineStop(state);
      render();
      if (mode.onStop) mode.onStop();
      updateIdleMessage();
    }
    function handleKeydown(e) {
      const routed = engineRouteKey(state, e.key);
      switch (routed.action) {
        case "stop":
          e.stopImmediatePropagation();
          stop();
          break;
        case "next":
          e.preventDefault();
          if (autoAdvanceTimer) {
            clearTimeout(autoAdvanceTimer);
            autoAdvanceTimer = null;
          }
          nextQuestion();
          break;
        case "continue":
          e.preventDefault();
          continueQuiz();
          break;
        case "delegate":
          if (mode.handleKey) mode.handleKey(e, { submitAnswer });
          break;
        case "ignore":
          break;
      }
    }
    function handleClick(e) {
      if (state.phase === "round-complete") return;
      if (state.phase !== "active" || !state.answered) return;
      if (e.target.closest(".answer-btn, .note-btn, .string-toggle")) return;
      if (autoAdvanceTimer) {
        clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
      nextQuestion();
    }
    function attach() {
      syncBaselineFromStorage();
      document.addEventListener("keydown", handleKeydown);
      container.addEventListener("click", handleClick);
      refreshNoteButtonLabels(container);
      var activeStatsBtn = container.querySelector(".stats-toggle-btn.active");
      if (activeStatsBtn) activeStatsBtn.click();
    }
    function detach() {
      document.removeEventListener("keydown", handleKeydown);
      container.removeEventListener("click", handleClick);
    }
    if (els.quizHeaderClose) {
      els.quizHeaderClose.addEventListener("click", stop);
    }
    if (els.roundCompleteEl) {
      const keepGoingBtn = els.roundCompleteEl.querySelector(".round-complete-continue");
      const stopBtn = els.roundCompleteEl.querySelector(".round-complete-stop");
      if (keepGoingBtn) keepGoingBtn.addEventListener("click", continueQuiz);
      if (stopBtn) stopBtn.addEventListener("click", stop);
    }
    function showCalibrationIfNeeded() {
      syncBaselineFromStorage();
      if (!motorBaseline && state.phase === "idle") {
        startCalibration();
      }
    }
    renderBaselineInfo();
    return {
      start,
      stop,
      showCalibrationIfNeeded,
      submitAnswer,
      nextQuestion,
      continueQuiz,
      attach,
      detach,
      updateIdleMessage,
      get isActive() {
        return state.phase === "active";
      },
      get isRunning() {
        return state.phase !== "idle";
      },
      get isAnswered() {
        return state.answered;
      },
      get baseline() {
        return motorBaseline;
      },
      selector,
      storage,
      els
    };
  }

  // src/stats-display.js
  var _heatmapColors = null;
  function cssVar(name) {
    try {
      var val = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      if (val) return val;
    } catch (_) {
    }
    return "";
  }
  function heatmapColors() {
    if (!_heatmapColors) {
      _heatmapColors = {
        none: cssVar("--heatmap-none") || "hsl(30, 4%, 85%)",
        level: [
          cssVar("--heatmap-1") || "hsl(12, 48%, 65%)",
          cssVar("--heatmap-2") || "hsl(30, 48%, 58%)",
          cssVar("--heatmap-3") || "hsl(50, 40%, 50%)",
          cssVar("--heatmap-4") || "hsl(72, 38%, 42%)",
          cssVar("--heatmap-5") || "hsl(90, 45%, 35%)"
        ]
      };
    }
    return _heatmapColors;
  }
  var RETENTION_LABELS = [
    "Needs work (&lt;20%)",
    "Fading (&gt;20%)",
    "Getting there (&gt;40%)",
    "Solid (&gt;60%)",
    "Automatic (&gt;80%)"
  ];
  function getAutomaticityColor(auto) {
    var c = heatmapColors();
    if (auto === null) return c.none;
    if (auto > 0.8) return c.level[4];
    if (auto > 0.6) return c.level[3];
    if (auto > 0.4) return c.level[2];
    if (auto > 0.2) return c.level[1];
    return c.level[0];
  }
  function getSpeedHeatmapColor(ms, baseline) {
    var c = heatmapColors();
    if (ms === null) return c.none;
    var b = baseline || 1e3;
    if (ms < b * 1.5) return c.level[4];
    if (ms < b * 3) return c.level[3];
    if (ms < b * 4.5) return c.level[2];
    if (ms < b * 6) return c.level[1];
    return c.level[0];
  }
  function getStatsCellColor(selector, itemId, statsMode, baseline) {
    if (statsMode === "retention") {
      return getAutomaticityColor(selector.getAutomaticity(itemId));
    }
    var stats = selector.getStats(itemId);
    return getSpeedHeatmapColor(stats ? stats.ewma : null, baseline);
  }
  function getStatsCellColorMerged(selector, itemIds, statsMode, baseline) {
    if (typeof itemIds === "string") return getStatsCellColor(selector, itemIds, statsMode, baseline);
    if (statsMode === "retention") {
      var sum = 0, count = 0;
      for (var i = 0; i < itemIds.length; i++) {
        var a = selector.getAutomaticity(itemIds[i]);
        if (a !== null) {
          sum += a;
          count++;
        }
      }
      return getAutomaticityColor(count > 0 ? sum / count : null);
    }
    var sum2 = 0, count2 = 0;
    for (var j = 0; j < itemIds.length; j++) {
      var stats = selector.getStats(itemIds[j]);
      if (stats && stats.ewma != null) {
        sum2 += stats.ewma;
        count2++;
      }
    }
    return getSpeedHeatmapColor(count2 > 0 ? sum2 / count2 : null, baseline);
  }
  function renderStatsTable(selector, rows, fwdHeader, revHeader, statsMode, containerEl, baseline) {
    if (!rows || rows.length === 0) {
      containerEl.innerHTML = "";
      return;
    }
    var html = '<table class="stats-table"><thead><tr>';
    html += "<th>" + rows[0]._colHeader + "</th><th>#</th>";
    html += "<th>" + fwdHeader + "</th><th>" + revHeader + "</th>";
    html += "</tr></thead><tbody>";
    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      var fwdColor = getStatsCellColor(selector, row.fwdItemId, statsMode, baseline);
      var revColor = getStatsCellColor(selector, row.revItemId, statsMode, baseline);
      html += "<tr>";
      html += "<td>" + row.label + "</td>";
      html += "<td>" + row.sublabel + "</td>";
      html += '<td class="stats-cell" style="background:' + fwdColor + '"></td>';
      html += '<td class="stats-cell" style="background:' + revColor + '"></td>';
      html += "</tr>";
    }
    html += "</tbody></table>";
    containerEl.innerHTML = html;
  }
  function renderStatsGrid(selector, colLabels, getItemId, statsMode, containerEl, notes, baseline) {
    var noteList = notes || NOTES;
    var html = '<table class="stats-grid"><thead><tr><th></th>';
    for (var c = 0; c < colLabels.length; c++) {
      html += "<th>" + colLabels[c] + "</th>";
    }
    html += "</tr></thead><tbody>";
    for (var n = 0; n < noteList.length; n++) {
      var note = noteList[n];
      html += '<tr><td class="stats-grid-row-label">' + displayNote(note.name || note.displayName) + "</td>";
      for (var i = 0; i < colLabels.length; i++) {
        var itemId = getItemId(note.name, i);
        var color = Array.isArray(itemId) ? getStatsCellColorMerged(selector, itemId, statsMode, baseline) : getStatsCellColor(selector, itemId, statsMode, baseline);
        html += '<td class="stats-cell" style="background:' + color + '"></td>';
      }
      html += "</tr>";
    }
    html += "</tbody></table>";
    containerEl.innerHTML = html;
  }
  function createStatsControls(container, renderFn) {
    var statsMode = null;
    var statsContainer = container.querySelector(".stats-container");
    function show(mode) {
      statsMode = mode;
      statsContainer.innerHTML = "";
      renderFn(mode, statsContainer);
      statsContainer.classList.remove("stats-hidden");
      container.querySelectorAll(".stats-toggle-btn").forEach(function(b) {
        b.classList.toggle("active", b.dataset.mode === mode);
      });
    }
    function hide() {
      statsMode = null;
      statsContainer.classList.add("stats-hidden");
      statsContainer.innerHTML = "";
    }
    container.querySelectorAll(".stats-toggle-btn").forEach(function(btn) {
      btn.addEventListener("click", function() {
        show(btn.dataset.mode);
      });
    });
    return {
      show,
      hide,
      get mode() {
        return statsMode;
      }
    };
  }
  function formatThreshold(ms) {
    var s = ms / 1e3;
    return s % 1 === 0 ? s + "s" : s.toFixed(1) + "s";
  }
  function legendItem(color, label) {
    return '<div class="legend-item"><div class="legend-swatch" style="background:' + color + '"></div>' + label + "</div>";
  }
  function buildStatsLegend(statsMode, baseline) {
    var c = heatmapColors();
    var html = '<div class="heatmap-legend active">';
    html += legendItem(c.none, "No data");
    if (statsMode === "retention") {
      for (var i = c.level.length - 1; i >= 0; i--) {
        html += legendItem(c.level[i], RETENTION_LABELS[i]);
      }
    } else {
      var b = baseline || 1e3;
      var t1 = formatThreshold(b * 1.5);
      var t2 = formatThreshold(b * 3);
      var t3 = formatThreshold(b * 4.5);
      var t4 = formatThreshold(b * 6);
      html += legendItem(c.level[4], "&lt; " + t1);
      html += legendItem(c.level[3], t1 + "\u2013" + t2);
      html += legendItem(c.level[2], t2 + "\u2013" + t3);
      html += legendItem(c.level[1], t3 + "\u2013" + t4);
      html += legendItem(c.level[0], "&ge; " + t4);
    }
    html += "</div>";
    return html;
  }

  // src/recommendations.js
  function computeRecommendations(selector, allIndices, getItemIds, config, options) {
    const sortUnstarted = options && options.sortUnstarted;
    const recs = selector.getStringRecommendations(allIndices, getItemIds);
    const started = recs.filter((r) => r.unseenCount < r.totalCount);
    const unstarted = recs.filter((r) => r.unseenCount === r.totalCount);
    if (started.length === 0) {
      if (unstarted.length > 0) {
        const sorted = sortUnstarted ? [...unstarted].sort(sortUnstarted) : unstarted;
        const first = sorted[0];
        return {
          recommended: /* @__PURE__ */ new Set([first.string]),
          enabled: /* @__PURE__ */ new Set([first.string]),
          consolidateIndices: [],
          consolidateDueCount: 0,
          expandIndex: first.string,
          expandNewCount: first.totalCount
        };
      }
      return {
        recommended: /* @__PURE__ */ new Set(),
        enabled: null,
        consolidateIndices: [],
        consolidateDueCount: 0,
        expandIndex: null,
        expandNewCount: 0
      };
    }
    const totalSeen = started.reduce((sum, r) => sum + (r.masteredCount + r.dueCount), 0);
    const totalMastered = started.reduce((sum, r) => sum + r.masteredCount, 0);
    const consolidatedRatio = totalSeen > 0 ? totalMastered / totalSeen : 0;
    const startedByWork = [...started].sort(
      (a, b) => b.dueCount + b.unseenCount - (a.dueCount + a.unseenCount)
    );
    const workCounts = startedByWork.map((r) => r.dueCount + r.unseenCount);
    const medianWork = workCounts[Math.floor(workCounts.length / 2)];
    const recommended = /* @__PURE__ */ new Set();
    const enabled = /* @__PURE__ */ new Set();
    const consolidateIndices = [];
    let consolidateDueCount = 0;
    for (const r of startedByWork) {
      if (r.dueCount + r.unseenCount > medianWork) {
        recommended.add(r.string);
        enabled.add(r.string);
        consolidateIndices.push(r.string);
        consolidateDueCount += r.dueCount + r.unseenCount;
      }
    }
    if (enabled.size === 0) {
      const r = startedByWork[0];
      recommended.add(r.string);
      enabled.add(r.string);
      consolidateIndices.push(r.string);
      consolidateDueCount += r.dueCount + r.unseenCount;
    }
    let expandIndex = null;
    let expandNewCount = 0;
    if (consolidatedRatio >= config.expansionThreshold && unstarted.length > 0) {
      const sorted = sortUnstarted ? [...unstarted].sort(sortUnstarted) : unstarted;
      expandIndex = sorted[0].string;
      expandNewCount = sorted[0].totalCount;
      recommended.add(expandIndex);
      enabled.add(expandIndex);
    }
    return {
      recommended,
      enabled,
      consolidateIndices,
      consolidateDueCount,
      expandIndex,
      expandNewCount
    };
  }

  // src/quiz-fretboard-state.js
  function toggleFretboardString(enabledStrings, string) {
    const next = new Set(enabledStrings);
    if (next.has(string)) {
      if (next.size > 1) next.delete(string);
    } else {
      next.add(string);
    }
    return next;
  }
  function createFretboardHelpers(musicData) {
    const noteNames = musicData.notes.map((n) => n.name);
    const fretCount = musicData.fretCount || 13;
    function getNoteAtPosition(string, fret) {
      const offset = musicData.stringOffsets[string];
      return noteNames[(offset + fret) % 12];
    }
    function parseFretboardItem(itemId) {
      const [s, f] = itemId.split("-").map(Number);
      return {
        currentString: s,
        currentFret: f,
        currentNote: getNoteAtPosition(s, f)
      };
    }
    function checkFretboardAnswer(currentNote, input) {
      const note = musicData.notes.find((n) => n.name === currentNote);
      const correct = !!(note && musicData.noteMatchesInput(note, input));
      return { correct, correctAnswer: displayNote(currentNote) };
    }
    function notePassesFilter(note, noteFilter) {
      if (noteFilter === "all") return true;
      const isNatural = musicData.naturalNotes.includes(note);
      return noteFilter === "natural" ? isNatural : !isNatural;
    }
    function getFretboardEnabledItems(enabledStrings, noteFilter) {
      const items = [];
      for (const s of enabledStrings) {
        for (let f = 0; f < fretCount; f++) {
          const note = getNoteAtPosition(s, f);
          if (notePassesFilter(note, noteFilter)) {
            items.push(s + "-" + f);
          }
        }
      }
      return items;
    }
    function getItemIdsForString(string, noteFilter) {
      const items = [];
      for (let f = 0; f < fretCount; f++) {
        const note = getNoteAtPosition(string, f);
        if (notePassesFilter(note, noteFilter)) {
          items.push(string + "-" + f);
        }
      }
      return items;
    }
    return {
      fretCount,
      getNoteAtPosition,
      parseFretboardItem,
      checkFretboardAnswer,
      getFretboardEnabledItems,
      getItemIdsForString
    };
  }
  function computeNotePrioritization(naturalStats, threshold) {
    let totalSeen = 0;
    let totalMastered = 0;
    for (const r of naturalStats) {
      totalSeen += r.masteredCount + r.dueCount;
      totalMastered += r.masteredCount;
    }
    const ratio = totalSeen > 0 ? totalMastered / totalSeen : 0;
    if (totalSeen === 0 || ratio < threshold) {
      return { suggestedFilter: "natural", naturalMasteryRatio: ratio };
    }
    return { suggestedFilter: "all", naturalMasteryRatio: ratio };
  }

  // src/quiz-fretboard.js
  function createFrettedInstrumentMode(instrument) {
    var container = document.getElementById("mode-" + instrument.id);
    var STRINGS_KEY = instrument.storageNamespace + "_enabledStrings";
    var NOTE_FILTER_KEY = instrument.storageNamespace + "_noteFilter";
    var enabledStrings = /* @__PURE__ */ new Set([instrument.defaultString]);
    var noteFilter = "natural";
    var recommendedStrings = /* @__PURE__ */ new Set();
    var lastNotePri = null;
    var allStrings = Array.from({ length: instrument.stringCount }, function(_, i) {
      return i;
    });
    var fb = createFretboardHelpers({
      notes: NOTES,
      naturalNotes: NATURAL_NOTES,
      stringOffsets: instrument.stringOffsets,
      fretCount: instrument.fretCount,
      noteMatchesInput
    });
    var FB_QUIZ_HL = "hsl(50, 100%, 50%)";
    var activeTab = "practice";
    var progressFretboard = container.querySelector(".tab-progress .fretboard-wrapper");
    var quizFretboard = container.querySelector(".quiz-area .fretboard-wrapper");
    function setCircleFill(root, string, fret, color) {
      var circle = root.querySelector(
        'circle.fb-pos[data-string="' + string + '"][data-fret="' + fret + '"]'
      );
      if (circle) circle.style.fill = color;
    }
    function clearAll(root) {
      root.querySelectorAll(".fb-pos").forEach(function(c) {
        c.style.fill = "";
      });
    }
    function setupHoverCard(fretboardWrapper) {
      var card = fretboardWrapper.querySelector(".hover-card");
      if (!card) return;
      function showCard(el) {
        var s = parseInt(el.getAttribute("data-string"));
        var f = parseInt(el.getAttribute("data-fret"));
        var note = fb.getNoteAtPosition(s, f);
        var itemId = s + "-" + f;
        var auto = engine.selector.getAutomaticity(itemId);
        card.querySelector(".hc-note").textContent = displayNote(note);
        card.querySelector(".hc-string-fret").textContent = displayNote(instrument.stringNames[s]) + " string, fret " + f;
        if (auto !== null) {
          var pct = Math.round(auto * 100);
          var label;
          if (auto > 0.8) label = "Automatic";
          else if (auto > 0.6) label = "Solid";
          else if (auto > 0.4) label = "Getting there";
          else if (auto > 0.2) label = "Fading";
          else label = "Needs work";
          card.querySelector(".hc-detail").textContent = label + " \xB7 " + pct + "%";
          var barFill = card.querySelector(".hc-bar-fill");
          barFill.style.width = pct + "%";
          barFill.style.background = getAutomaticityColor(auto);
        } else {
          card.querySelector(".hc-detail").textContent = "Not seen yet";
          var barFill2 = card.querySelector(".hc-bar-fill");
          barFill2.style.width = "0%";
          barFill2.style.background = "";
        }
        var containerRect = fretboardWrapper.querySelector(".fretboard-container").getBoundingClientRect();
        var elRect = el.getBoundingClientRect();
        var cx = elRect.left + elRect.width / 2 - containerRect.left;
        var cy = elRect.top - containerRect.top;
        if (cy < 50) {
          card.style.left = cx + "px";
          card.style.top = cy + elRect.height + 6 + "px";
          card.style.transform = "translate(-50%, 0)";
        } else {
          card.style.left = cx + "px";
          card.style.top = cy - 6 + "px";
          card.style.transform = "translate(-50%, -100%)";
        }
        card.classList.add("visible");
      }
      function hideCard() {
        card.classList.remove("visible");
      }
      var svg = fretboardWrapper.querySelector("svg");
      svg.addEventListener("mouseover", function(e) {
        var el = e.target.closest(".fb-pos");
        if (el) showCard(el);
      });
      svg.addEventListener("mouseout", function(e) {
        var el = e.target.closest(".fb-pos");
        if (el) hideCard();
      });
    }
    function loadEnabledStrings() {
      var saved = localStorage.getItem(STRINGS_KEY);
      if (saved) {
        try {
          enabledStrings = new Set(JSON.parse(saved));
        } catch (e) {
        }
      }
      updateStringToggles();
    }
    function saveEnabledStrings() {
      localStorage.setItem(STRINGS_KEY, JSON.stringify([...enabledStrings]));
    }
    function updateStringToggles() {
      container.querySelectorAll(".string-toggle").forEach(function(btn) {
        var s = parseInt(btn.dataset.string);
        btn.classList.toggle("active", enabledStrings.has(s));
        btn.classList.toggle("recommended", recommendedStrings.has(s));
      });
    }
    function toggleString(s) {
      enabledStrings = toggleFretboardString(enabledStrings, s);
      saveEnabledStrings();
      refreshUI();
    }
    function loadNoteFilter() {
      var saved = localStorage.getItem(NOTE_FILTER_KEY);
      if (saved && (saved === "natural" || saved === "sharps-flats" || saved === "all")) {
        noteFilter = saved;
      }
      updateNoteToggles();
    }
    function saveNoteFilter() {
      try {
        localStorage.setItem(NOTE_FILTER_KEY, noteFilter);
      } catch (_) {
      }
    }
    function updateNoteToggles() {
      var naturalBtn = container.querySelector('.notes-toggle[data-notes="natural"]');
      var accBtn = container.querySelector('.notes-toggle[data-notes="sharps-flats"]');
      if (naturalBtn) naturalBtn.classList.toggle("active", noteFilter === "natural" || noteFilter === "all");
      if (accBtn) accBtn.classList.toggle("active", noteFilter === "sharps-flats" || noteFilter === "all");
    }
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach(function(btn) {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach(function(el) {
        var isPractice = el.classList.contains("tab-practice");
        var isProgress = el.classList.contains("tab-progress");
        if (tabName === "practice") {
          el.classList.toggle("active", isPractice);
        } else {
          el.classList.toggle("active", isProgress);
        }
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        clearAll(progressFretboard);
        renderPracticeSummary();
      }
    }
    var statsControls = createStatsControls(container, function(mode2, el) {
      el.innerHTML = buildStatsLegend(mode2, engine.baseline);
      if (mode2 === "retention") {
        for (var si2 = 0; si2 < allStrings.length; si2++) {
          var s = allStrings[si2];
          for (var f = 0; f < instrument.fretCount; f++) {
            var auto = engine.selector.getAutomaticity(s + "-" + f);
            var color = getAutomaticityColor(auto);
            setCircleFill(progressFretboard, s, f, color);
          }
        }
      } else {
        for (var sj = 0; sj < allStrings.length; sj++) {
          var s2 = allStrings[sj];
          for (var f2 = 0; f2 < instrument.fretCount; f2++) {
            var stats = engine.selector.getStats(s2 + "-" + f2);
            var ewma = stats ? stats.ewma : null;
            var color2 = getSpeedHeatmapColor(ewma, engine.baseline);
            setCircleFill(progressFretboard, s2, f2, color2);
          }
        }
      }
    });
    function hideHeatmap() {
      statsControls.hide();
      clearAll(progressFretboard);
    }
    function updateStats(selector) {
      var statsEl = container.querySelector(".stats");
      if (statsEl) statsEl.textContent = "";
    }
    var recsOptions = { sortUnstarted: function(a, b) {
      return b.string - a.string;
    } };
    function getRecommendationResult() {
      return computeRecommendations(
        engine.selector,
        allStrings,
        function(s) {
          return fb.getItemIdsForString(s, "all");
        },
        DEFAULT_CONFIG,
        recsOptions
      );
    }
    function updateRecommendations(selector) {
      var result = getRecommendationResult();
      recommendedStrings = result.recommended;
      updateStringToggles();
    }
    function applyRecommendations(selector) {
      var result = getRecommendationResult();
      recommendedStrings = result.recommended;
      if (result.enabled) {
        enabledStrings = result.enabled;
        saveEnabledStrings();
      }
      updateStringToggles();
    }
    function refreshUI() {
      updateRecommendations(engine.selector);
      engine.updateIdleMessage();
      renderPracticeSummary();
      renderSessionSummary();
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < items.length; i++) {
        var auto = engine.selector.getAutomaticity(items[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      var allItems = fb.getFretboardEnabledItems(new Set(allStrings), noteFilter);
      var allFluent = 0;
      for (var j = 0; j < allItems.length; j++) {
        var a2 = engine.selector.getAutomaticity(allItems[j]);
        if (a2 !== null && a2 > threshold) allFluent++;
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = allItems.length + " positions to learn";
      } else {
        var pct = allItems.length > 0 ? Math.round(allFluent / allItems.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = allFluent + " of " + allItems.length + " positions fluent";
      }
      var result = getRecommendationResult();
      var naturalStats = engine.selector.getStringRecommendations(
        [...result.recommended],
        function(s) {
          return fb.getItemIdsForString(s, "natural");
        }
      );
      lastNotePri = computeNotePrioritization(naturalStats, DEFAULT_CONFIG.expansionThreshold);
      if (result.recommended.size > 0) {
        var parts = [];
        if (result.consolidateIndices.length > 0) {
          var cNames = result.consolidateIndices.sort(function(a, b) {
            return b - a;
          }).map(function(s) {
            return displayNote(instrument.stringNames[s]);
          });
          parts.push("solidify " + cNames.join(", ") + " string" + (cNames.length > 1 ? "s" : "") + " \u2014 " + result.consolidateDueCount + " slow item" + (result.consolidateDueCount !== 1 ? "s" : ""));
        }
        if (result.expandIndex !== null) {
          parts.push("start " + displayNote(instrument.stringNames[result.expandIndex]) + " string \u2014 " + result.expandNewCount + " new item" + (result.expandNewCount !== 1 ? "s" : ""));
        }
        if (lastNotePri.suggestedFilter === "natural") {
          parts.push("naturals first");
        } else {
          parts.push("add sharps & flats");
        }
        recText.textContent = "Suggestion: " + parts.join(", ");
        recBtn.classList.remove("hidden");
      } else {
        recText.textContent = "";
        recBtn.classList.add("hidden");
      }
    }
    function noteFilterLabel() {
      if (noteFilter === "natural") return "natural notes";
      if (noteFilter === "sharps-flats") return "sharps and flats";
      return "all notes";
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var count = enabledStrings.size;
      el.textContent = count + " string" + (count !== 1 ? "s" : "") + " \xB7 " + noteFilterLabel() + " \xB7 60s";
    }
    function updateAccidentalButtons() {
      var hideAcc = noteFilter === "natural";
      container.querySelectorAll(".note-btn.accidental").forEach(function(btn) {
        btn.classList.toggle("hidden", hideAcc);
      });
      var accRow = container.querySelector(".note-row-accidentals");
      if (accRow) accRow.classList.toggle("hidden", hideAcc);
    }
    var currentString = null;
    var currentFret = null;
    var currentNote = null;
    var mode = {
      id: instrument.id,
      name: instrument.name,
      storageNamespace: instrument.storageNamespace,
      getEnabledItems: function() {
        return fb.getFretboardEnabledItems(enabledStrings, noteFilter);
      },
      getPracticingLabel: function() {
        var parts = [];
        if (enabledStrings.size < instrument.stringCount) {
          var names = Array.from(enabledStrings).sort(function(a, b) {
            return b - a;
          }).map(function(s) {
            return displayNote(instrument.stringNames[s]);
          });
          parts.push(names.join(", ") + " string" + (names.length === 1 ? "" : "s"));
        } else {
          parts.push("all strings");
        }
        if (noteFilter !== "all") parts.push(noteFilterLabel());
        return parts.join(", ");
      },
      presentQuestion: function(itemId) {
        clearAll(quizFretboard);
        var q = fb.parseFretboardItem(itemId);
        currentString = q.currentString;
        currentFret = q.currentFret;
        currentNote = q.currentNote;
        setCircleFill(quizFretboard, q.currentString, q.currentFret, FB_QUIZ_HL);
        container.querySelector(".quiz-prompt").textContent = "Name this note.";
      },
      checkAnswer: function(itemId, input) {
        return fb.checkFretboardAnswer(currentNote, input);
      },
      onAnswer: function(itemId, result, responseTime) {
        if (result.correct) {
          setCircleFill(quizFretboard, currentString, currentFret, "var(--color-success)");
        } else {
          setCircleFill(quizFretboard, currentString, currentFret, "var(--color-error)");
        }
      },
      onStart: function() {
        noteKeyHandler.reset();
        if (statsControls.mode) hideHeatmap();
        updateStats(engine.selector);
      },
      onStop: function() {
        noteKeyHandler.reset();
        clearAll(quizFretboard);
        updateStats(engine.selector);
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        refreshUI();
      },
      handleKey: function(e, ctx) {
        return noteKeyHandler.handleKey(e);
      },
      getCalibrationButtons: function() {
        return Array.from(container.querySelectorAll(".note-btn:not(.hidden)"));
      },
      getCalibrationTrialConfig: function(buttons, prevBtn) {
        var btn = pickCalibrationButton(buttons, prevBtn);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    var engine = createQuizEngine(mode, container);
    var noteKeyHandler = createAdaptiveKeyHandler(
      function(input) {
        engine.submitAnswer(input);
      },
      function() {
        return noteFilter !== "natural";
      }
    );
    var allItemIds = [];
    for (var si = 0; si < allStrings.length; si++) {
      for (var fi = 0; fi < instrument.fretCount; fi++) {
        allItemIds.push(allStrings[si] + "-" + fi);
      }
    }
    engine.storage.preload(allItemIds);
    function init() {
      loadEnabledStrings();
      loadNoteFilter();
      container.querySelectorAll(".mode-tab").forEach(function(btn) {
        btn.addEventListener("click", function() {
          switchTab(btn.dataset.tab);
        });
      });
      container.querySelectorAll(".string-toggle").forEach(function(btn) {
        btn.addEventListener("click", function() {
          toggleString(parseInt(btn.dataset.string));
        });
      });
      container.querySelectorAll(".note-btn").forEach(function(btn) {
        btn.addEventListener("click", function() {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.note);
        });
      });
      container.querySelectorAll(".notes-toggle").forEach(function(btn) {
        btn.addEventListener("click", function() {
          btn.classList.toggle("active");
          var anyActive = container.querySelector(".notes-toggle.active");
          if (!anyActive) btn.classList.add("active");
          var naturalActive = container.querySelector('.notes-toggle[data-notes="natural"].active');
          var accActive = container.querySelector('.notes-toggle[data-notes="sharps-flats"].active');
          if (naturalActive && accActive) noteFilter = "all";
          else if (accActive) noteFilter = "sharps-flats";
          else noteFilter = "natural";
          saveNoteFilter();
          updateAccidentalButtons();
          refreshUI();
        });
      });
      container.querySelector(".start-btn").addEventListener("click", function() {
        engine.start();
      });
      var recBtn = container.querySelector(".practice-rec-btn");
      if (recBtn) {
        recBtn.addEventListener("click", function() {
          applyRecommendations(engine.selector);
          if (lastNotePri) {
            noteFilter = lastNotePri.suggestedFilter;
            saveNoteFilter();
            updateNoteToggles();
            updateAccidentalButtons();
          }
          refreshUI();
        });
      }
      if (progressFretboard) setupHoverCard(progressFretboard);
      updateRecommendations(engine.selector);
      updateAccidentalButtons();
      updateStats(engine.selector);
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate: function() {
        engine.attach();
        refreshNoteButtonLabels(container);
        refreshUI();
      },
      deactivate: function() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
      },
      onNotationChange: function() {
        if (!container.classList.contains("mode-active")) return;
        renderPracticeSummary();
        if (activeTab === "progress" && statsControls.mode) {
          statsControls.show(statsControls.mode);
        }
      }
    };
  }
  function createGuitarFretboardMode() {
    return createFrettedInstrumentMode(GUITAR);
  }
  function createUkuleleFretboardMode() {
    return createFrettedInstrumentMode(UKULELE);
  }

  // src/quiz-speed-tap.js
  function createSpeedTapMode() {
    var container = document.getElementById("mode-speedTap");
    var NOTE_FILTER_KEY = "speedTap_noteFilter";
    var noteFilter = "natural";
    var currentNote = null;
    var targetPositions = [];
    var foundPositions = /* @__PURE__ */ new Set();
    var roundActive = false;
    var wrongFlashTimeouts = /* @__PURE__ */ new Set();
    var noteNames = NOTES.map(function(n) {
      return n.name;
    });
    var FB_TAP_NEUTRAL = "hsl(30, 4%, 90%)";
    var FB_TAP_CORRECT = "hsl(90, 45%, 35%)";
    var _cs = getComputedStyle(document.documentElement);
    var COLOR_ERROR = _cs.getPropertyValue("--color-error").trim();
    function getNoteAtPosition(string, fret) {
      var offset = STRING_OFFSETS[string];
      return noteNames[(offset + fret) % 12];
    }
    function getPositionsForNote(noteName) {
      var positions = [];
      for (var s = 0; s < 6; s++) {
        for (var f = 0; f <= 12; f++) {
          if (getNoteAtPosition(s, f) === noteName) {
            positions.push({ string: s, fret: f });
          }
        }
      }
      return positions;
    }
    function setCircleFill(string, fret, color) {
      var circle = container.querySelector(
        'circle.fb-pos[data-string="' + string + '"][data-fret="' + fret + '"]'
      );
      if (circle) circle.style.fill = color;
    }
    function clearAll() {
      container.querySelectorAll(".fb-pos").forEach(function(c) {
        c.style.fill = "";
      });
    }
    var activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach(function(btn) {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach(function(el) {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i2 = 0; i2 < items.length; i2++) {
        var auto = engine.selector.getAutomaticity(items[i2]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = items.length + " notes to learn";
      } else {
        var pct = items.length > 0 ? Math.round(fluent / items.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = fluent + " of " + items.length + " notes fluent";
      }
      recText.textContent = "";
      recBtn.classList.add("hidden");
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var items = mode.getEnabledItems();
      el.textContent = items.length + " notes \xB7 60s";
    }
    var statsControls = createStatsControls(container, function(mode2, el) {
      var html = '<table class="stats-table speed-tap-stats"><thead><tr>';
      for (var i2 = 0; i2 < NOTES.length; i2++) {
        html += "<th>" + displayNote(NOTES[i2].name) + "</th>";
      }
      html += "</tr></thead><tbody><tr>";
      for (var j = 0; j < NOTES.length; j++) {
        if (mode2 === "retention") {
          var auto = engine.selector.getAutomaticity(NOTES[j].name);
          html += '<td class="stats-cell" style="background:' + getAutomaticityColor(auto) + '"></td>';
        } else {
          var stats = engine.selector.getStats(NOTES[j].name);
          var posCount = getPositionsForNote(NOTES[j].name).length;
          var perPosMs = stats ? stats.ewma / posCount : null;
          html += '<td class="stats-cell" style="background:' + getSpeedHeatmapColor(perPosMs) + '"></td>';
        }
      }
      html += "</tr></tbody></table>";
      html += buildStatsLegend(mode2, engine.baseline);
      el.innerHTML = html;
    });
    var progressEl = container.querySelector(".speed-tap-progress");
    var fretboardWrapper = container.querySelector(".fretboard-wrapper");
    function updateRoundProgress() {
      if (progressEl) {
        progressEl.textContent = foundPositions.size + " / " + targetPositions.length;
      }
    }
    function handleCircleTap(string, fret) {
      if (!engine.isActive || engine.isAnswered || !roundActive) return;
      var key = string + "-" + fret;
      if (foundPositions.has(key)) return;
      var tappedNote = getNoteAtPosition(string, fret);
      if (tappedNote === currentNote) {
        foundPositions.add(key);
        setCircleFill(string, fret, FB_TAP_CORRECT);
        updateRoundProgress();
        if (foundPositions.size === targetPositions.length) {
          roundActive = false;
          engine.submitAnswer("complete");
        }
      } else {
        setCircleFill(string, fret, COLOR_ERROR);
        var timeout = setTimeout(function() {
          wrongFlashTimeouts.delete(timeout);
          if (!foundPositions.has(key)) {
            setCircleFill(string, fret, FB_TAP_NEUTRAL);
          }
        }, 800);
        wrongFlashTimeouts.add(timeout);
      }
    }
    function handleFretboardClick(e) {
      if (e.target.closest(".setting-group")) return;
      if (engine.isActive && !engine.isAnswered && roundActive) {
        var target = e.target.closest("circle.fb-pos[data-string][data-fret]");
        if (target) {
          handleCircleTap(parseInt(target.dataset.string), parseInt(target.dataset.fret));
        }
      }
    }
    var mode = {
      id: "speedTap",
      name: "Speed Tap",
      storageNamespace: "speedTap",
      getEnabledItems: function() {
        if (noteFilter === "natural") return NATURAL_NOTES.slice();
        if (noteFilter === "sharps-flats") return NOTES.filter(function(n) {
          return !NATURAL_NOTES.includes(n.name);
        }).map(function(n) {
          return n.name;
        });
        return NOTES.map(function(n) {
          return n.name;
        });
      },
      getExpectedResponseCount: function(itemId) {
        return getPositionsForNote(itemId).length;
      },
      presentQuestion: function(itemId) {
        wrongFlashTimeouts.forEach(function(t) {
          clearTimeout(t);
        });
        wrongFlashTimeouts.clear();
        clearAll();
        currentNote = itemId;
        targetPositions = getPositionsForNote(currentNote);
        foundPositions = /* @__PURE__ */ new Set();
        roundActive = true;
        container.querySelectorAll(".fb-pos").forEach(function(c) {
          c.style.fill = FB_TAP_NEUTRAL;
        });
        var prompt = container.querySelector(".quiz-prompt");
        if (prompt) {
          var note = NOTES.find(function(n) {
            return n.name === currentNote;
          });
          prompt.textContent = "Tap all " + (note ? displayNote(pickRandomAccidental(note.displayName)) : displayNote(currentNote));
        }
        updateRoundProgress();
      },
      checkAnswer: function(itemId, input) {
        var allFound = input === "complete";
        return { correct: allFound, correctAnswer: displayNote(currentNote) };
      },
      onStart: function() {
        if (statsControls.mode) statsControls.hide();
        if (fretboardWrapper) fretboardWrapper.classList.remove("fretboard-hidden");
      },
      onStop: function() {
        roundActive = false;
        wrongFlashTimeouts.forEach(function(t) {
          clearTimeout(t);
        });
        wrongFlashTimeouts.clear();
        clearAll();
        currentNote = null;
        if (progressEl) progressEl.textContent = "";
        if (fretboardWrapper) fretboardWrapper.classList.add("fretboard-hidden");
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        renderPracticeSummary();
        renderSessionSummary();
      },
      onAnswer: function(itemId, result, responseTime) {
        roundActive = false;
        if (!result.correct) {
          for (var i2 = 0; i2 < targetPositions.length; i2++) {
            var pos = targetPositions[i2];
            var key = pos.string + "-" + pos.fret;
            if (!foundPositions.has(key)) {
              setCircleFill(pos.string, pos.fret, COLOR_ERROR);
            }
          }
        }
      },
      handleKey: function(e, ctx) {
        return false;
      },
      getCalibrationButtons: function() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      }
    };
    var engine = createQuizEngine(mode, container);
    for (var i = 0; i < NOTES.length; i++) {
      engine.storage.getStats(NOTES[i].name);
    }
    function loadNoteFilter() {
      var saved = localStorage.getItem(NOTE_FILTER_KEY);
      if (saved && (saved === "natural" || saved === "sharps-flats" || saved === "all")) {
        noteFilter = saved;
      }
      updateNoteToggles();
    }
    function saveNoteFilter() {
      try {
        localStorage.setItem(NOTE_FILTER_KEY, noteFilter);
      } catch (_) {
      }
    }
    function updateNoteToggles() {
      var naturalBtn = container.querySelector('.notes-toggle[data-notes="natural"]');
      var accBtn = container.querySelector('.notes-toggle[data-notes="sharps-flats"]');
      if (naturalBtn) naturalBtn.classList.toggle("active", noteFilter === "natural" || noteFilter === "all");
      if (accBtn) accBtn.classList.toggle("active", noteFilter === "sharps-flats" || noteFilter === "all");
    }
    function init() {
      loadNoteFilter();
      container.querySelectorAll(".mode-tab").forEach(function(btn) {
        btn.addEventListener("click", function() {
          switchTab(btn.dataset.tab);
        });
      });
      container.querySelectorAll(".notes-toggle").forEach(function(btn) {
        btn.addEventListener("click", function() {
          btn.classList.toggle("active");
          var anyActive = container.querySelector(".notes-toggle.active");
          if (!anyActive) btn.classList.add("active");
          var naturalActive = container.querySelector('.notes-toggle[data-notes="natural"].active');
          var accActive = container.querySelector('.notes-toggle[data-notes="sharps-flats"].active');
          if (naturalActive && accActive) noteFilter = "all";
          else if (accActive) noteFilter = "sharps-flats";
          else noteFilter = "natural";
          saveNoteFilter();
          engine.updateIdleMessage();
          renderPracticeSummary();
          renderSessionSummary();
        });
      });
      container.querySelector(".start-btn").addEventListener("click", function() {
        engine.start();
      });
      if (fretboardWrapper) fretboardWrapper.classList.add("fretboard-hidden");
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate: function() {
        engine.attach();
        container.addEventListener("click", handleFretboardClick);
        engine.updateIdleMessage();
        renderPracticeSummary();
      },
      deactivate: function() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        container.removeEventListener("click", handleFretboardClick);
      }
    };
  }

  // src/quiz-note-semitones.js
  function createNoteSemitonesMode() {
    const container = document.getElementById("mode-noteSemitones");
    const ALL_ITEMS = [];
    for (const note of NOTES) {
      ALL_ITEMS.push(note.name + ":fwd");
      ALL_ITEMS.push(note.name + ":rev");
    }
    function parseItem(itemId) {
      const [noteName, dir] = itemId.split(":");
      const note = NOTES.find((n) => n.name === noteName);
      return { note, dir };
    }
    let currentItem = null;
    let currentAccidentalChoice = null;
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < ALL_ITEMS.length; i++) {
        var auto = engine.selector.getAutomaticity(ALL_ITEMS[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(fluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = fluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      recText.textContent = "";
      recBtn.classList.add("hidden");
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      el.textContent = ALL_ITEMS.length + " items \xB7 60s";
    }
    function getTableRows() {
      return NOTES.map((note) => ({
        label: displayNote(note.name),
        sublabel: String(note.num),
        _colHeader: "Note",
        fwdItemId: note.name + ":fwd",
        revItemId: note.name + ":rev"
      }));
    }
    const statsControls = createStatsControls(container, function(mode2, el) {
      const tableDiv = document.createElement("div");
      el.appendChild(tableDiv);
      renderStatsTable(engine.selector, getTableRows(), "N\u2192#", "#\u2192N", mode2, tableDiv, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    const mode = {
      id: "noteSemitones",
      name: "Note \u2194 Semitones",
      storageNamespace: "noteSemitones",
      getEnabledItems() {
        return ALL_ITEMS;
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        const prompt = container.querySelector(".quiz-prompt");
        const noteButtons = container.querySelector(".answer-buttons-notes");
        const numButtons = container.querySelector(".answer-buttons-numbers");
        currentAccidentalChoice = pickRandomAccidental(currentItem.note.displayName);
        if (currentItem.dir === "fwd") {
          prompt.textContent = displayNote(currentAccidentalChoice);
          noteButtons.classList.add("answer-group-hidden");
          numButtons.classList.remove("answer-group-hidden");
        } else {
          prompt.textContent = String(currentItem.note.num);
          noteButtons.classList.remove("answer-group-hidden");
          numButtons.classList.add("answer-group-hidden");
        }
      },
      checkAnswer(itemId, input) {
        if (currentItem.dir === "fwd") {
          const correct = parseInt(input, 10) === currentItem.note.num;
          return { correct, correctAnswer: String(currentItem.note.num) };
        } else {
          const correct = noteMatchesInput(currentItem.note, input);
          return { correct, correctAnswer: displayNote(currentAccidentalChoice) };
        }
      },
      onStart() {
        noteKeyHandler.reset();
        if (pendingDigitTimeout) clearTimeout(pendingDigitTimeout);
        pendingDigit = null;
        pendingDigitTimeout = null;
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        noteKeyHandler.reset();
        if (pendingDigitTimeout) clearTimeout(pendingDigitTimeout);
        pendingDigit = null;
        pendingDigitTimeout = null;
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        renderPracticeSummary();
        renderSessionSummary();
      },
      handleKey(e, { submitAnswer }) {
        if (currentItem.dir === "rev") {
          return noteKeyHandler.handleKey(e);
        }
        if (e.key >= "0" && e.key <= "9") {
          e.preventDefault();
          if (pendingDigit !== null) {
            const num = pendingDigit * 10 + parseInt(e.key);
            clearTimeout(pendingDigitTimeout);
            pendingDigit = null;
            pendingDigitTimeout = null;
            if (num <= 11) {
              submitAnswer(String(num));
            }
            return true;
          }
          const d = parseInt(e.key);
          if (d >= 2) {
            submitAnswer(String(d));
          } else {
            pendingDigit = d;
            pendingDigitTimeout = setTimeout(() => {
              submitAnswer(String(pendingDigit));
              pendingDigit = null;
              pendingDigitTimeout = null;
            }, 400);
          }
          return true;
        }
        return false;
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        const btn = pickCalibrationButton(buttons, prevBtn);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    let pendingDigit = null;
    let pendingDigitTimeout = null;
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    const noteKeyHandler = createAdaptiveKeyHandler(
      (input) => engine.submitAnswer(input),
      () => true
    );
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      container.querySelectorAll(".answer-btn-note").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.note);
        });
      });
      container.querySelectorAll(".answer-btn-num").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.num);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        refreshNoteButtonLabels(container);
        engine.updateIdleMessage();
        renderPracticeSummary();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
        if (pendingDigitTimeout) clearTimeout(pendingDigitTimeout);
        pendingDigit = null;
      }
    };
  }

  // src/quiz-interval-semitones.js
  function createIntervalSemitonesMode() {
    const container = document.getElementById("mode-intervalSemitones");
    const ALL_ITEMS = [];
    for (const interval of INTERVALS) {
      ALL_ITEMS.push(interval.abbrev + ":fwd");
      ALL_ITEMS.push(interval.abbrev + ":rev");
    }
    function parseItem(itemId) {
      const [abbrev, dir] = itemId.split(":");
      const interval = INTERVALS.find((i) => i.abbrev === abbrev);
      return { interval, dir };
    }
    let currentItem = null;
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < ALL_ITEMS.length; i++) {
        var auto = engine.selector.getAutomaticity(ALL_ITEMS[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(fluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = fluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      recText.textContent = "";
      recBtn.classList.add("hidden");
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      el.textContent = ALL_ITEMS.length + " items \xB7 60s";
    }
    function getTableRows() {
      return INTERVALS.map((interval) => ({
        label: interval.abbrev,
        sublabel: String(interval.num),
        _colHeader: "Interval",
        fwdItemId: interval.abbrev + ":fwd",
        revItemId: interval.abbrev + ":rev"
      }));
    }
    const statsControls = createStatsControls(container, function(mode2, el) {
      const tableDiv = document.createElement("div");
      el.appendChild(tableDiv);
      renderStatsTable(engine.selector, getTableRows(), "I\u2192#", "#\u2192I", mode2, tableDiv, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    const mode = {
      id: "intervalSemitones",
      name: "Interval \u2194 Semitones",
      storageNamespace: "intervalSemitones",
      getEnabledItems() {
        return ALL_ITEMS;
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        const prompt = container.querySelector(".quiz-prompt");
        const intervalButtons = container.querySelector(".answer-buttons-intervals");
        const numButtons = container.querySelector(".answer-buttons-numbers");
        if (currentItem.dir === "fwd") {
          prompt.textContent = currentItem.interval.name;
          intervalButtons.classList.add("answer-group-hidden");
          numButtons.classList.remove("answer-group-hidden");
        } else {
          prompt.textContent = String(currentItem.interval.num);
          intervalButtons.classList.remove("answer-group-hidden");
          numButtons.classList.add("answer-group-hidden");
        }
      },
      checkAnswer(itemId, input) {
        if (currentItem.dir === "fwd") {
          const correct = parseInt(input, 10) === currentItem.interval.num;
          return { correct, correctAnswer: String(currentItem.interval.num) };
        } else {
          const correct = intervalMatchesInput(currentItem.interval, input);
          return { correct, correctAnswer: currentItem.interval.abbrev };
        }
      },
      onStart() {
        if (pendingDigitTimeout) clearTimeout(pendingDigitTimeout);
        pendingDigit = null;
        pendingDigitTimeout = null;
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        if (pendingDigitTimeout) clearTimeout(pendingDigitTimeout);
        pendingDigit = null;
        pendingDigitTimeout = null;
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        renderPracticeSummary();
        renderSessionSummary();
      },
      handleKey(e, { submitAnswer }) {
        if (currentItem.dir === "fwd") {
          if (e.key >= "0" && e.key <= "9") {
            e.preventDefault();
            if (pendingDigit !== null) {
              const num = pendingDigit * 10 + parseInt(e.key);
              clearTimeout(pendingDigitTimeout);
              pendingDigit = null;
              pendingDigitTimeout = null;
              if (num >= 1 && num <= 12) {
                submitAnswer(String(num));
              }
              return true;
            }
            const d = parseInt(e.key);
            if (d >= 2 && d <= 9) {
              submitAnswer(String(d));
            } else {
              pendingDigit = d;
              pendingDigitTimeout = setTimeout(() => {
                if (pendingDigit >= 1) submitAnswer(String(pendingDigit));
                pendingDigit = null;
                pendingDigitTimeout = null;
              }, 400);
            }
            return true;
          }
        }
        return false;
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-interval"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        let btn;
        do {
          btn = buttons[Math.floor(Math.random() * buttons.length)];
        } while (btn === prevBtn && buttons.length > 1);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    let pendingDigit = null;
    let pendingDigitTimeout = null;
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      container.querySelectorAll(".answer-btn-interval").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.interval);
        });
      });
      container.querySelectorAll(".answer-btn-num").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.num);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        engine.updateIdleMessage();
        renderPracticeSummary();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        if (pendingDigitTimeout) clearTimeout(pendingDigitTimeout);
        pendingDigit = null;
      }
    };
  }

  // src/quiz-semitone-math.js
  function createSemitoneMathMode() {
    const container = document.getElementById("mode-semitoneMath");
    const GROUPS_KEY = "semitoneMath_enabledGroups";
    const DISTANCE_GROUPS = [
      { distances: [1, 2], label: "\xB11\u20132" },
      { distances: [3, 4], label: "\xB13\u20134" },
      { distances: [5, 6], label: "\xB15\u20136" },
      { distances: [7, 8], label: "\xB17\u20138" },
      { distances: [9, 10], label: "\xB19\u201310" },
      { distances: [11], label: "\xB111" }
    ];
    let enabledGroups = /* @__PURE__ */ new Set([0]);
    let recommendedGroups = /* @__PURE__ */ new Set();
    const ALL_ITEMS = [];
    for (const note of NOTES) {
      for (let s = 1; s <= 11; s++) {
        ALL_ITEMS.push(note.name + "+" + s);
        ALL_ITEMS.push(note.name + "-" + s);
      }
    }
    function parseItem(itemId) {
      const match = itemId.match(/^([A-G]#?)([+-])(\d+)$/);
      const noteName = match[1];
      const op = match[2];
      const semitones = parseInt(match[3]);
      const note = NOTES.find((n) => n.name === noteName);
      const answer = op === "+" ? noteAdd(note.num, semitones) : noteSub(note.num, semitones);
      return { note, op, semitones, answer };
    }
    function getItemIdsForGroup(groupIndex) {
      const distances = DISTANCE_GROUPS[groupIndex].distances;
      const items = [];
      for (const note of NOTES) {
        for (const d of distances) {
          items.push(note.name + "+" + d);
          items.push(note.name + "-" + d);
        }
      }
      return items;
    }
    function loadEnabledGroups() {
      const saved = localStorage.getItem(GROUPS_KEY);
      if (saved) {
        try {
          enabledGroups = new Set(JSON.parse(saved));
        } catch {
        }
      }
      updateGroupToggles();
    }
    function saveEnabledGroups() {
      localStorage.setItem(GROUPS_KEY, JSON.stringify([...enabledGroups]));
    }
    function updateGroupToggles() {
      container.querySelectorAll(".distance-toggle").forEach((btn) => {
        const g = parseInt(btn.dataset.group);
        btn.classList.toggle("active", enabledGroups.has(g));
        btn.classList.toggle("recommended", recommendedGroups.has(g));
      });
    }
    const recsOptions = { sortUnstarted: (a, b) => a.string - b.string };
    function getRecommendationResult() {
      const allGroups = DISTANCE_GROUPS.map((_, i) => i);
      return computeRecommendations(engine.selector, allGroups, getItemIdsForGroup, DEFAULT_CONFIG, recsOptions);
    }
    function updateRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      updateGroupToggles();
    }
    function applyRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      if (result.enabled) {
        enabledGroups = result.enabled;
        saveEnabledGroups();
      }
      updateGroupToggles();
    }
    function toggleGroup(g) {
      if (enabledGroups.has(g)) {
        if (enabledGroups.size > 1) enabledGroups.delete(g);
      } else {
        enabledGroups.add(g);
      }
      saveEnabledGroups();
      refreshUI();
    }
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function refreshUI() {
      updateRecommendations(engine.selector);
      engine.updateIdleMessage();
      renderPracticeSummary();
      renderSessionSummary();
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < items.length; i++) {
        var auto = engine.selector.getAutomaticity(items[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      var allFluent = 0;
      for (var j = 0; j < ALL_ITEMS.length; j++) {
        var a2 = engine.selector.getAutomaticity(ALL_ITEMS[j]);
        if (a2 !== null && a2 > threshold) allFluent++;
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(allFluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = allFluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      var result = getRecommendationResult();
      if (result.recommended.size > 0) {
        var parts = [];
        if (result.consolidateIndices.length > 0) {
          var cNames = result.consolidateIndices.sort(function(a, b) {
            return a - b;
          }).map(function(g) {
            return DISTANCE_GROUPS[g].label;
          });
          parts.push("solidify " + cNames.join(", ") + " \u2014 " + result.consolidateDueCount + " slow item" + (result.consolidateDueCount !== 1 ? "s" : ""));
        }
        if (result.expandIndex !== null) {
          parts.push("start " + DISTANCE_GROUPS[result.expandIndex].label + " \u2014 " + result.expandNewCount + " new item" + (result.expandNewCount !== 1 ? "s" : ""));
        }
        recText.textContent = "Suggestion: " + parts.join("\n");
        recBtn.classList.remove("hidden");
      } else {
        recText.textContent = "";
        recBtn.classList.add("hidden");
      }
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var items = mode.getEnabledItems();
      el.textContent = items.length + " items \xB7 60s";
    }
    let currentItem = null;
    const statsControls = createStatsControls(container, (mode2, el) => {
      const colLabels = [];
      for (let s = 1; s <= 11; s++) colLabels.push(String(s));
      const gridDiv = document.createElement("div");
      gridDiv.className = "stats-grid-wrapper";
      el.appendChild(gridDiv);
      renderStatsGrid(engine.selector, colLabels, (noteName, colIdx) => {
        const n = colIdx + 1;
        return [noteName + "+" + n, noteName + "-" + n];
      }, mode2, gridDiv, void 0, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    const mode = {
      id: "semitoneMath",
      name: "Semitone Math",
      storageNamespace: "semitoneMath",
      getEnabledItems() {
        const items = [];
        for (const g of enabledGroups) {
          items.push(...getItemIdsForGroup(g));
        }
        return items;
      },
      getPracticingLabel() {
        if (enabledGroups.size === DISTANCE_GROUPS.length) return "all distances";
        const labels = [...enabledGroups].sort((a, b) => a - b).map((g) => DISTANCE_GROUPS[g].label);
        return labels.join(", ") + " semitones";
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        currentItem.useFlats = currentItem.op === "-";
        const prompt = container.querySelector(".quiz-prompt");
        const noteName = displayNote(pickAccidentalName(currentItem.note.displayName, currentItem.useFlats));
        prompt.textContent = noteName + " " + currentItem.op + " " + currentItem.semitones;
        container.querySelectorAll(".answer-btn-note").forEach((btn) => {
          const note = NOTES.find((n) => n.name === btn.dataset.note);
          if (note) btn.textContent = displayNote(pickAccidentalName(note.displayName, currentItem.useFlats));
        });
      },
      checkAnswer(itemId, input) {
        const correct = noteMatchesInput(currentItem.answer, input);
        return { correct, correctAnswer: displayNote(pickAccidentalName(currentItem.answer.displayName, currentItem.useFlats)) };
      },
      onStart() {
        noteKeyHandler.reset();
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        noteKeyHandler.reset();
        refreshNoteButtonLabels(container);
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        refreshUI();
      },
      handleKey(e, { submitAnswer }) {
        return noteKeyHandler.handleKey(e);
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        const btn = pickCalibrationButton(buttons, prevBtn);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    const noteKeyHandler = createAdaptiveKeyHandler(
      (input) => engine.submitAnswer(input),
      () => true
    );
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      var toggleLabel = container.querySelector(".toggle-group-label");
      if (toggleLabel) toggleLabel.textContent = "Distances";
      const togglesDiv = container.querySelector(".distance-toggles");
      DISTANCE_GROUPS.forEach((group, i) => {
        const btn = document.createElement("button");
        btn.className = "distance-toggle";
        btn.dataset.group = String(i);
        btn.textContent = group.label;
        btn.addEventListener("click", () => toggleGroup(i));
        togglesDiv.appendChild(btn);
      });
      loadEnabledGroups();
      container.querySelectorAll(".answer-btn-note").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.note);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      var recBtn = container.querySelector(".practice-rec-btn");
      if (recBtn) {
        recBtn.addEventListener("click", () => {
          applyRecommendations(engine.selector);
          refreshUI();
        });
      }
      updateRecommendations(engine.selector);
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        refreshNoteButtonLabels(container);
        refreshUI();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
      }
    };
  }

  // src/quiz-interval-math.js
  function createIntervalMathMode() {
    const container = document.getElementById("mode-intervalMath");
    const GROUPS_KEY = "intervalMath_enabledGroups";
    const MATH_INTERVALS = INTERVALS.filter((i) => i.num >= 1 && i.num <= 11);
    const DISTANCE_GROUPS = [
      { distances: [1, 2], label: "m2 M2" },
      { distances: [3, 4], label: "m3 M3" },
      { distances: [5, 6], label: "P4 TT" },
      { distances: [7, 8], label: "P5 m6" },
      { distances: [9, 10], label: "M6 m7" },
      { distances: [11], label: "M7" }
    ];
    let enabledGroups = /* @__PURE__ */ new Set([0]);
    let recommendedGroups = /* @__PURE__ */ new Set();
    const ALL_ITEMS = [];
    for (const note of NOTES) {
      for (const interval of MATH_INTERVALS) {
        ALL_ITEMS.push(note.name + "+" + interval.abbrev);
        ALL_ITEMS.push(note.name + "-" + interval.abbrev);
      }
    }
    function parseItem(itemId) {
      const match = itemId.match(/^([A-G]#?)([+-])(.+)$/);
      const noteName = match[1];
      const op = match[2];
      const abbrev = match[3];
      const note = NOTES.find((n) => n.name === noteName);
      const interval = MATH_INTERVALS.find((i) => i.abbrev === abbrev);
      const answer = op === "+" ? noteAdd(note.num, interval.num) : noteSub(note.num, interval.num);
      return { note, op, interval, answer };
    }
    function getItemIdsForGroup(groupIndex) {
      const distances = DISTANCE_GROUPS[groupIndex].distances;
      const intervals = MATH_INTERVALS.filter((i) => distances.includes(i.num));
      const items = [];
      for (const note of NOTES) {
        for (const interval of intervals) {
          items.push(note.name + "+" + interval.abbrev);
          items.push(note.name + "-" + interval.abbrev);
        }
      }
      return items;
    }
    function loadEnabledGroups() {
      const saved = localStorage.getItem(GROUPS_KEY);
      if (saved) {
        try {
          enabledGroups = new Set(JSON.parse(saved));
        } catch {
        }
      }
      updateGroupToggles();
    }
    function saveEnabledGroups() {
      localStorage.setItem(GROUPS_KEY, JSON.stringify([...enabledGroups]));
    }
    function updateGroupToggles() {
      container.querySelectorAll(".distance-toggle").forEach((btn) => {
        const g = parseInt(btn.dataset.group);
        btn.classList.toggle("active", enabledGroups.has(g));
        btn.classList.toggle("recommended", recommendedGroups.has(g));
      });
    }
    const recsOptions = { sortUnstarted: (a, b) => a.string - b.string };
    function getRecommendationResult() {
      const allGroups = DISTANCE_GROUPS.map((_, i) => i);
      return computeRecommendations(engine.selector, allGroups, getItemIdsForGroup, DEFAULT_CONFIG, recsOptions);
    }
    function updateRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      updateGroupToggles();
    }
    function applyRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      if (result.enabled) {
        enabledGroups = result.enabled;
        saveEnabledGroups();
      }
      updateGroupToggles();
    }
    function toggleGroup(g) {
      if (enabledGroups.has(g)) {
        if (enabledGroups.size > 1) enabledGroups.delete(g);
      } else {
        enabledGroups.add(g);
      }
      saveEnabledGroups();
      refreshUI();
    }
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function refreshUI() {
      updateRecommendations(engine.selector);
      engine.updateIdleMessage();
      renderPracticeSummary();
      renderSessionSummary();
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < items.length; i++) {
        var auto = engine.selector.getAutomaticity(items[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      var allFluent = 0;
      for (var j = 0; j < ALL_ITEMS.length; j++) {
        var a2 = engine.selector.getAutomaticity(ALL_ITEMS[j]);
        if (a2 !== null && a2 > threshold) allFluent++;
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(allFluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = allFluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      var result = getRecommendationResult();
      if (result.recommended.size > 0) {
        var parts = [];
        if (result.consolidateIndices.length > 0) {
          var cNames = result.consolidateIndices.sort(function(a, b) {
            return a - b;
          }).map(function(g) {
            return DISTANCE_GROUPS[g].label;
          });
          parts.push("solidify " + cNames.join(", ") + " \u2014 " + result.consolidateDueCount + " slow item" + (result.consolidateDueCount !== 1 ? "s" : ""));
        }
        if (result.expandIndex !== null) {
          parts.push("start " + DISTANCE_GROUPS[result.expandIndex].label + " \u2014 " + result.expandNewCount + " new item" + (result.expandNewCount !== 1 ? "s" : ""));
        }
        recText.textContent = "Suggestion: " + parts.join("\n");
        recBtn.classList.remove("hidden");
      } else {
        recText.textContent = "";
        recBtn.classList.add("hidden");
      }
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var items = mode.getEnabledItems();
      el.textContent = items.length + " items \xB7 60s";
    }
    let currentItem = null;
    const statsControls = createStatsControls(container, (mode2, el) => {
      const colLabels = MATH_INTERVALS.map((i) => i.abbrev);
      const gridDiv = document.createElement("div");
      gridDiv.className = "stats-grid-wrapper";
      el.appendChild(gridDiv);
      renderStatsGrid(engine.selector, colLabels, (noteName, colIdx) => {
        const abbrev = MATH_INTERVALS[colIdx].abbrev;
        return [noteName + "+" + abbrev, noteName + "-" + abbrev];
      }, mode2, gridDiv, void 0, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    const mode = {
      id: "intervalMath",
      name: "Interval Math",
      storageNamespace: "intervalMath",
      getEnabledItems() {
        const items = [];
        for (const g of enabledGroups) {
          items.push(...getItemIdsForGroup(g));
        }
        return items;
      },
      getPracticingLabel() {
        if (enabledGroups.size === DISTANCE_GROUPS.length) return "all intervals";
        const labels = [...enabledGroups].sort((a, b) => a - b).map((g) => DISTANCE_GROUPS[g].label);
        return labels.join(", ") + " intervals";
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        currentItem.useFlats = currentItem.op === "-";
        const prompt = container.querySelector(".quiz-prompt");
        const noteName = displayNote(pickAccidentalName(currentItem.note.displayName, currentItem.useFlats));
        prompt.textContent = noteName + " " + currentItem.op + " " + currentItem.interval.abbrev;
        container.querySelectorAll(".answer-btn-note").forEach((btn) => {
          const note = NOTES.find((n) => n.name === btn.dataset.note);
          if (note) btn.textContent = displayNote(pickAccidentalName(note.displayName, currentItem.useFlats));
        });
      },
      checkAnswer(itemId, input) {
        const correct = noteMatchesInput(currentItem.answer, input);
        return { correct, correctAnswer: displayNote(pickAccidentalName(currentItem.answer.displayName, currentItem.useFlats)) };
      },
      onStart() {
        noteKeyHandler.reset();
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        noteKeyHandler.reset();
        refreshNoteButtonLabels(container);
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        refreshUI();
      },
      handleKey(e, { submitAnswer }) {
        return noteKeyHandler.handleKey(e);
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        const btn = pickCalibrationButton(buttons, prevBtn);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    const noteKeyHandler = createAdaptiveKeyHandler(
      (input) => engine.submitAnswer(input),
      () => true
    );
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      var toggleLabel = container.querySelector(".toggle-group-label");
      if (toggleLabel) toggleLabel.textContent = "Intervals";
      const togglesDiv = container.querySelector(".distance-toggles");
      DISTANCE_GROUPS.forEach((group, i) => {
        const btn = document.createElement("button");
        btn.className = "distance-toggle";
        btn.dataset.group = String(i);
        btn.textContent = group.label;
        btn.addEventListener("click", () => toggleGroup(i));
        togglesDiv.appendChild(btn);
      });
      loadEnabledGroups();
      container.querySelectorAll(".answer-btn-note").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.note);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      var recBtn = container.querySelector(".practice-rec-btn");
      if (recBtn) {
        recBtn.addEventListener("click", () => {
          applyRecommendations(engine.selector);
          refreshUI();
        });
      }
      updateRecommendations(engine.selector);
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        refreshNoteButtonLabels(container);
        refreshUI();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
      }
    };
  }

  // src/quiz-key-signatures.js
  function createKeySignaturesMode() {
    const container = document.getElementById("mode-keySignatures");
    const GROUPS_KEY = "keySignatures_enabledGroups";
    const KEY_GROUPS = [
      { keys: ["C", "G", "F"], label: "C G F" },
      { keys: ["D", "Bb"], label: "D B\u266D" },
      { keys: ["A", "Eb"], label: "A E\u266D" },
      { keys: ["E", "Ab"], label: "E A\u266D" },
      { keys: ["B", "Db", "F#"], label: "B D\u266D F\u266F" }
    ];
    let enabledGroups = /* @__PURE__ */ new Set([0, 1]);
    let recommendedGroups = /* @__PURE__ */ new Set();
    const ALL_ITEMS = [];
    for (const key of MAJOR_KEYS) {
      ALL_ITEMS.push(key.root + ":fwd");
      ALL_ITEMS.push(key.root + ":rev");
    }
    function parseItem(itemId) {
      const [rootName, dir] = itemId.split(":");
      const key = MAJOR_KEYS.find((k) => k.root === rootName);
      return { key, dir };
    }
    function getItemIdsForGroup(groupIndex) {
      const roots = KEY_GROUPS[groupIndex].keys;
      const items = [];
      for (const root of roots) {
        items.push(root + ":fwd");
        items.push(root + ":rev");
      }
      return items;
    }
    function loadEnabledGroups() {
      const saved = localStorage.getItem(GROUPS_KEY);
      if (saved) {
        try {
          enabledGroups = new Set(JSON.parse(saved));
        } catch {
        }
      }
      updateGroupToggles();
    }
    function saveEnabledGroups() {
      localStorage.setItem(GROUPS_KEY, JSON.stringify([...enabledGroups]));
    }
    function updateGroupToggles() {
      container.querySelectorAll(".distance-toggle").forEach((btn) => {
        const g = parseInt(btn.dataset.group);
        btn.classList.toggle("active", enabledGroups.has(g));
        btn.classList.toggle("recommended", recommendedGroups.has(g));
      });
    }
    const recsOptions = { sortUnstarted: (a, b) => a.string - b.string };
    function getRecommendationResult() {
      const allGroups = KEY_GROUPS.map((_, i) => i);
      return computeRecommendations(engine.selector, allGroups, getItemIdsForGroup, DEFAULT_CONFIG, recsOptions);
    }
    function updateRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      updateGroupToggles();
    }
    function applyRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      if (result.enabled) {
        enabledGroups = result.enabled;
        saveEnabledGroups();
      }
      updateGroupToggles();
    }
    function toggleGroup(g) {
      if (enabledGroups.has(g)) {
        if (enabledGroups.size > 1) enabledGroups.delete(g);
      } else {
        enabledGroups.add(g);
      }
      saveEnabledGroups();
      refreshUI();
    }
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function refreshUI() {
      updateRecommendations(engine.selector);
      engine.updateIdleMessage();
      renderPracticeSummary();
      renderSessionSummary();
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < items.length; i++) {
        var auto = engine.selector.getAutomaticity(items[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      var allFluent = 0;
      for (var j = 0; j < ALL_ITEMS.length; j++) {
        var a2 = engine.selector.getAutomaticity(ALL_ITEMS[j]);
        if (a2 !== null && a2 > threshold) allFluent++;
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(allFluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = allFluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      var result = getRecommendationResult();
      if (result.recommended.size > 0) {
        var parts = [];
        if (result.consolidateIndices.length > 0) {
          var cNames = result.consolidateIndices.sort(function(a, b) {
            return a - b;
          }).map(function(g) {
            return KEY_GROUPS[g].label;
          });
          parts.push("solidify " + cNames.join(", ") + " \u2014 " + result.consolidateDueCount + " slow item" + (result.consolidateDueCount !== 1 ? "s" : ""));
        }
        if (result.expandIndex !== null) {
          parts.push("start " + KEY_GROUPS[result.expandIndex].label + " \u2014 " + result.expandNewCount + " new item" + (result.expandNewCount !== 1 ? "s" : ""));
        }
        recText.textContent = "Suggestion: " + parts.join("\n");
        recBtn.classList.remove("hidden");
      } else {
        recText.textContent = "";
        recBtn.classList.add("hidden");
      }
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var items = mode.getEnabledItems();
      el.textContent = items.length + " items \xB7 60s";
    }
    let currentItem = null;
    function getTableRows() {
      return MAJOR_KEYS.map((key) => ({
        label: displayNote(key.root) + " major",
        sublabel: keySignatureLabel(key),
        _colHeader: "Key",
        fwdItemId: key.root + ":fwd",
        revItemId: key.root + ":rev"
      }));
    }
    const statsControls = createStatsControls(container, (mode2, el) => {
      const tableDiv = document.createElement("div");
      el.appendChild(tableDiv);
      renderStatsTable(engine.selector, getTableRows(), "Key\u2192Sig", "Sig\u2192Key", mode2, tableDiv, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    let pendingSigDigit = null;
    let pendingSigTimeout = null;
    const mode = {
      id: "keySignatures",
      name: "Key Signatures",
      storageNamespace: "keySignatures",
      getEnabledItems() {
        const items = [];
        for (const g of enabledGroups) {
          items.push(...getItemIdsForGroup(g));
        }
        return items;
      },
      getPracticingLabel() {
        if (enabledGroups.size === KEY_GROUPS.length) return "all keys";
        const keys = [...enabledGroups].sort((a, b) => a - b).flatMap((g) => KEY_GROUPS[g].keys).map((k) => displayNote(k));
        return keys.join(", ");
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        const prompt = container.querySelector(".quiz-prompt");
        const sigButtons = container.querySelector(".answer-buttons-keysig");
        const noteButtons = container.querySelector(".answer-buttons-notes");
        if (currentItem.dir === "fwd") {
          prompt.textContent = displayNote(currentItem.key.root) + " major";
          sigButtons.classList.remove("answer-group-hidden");
          noteButtons.classList.add("answer-group-hidden");
        } else {
          const label = keySignatureLabel(currentItem.key);
          prompt.textContent = label + " major";
          sigButtons.classList.add("answer-group-hidden");
          noteButtons.classList.remove("answer-group-hidden");
        }
      },
      checkAnswer(itemId, input) {
        if (currentItem.dir === "fwd") {
          const expected = keySignatureLabel(currentItem.key);
          return { correct: input === expected, correctAnswer: expected };
        } else {
          const correct = spelledNoteMatchesSemitone(currentItem.key.root, input);
          return { correct, correctAnswer: displayNote(currentItem.key.root) };
        }
      },
      onStart() {
        noteKeyHandler.reset();
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        noteKeyHandler.reset();
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        refreshUI();
      },
      handleKey(e, { submitAnswer }) {
        if (currentItem.dir === "rev") {
          return noteKeyHandler.handleKey(e);
        }
        if (e.key >= "0" && e.key <= "7") {
          e.preventDefault();
          if (pendingSigTimeout) clearTimeout(pendingSigTimeout);
          pendingSigDigit = e.key;
          pendingSigTimeout = setTimeout(() => {
            if (pendingSigDigit === "0") {
              submitAnswer("0");
            }
            pendingSigDigit = null;
            pendingSigTimeout = null;
          }, 600);
          return true;
        }
        if (pendingSigDigit !== null && (e.key === "#" || e.key === "b")) {
          e.preventDefault();
          clearTimeout(pendingSigTimeout);
          const answer = pendingSigDigit + e.key;
          pendingSigDigit = null;
          pendingSigTimeout = null;
          submitAnswer(answer);
          return true;
        }
        return false;
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        const btn = pickCalibrationButton(buttons, prevBtn);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    const noteKeyHandler = createAdaptiveKeyHandler(
      (input) => engine.submitAnswer(input),
      () => true
    );
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      var toggleLabel = container.querySelector(".toggle-group-label");
      if (toggleLabel) toggleLabel.textContent = "Keys";
      const togglesDiv = container.querySelector(".distance-toggles");
      KEY_GROUPS.forEach((group, i) => {
        const btn = document.createElement("button");
        btn.className = "distance-toggle";
        btn.dataset.group = String(i);
        btn.textContent = group.label;
        btn.addEventListener("click", () => toggleGroup(i));
        togglesDiv.appendChild(btn);
      });
      loadEnabledGroups();
      container.querySelectorAll(".answer-btn-keysig").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.sig);
        });
      });
      container.querySelectorAll(".answer-btn-note").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.note);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      var recBtn = container.querySelector(".practice-rec-btn");
      if (recBtn) {
        recBtn.addEventListener("click", () => {
          applyRecommendations(engine.selector);
          refreshUI();
        });
      }
      updateRecommendations(engine.selector);
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        refreshNoteButtonLabels(container);
        refreshUI();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
        if (pendingSigTimeout) clearTimeout(pendingSigTimeout);
        pendingSigDigit = null;
      }
    };
  }

  // src/quiz-scale-degrees.js
  function createScaleDegreesMode() {
    const container = document.getElementById("mode-scaleDegrees");
    const GROUPS_KEY = "scaleDegrees_enabledGroups";
    const DEGREE_GROUPS = [
      { degrees: [1, 5], label: "1st,5th" },
      { degrees: [4], label: "4th" },
      { degrees: [3, 7], label: "3rd,7th" },
      { degrees: [2, 6], label: "2nd,6th" }
    ];
    let enabledGroups = /* @__PURE__ */ new Set([0]);
    let recommendedGroups = /* @__PURE__ */ new Set();
    const ALL_ITEMS = [];
    for (const key of MAJOR_KEYS) {
      for (let d = 1; d <= 7; d++) {
        ALL_ITEMS.push(key.root + ":" + d + ":fwd");
        ALL_ITEMS.push(key.root + ":" + d + ":rev");
      }
    }
    const DEGREE_LABELS = ["1st", "2nd", "3rd", "4th", "5th", "6th", "7th"];
    function parseItem(itemId) {
      const parts = itemId.split(":");
      const keyRoot = parts[0];
      const degree = parseInt(parts[1]);
      const dir = parts[2];
      const key = MAJOR_KEYS.find((k) => k.root === keyRoot);
      const noteName = getScaleDegreeNote(keyRoot, degree);
      return { key, degree, dir, noteName };
    }
    function getItemIdsForGroup(groupIndex) {
      const degrees = DEGREE_GROUPS[groupIndex].degrees;
      const items = [];
      for (const key of MAJOR_KEYS) {
        for (const d of degrees) {
          items.push(key.root + ":" + d + ":fwd");
          items.push(key.root + ":" + d + ":rev");
        }
      }
      return items;
    }
    function loadEnabledGroups() {
      const saved = localStorage.getItem(GROUPS_KEY);
      if (saved) {
        try {
          enabledGroups = new Set(JSON.parse(saved));
        } catch {
        }
      }
      updateGroupToggles();
    }
    function saveEnabledGroups() {
      localStorage.setItem(GROUPS_KEY, JSON.stringify([...enabledGroups]));
    }
    function updateGroupToggles() {
      container.querySelectorAll(".distance-toggle").forEach((btn) => {
        const g = parseInt(btn.dataset.group);
        btn.classList.toggle("active", enabledGroups.has(g));
        btn.classList.toggle("recommended", recommendedGroups.has(g));
      });
    }
    const recsOptions = { sortUnstarted: (a, b) => a.string - b.string };
    function getRecommendationResult() {
      const allGroups = DEGREE_GROUPS.map((_, i) => i);
      return computeRecommendations(engine.selector, allGroups, getItemIdsForGroup, DEFAULT_CONFIG, recsOptions);
    }
    function updateRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      updateGroupToggles();
    }
    function applyRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      if (result.enabled) {
        enabledGroups = result.enabled;
        saveEnabledGroups();
      }
      updateGroupToggles();
    }
    function toggleGroup(g) {
      if (enabledGroups.has(g)) {
        if (enabledGroups.size > 1) enabledGroups.delete(g);
      } else {
        enabledGroups.add(g);
      }
      saveEnabledGroups();
      refreshUI();
    }
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function refreshUI() {
      updateRecommendations(engine.selector);
      engine.updateIdleMessage();
      renderPracticeSummary();
      renderSessionSummary();
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < items.length; i++) {
        var auto = engine.selector.getAutomaticity(items[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      var allFluent = 0;
      for (var j = 0; j < ALL_ITEMS.length; j++) {
        var a2 = engine.selector.getAutomaticity(ALL_ITEMS[j]);
        if (a2 !== null && a2 > threshold) allFluent++;
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(allFluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = allFluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      var result = getRecommendationResult();
      if (result.recommended.size > 0) {
        var parts = [];
        if (result.consolidateIndices.length > 0) {
          var cNames = result.consolidateIndices.sort(function(a, b) {
            return a - b;
          }).map(function(g) {
            return DEGREE_GROUPS[g].label;
          });
          parts.push("solidify " + cNames.join(", ") + " \u2014 " + result.consolidateDueCount + " slow item" + (result.consolidateDueCount !== 1 ? "s" : ""));
        }
        if (result.expandIndex !== null) {
          parts.push("start " + DEGREE_GROUPS[result.expandIndex].label + " \u2014 " + result.expandNewCount + " new item" + (result.expandNewCount !== 1 ? "s" : ""));
        }
        recText.textContent = "Suggestion: " + parts.join("\n");
        recBtn.classList.remove("hidden");
      } else {
        recText.textContent = "";
        recBtn.classList.add("hidden");
      }
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var items = mode.getEnabledItems();
      el.textContent = items.length + " items \xB7 60s";
    }
    let currentItem = null;
    const statsControls = createStatsControls(container, (mode2, el) => {
      const colLabels = DEGREE_LABELS;
      const gridDiv = document.createElement("div");
      gridDiv.className = "stats-grid-wrapper";
      el.appendChild(gridDiv);
      const keyNotes = MAJOR_KEYS.map((k) => ({ name: k.root, displayName: k.root }));
      renderStatsGrid(engine.selector, colLabels, (keyRoot, colIdx) => {
        const d = colIdx + 1;
        return [keyRoot + ":" + d + ":fwd", keyRoot + ":" + d + ":rev"];
      }, mode2, gridDiv, keyNotes, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    const mode = {
      id: "scaleDegrees",
      name: "Scale Degrees",
      storageNamespace: "scaleDegrees",
      getEnabledItems() {
        const items = [];
        for (const g of enabledGroups) {
          items.push(...getItemIdsForGroup(g));
        }
        return items;
      },
      getPracticingLabel() {
        if (enabledGroups.size === DEGREE_GROUPS.length) return "all degrees";
        const degrees = [...enabledGroups].sort((a, b) => a - b).flatMap((g) => DEGREE_GROUPS[g].degrees).sort((a, b) => a - b);
        return degrees.map((d) => DEGREE_LABELS[d - 1]).join(", ") + " degrees";
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        const prompt = container.querySelector(".quiz-prompt");
        const noteButtons = container.querySelector(".answer-buttons-notes");
        const degreeButtons = container.querySelector(".answer-buttons-degrees");
        if (currentItem.dir === "fwd") {
          prompt.textContent = DEGREE_LABELS[currentItem.degree - 1] + " of " + displayNote(currentItem.key.root) + " major";
          noteButtons.classList.remove("answer-group-hidden");
          degreeButtons.classList.add("answer-group-hidden");
        } else {
          prompt.textContent = displayNote(currentItem.key.root) + " major: " + displayNote(currentItem.noteName);
          noteButtons.classList.add("answer-group-hidden");
          degreeButtons.classList.remove("answer-group-hidden");
        }
      },
      checkAnswer(itemId, input) {
        if (currentItem.dir === "fwd") {
          const correct = spelledNoteMatchesSemitone(currentItem.noteName, input);
          return { correct, correctAnswer: displayNote(currentItem.noteName) };
        } else {
          const expectedDegree = String(currentItem.degree);
          return { correct: input === expectedDegree, correctAnswer: DEGREE_LABELS[currentItem.degree - 1] };
        }
      },
      onStart() {
        noteKeyHandler.reset();
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        noteKeyHandler.reset();
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        refreshUI();
      },
      handleKey(e, { submitAnswer }) {
        if (currentItem.dir === "fwd") {
          return noteKeyHandler.handleKey(e);
        }
        if (e.key >= "1" && e.key <= "7") {
          e.preventDefault();
          submitAnswer(e.key);
          return true;
        }
        return false;
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        const btn = pickCalibrationButton(buttons, prevBtn);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    const noteKeyHandler = createAdaptiveKeyHandler(
      (input) => engine.submitAnswer(input),
      () => true
    );
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      var toggleLabel = container.querySelector(".toggle-group-label");
      if (toggleLabel) toggleLabel.textContent = "Degrees";
      const togglesDiv = container.querySelector(".distance-toggles");
      DEGREE_GROUPS.forEach((group, i) => {
        const btn = document.createElement("button");
        btn.className = "distance-toggle";
        btn.dataset.group = String(i);
        btn.textContent = group.label;
        btn.addEventListener("click", () => toggleGroup(i));
        togglesDiv.appendChild(btn);
      });
      loadEnabledGroups();
      container.querySelectorAll(".answer-btn-note").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.note);
        });
      });
      container.querySelectorAll(".answer-btn-degree").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.degree);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      var recBtn = container.querySelector(".practice-rec-btn");
      if (recBtn) {
        recBtn.addEventListener("click", () => {
          applyRecommendations(engine.selector);
          refreshUI();
        });
      }
      updateRecommendations(engine.selector);
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        refreshNoteButtonLabels(container);
        refreshUI();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
      }
    };
  }

  // src/quiz-diatonic-chords.js
  function createDiatonicChordsMode() {
    const container = document.getElementById("mode-diatonicChords");
    const GROUPS_KEY = "diatonicChords_enabledGroups";
    const CHORD_GROUPS = [
      { degrees: [1, 4, 5], label: "I,IV,V" },
      { degrees: [2, 6], label: "ii,vi" },
      { degrees: [3, 7], label: "iii,vii\xB0" }
    ];
    let enabledGroups = /* @__PURE__ */ new Set([0]);
    let recommendedGroups = /* @__PURE__ */ new Set();
    const ALL_ITEMS = [];
    for (const key of MAJOR_KEYS) {
      for (let d = 1; d <= 7; d++) {
        ALL_ITEMS.push(key.root + ":" + d + ":fwd");
        ALL_ITEMS.push(key.root + ":" + d + ":rev");
      }
    }
    function parseItem(itemId) {
      const parts = itemId.split(":");
      const keyRoot = parts[0];
      const degree = parseInt(parts[1]);
      const dir = parts[2];
      const key = MAJOR_KEYS.find((k) => k.root === keyRoot);
      const chord = DIATONIC_CHORDS[degree - 1];
      const rootNote = getScaleDegreeNote(keyRoot, degree);
      return { key, degree, dir, chord, rootNote };
    }
    function getItemIdsForGroup(groupIndex) {
      const degrees = CHORD_GROUPS[groupIndex].degrees;
      const items = [];
      for (const key of MAJOR_KEYS) {
        for (const d of degrees) {
          items.push(key.root + ":" + d + ":fwd");
          items.push(key.root + ":" + d + ":rev");
        }
      }
      return items;
    }
    function loadEnabledGroups() {
      const saved = localStorage.getItem(GROUPS_KEY);
      if (saved) {
        try {
          enabledGroups = new Set(JSON.parse(saved));
        } catch {
        }
      }
      updateGroupToggles();
    }
    function saveEnabledGroups() {
      localStorage.setItem(GROUPS_KEY, JSON.stringify([...enabledGroups]));
    }
    function updateGroupToggles() {
      container.querySelectorAll(".distance-toggle").forEach((btn) => {
        const g = parseInt(btn.dataset.group);
        btn.classList.toggle("active", enabledGroups.has(g));
        btn.classList.toggle("recommended", recommendedGroups.has(g));
      });
    }
    const recsOptions = { sortUnstarted: (a, b) => a.string - b.string };
    function getRecommendationResult() {
      const allGroups = CHORD_GROUPS.map((_, i) => i);
      return computeRecommendations(engine.selector, allGroups, getItemIdsForGroup, DEFAULT_CONFIG, recsOptions);
    }
    function updateRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      updateGroupToggles();
    }
    function applyRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      if (result.enabled) {
        enabledGroups = result.enabled;
        saveEnabledGroups();
      }
      updateGroupToggles();
    }
    function toggleGroup(g) {
      if (enabledGroups.has(g)) {
        if (enabledGroups.size > 1) enabledGroups.delete(g);
      } else {
        enabledGroups.add(g);
      }
      saveEnabledGroups();
      refreshUI();
    }
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function refreshUI() {
      updateRecommendations(engine.selector);
      engine.updateIdleMessage();
      renderPracticeSummary();
      renderSessionSummary();
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < items.length; i++) {
        var auto = engine.selector.getAutomaticity(items[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      var allFluent = 0;
      for (var j = 0; j < ALL_ITEMS.length; j++) {
        var a2 = engine.selector.getAutomaticity(ALL_ITEMS[j]);
        if (a2 !== null && a2 > threshold) allFluent++;
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(allFluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = allFluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      var result = getRecommendationResult();
      if (result.recommended.size > 0) {
        var parts = [];
        if (result.consolidateIndices.length > 0) {
          var cNames = result.consolidateIndices.sort(function(a, b) {
            return a - b;
          }).map(function(g) {
            return CHORD_GROUPS[g].label;
          });
          parts.push("solidify " + cNames.join(", ") + " \u2014 " + result.consolidateDueCount + " slow item" + (result.consolidateDueCount !== 1 ? "s" : ""));
        }
        if (result.expandIndex !== null) {
          parts.push("start " + CHORD_GROUPS[result.expandIndex].label + " \u2014 " + result.expandNewCount + " new item" + (result.expandNewCount !== 1 ? "s" : ""));
        }
        recText.textContent = "Suggestion: " + parts.join("\n");
        recBtn.classList.remove("hidden");
      } else {
        recText.textContent = "";
        recBtn.classList.add("hidden");
      }
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var items = mode.getEnabledItems();
      el.textContent = items.length + " items \xB7 60s";
    }
    let currentItem = null;
    const statsControls = createStatsControls(container, (mode2, el) => {
      const colLabels = ROMAN_NUMERALS;
      const gridDiv = document.createElement("div");
      gridDiv.className = "stats-grid-wrapper";
      el.appendChild(gridDiv);
      const keyNotes = MAJOR_KEYS.map((k) => ({ name: k.root, displayName: k.root }));
      renderStatsGrid(engine.selector, colLabels, (keyRoot, colIdx) => {
        const d = colIdx + 1;
        return [keyRoot + ":" + d + ":fwd", keyRoot + ":" + d + ":rev"];
      }, mode2, gridDiv, keyNotes, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    const mode = {
      id: "diatonicChords",
      name: "Diatonic Chords",
      storageNamespace: "diatonicChords",
      getEnabledItems() {
        const items = [];
        for (const g of enabledGroups) {
          items.push(...getItemIdsForGroup(g));
        }
        return items;
      },
      getPracticingLabel() {
        if (enabledGroups.size === CHORD_GROUPS.length) return "all chords";
        const numerals = [...enabledGroups].sort((a, b) => a - b).flatMap((g) => CHORD_GROUPS[g].degrees).sort((a, b) => a - b).map((d) => ROMAN_NUMERALS[d - 1]);
        return numerals.join(", ") + " chords";
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        const prompt = container.querySelector(".quiz-prompt");
        const noteButtons = container.querySelector(".answer-buttons-notes");
        const numeralButtons = container.querySelector(".answer-buttons-numerals");
        if (currentItem.dir === "fwd") {
          prompt.textContent = currentItem.chord.numeral + " in " + displayNote(currentItem.key.root) + " major";
          noteButtons.classList.remove("answer-group-hidden");
          numeralButtons.classList.add("answer-group-hidden");
        } else {
          const chordName = displayNote(currentItem.rootNote) + currentItem.chord.qualityLabel;
          prompt.textContent = chordName + " in " + displayNote(currentItem.key.root) + " major";
          noteButtons.classList.add("answer-group-hidden");
          numeralButtons.classList.remove("answer-group-hidden");
        }
      },
      checkAnswer(itemId, input) {
        if (currentItem.dir === "fwd") {
          const correct = spelledNoteMatchesSemitone(currentItem.rootNote, input);
          const fullAnswer = displayNote(currentItem.rootNote) + " " + currentItem.chord.quality;
          return { correct, correctAnswer: fullAnswer };
        } else {
          const expectedNumeral = currentItem.chord.numeral;
          return { correct: input === expectedNumeral, correctAnswer: expectedNumeral };
        }
      },
      onStart() {
        noteKeyHandler.reset();
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        noteKeyHandler.reset();
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        refreshUI();
      },
      handleKey(e, { submitAnswer }) {
        if (currentItem.dir === "fwd") {
          return noteKeyHandler.handleKey(e);
        }
        if (e.key >= "1" && e.key <= "7") {
          e.preventDefault();
          submitAnswer(ROMAN_NUMERALS[parseInt(e.key) - 1]);
          return true;
        }
        return false;
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        const btn = pickCalibrationButton(buttons, prevBtn);
        return { prompt: "Press " + btn.textContent, targetButtons: [btn] };
      }
    };
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    const noteKeyHandler = createAdaptiveKeyHandler(
      (input) => engine.submitAnswer(input),
      () => true
    );
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      var toggleLabel = container.querySelector(".toggle-group-label");
      if (toggleLabel) toggleLabel.textContent = "Chords";
      const togglesDiv = container.querySelector(".distance-toggles");
      CHORD_GROUPS.forEach((group, i) => {
        const btn = document.createElement("button");
        btn.className = "distance-toggle";
        btn.dataset.group = String(i);
        btn.textContent = group.label;
        btn.addEventListener("click", () => toggleGroup(i));
        togglesDiv.appendChild(btn);
      });
      loadEnabledGroups();
      container.querySelectorAll(".answer-btn-note").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.note);
        });
      });
      container.querySelectorAll(".answer-btn-numeral").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          engine.submitAnswer(btn.dataset.numeral);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      var recBtn = container.querySelector(".practice-rec-btn");
      if (recBtn) {
        recBtn.addEventListener("click", () => {
          applyRecommendations(engine.selector);
          refreshUI();
        });
      }
      updateRecommendations(engine.selector);
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        refreshNoteButtonLabels(container);
        refreshUI();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
      }
    };
  }

  // src/quiz-chord-spelling.js
  function createChordSpellingMode() {
    const container = document.getElementById("mode-chordSpelling");
    const GROUPS_KEY = "chordSpelling_enabledGroups";
    const SPELLING_GROUPS = [];
    let maxGroup = 0;
    for (const ct of CHORD_TYPES) {
      if (ct.group > maxGroup) maxGroup = ct.group;
    }
    for (let g = 0; g <= maxGroup; g++) {
      const types = CHORD_TYPES.filter((t) => t.group === g);
      const label = types.map((t) => t.symbol || "maj").join(", ");
      SPELLING_GROUPS.push({ types, label });
    }
    let enabledGroups = /* @__PURE__ */ new Set([0]);
    let recommendedGroups = /* @__PURE__ */ new Set();
    const ALL_ITEMS = [];
    for (const root of CHORD_ROOTS) {
      for (const type of CHORD_TYPES) {
        ALL_ITEMS.push(root + ":" + type.name);
      }
    }
    function parseItem(itemId) {
      const colonIdx = itemId.indexOf(":");
      const rootName = itemId.substring(0, colonIdx);
      const typeName = itemId.substring(colonIdx + 1);
      const chordType = CHORD_TYPES.find((t) => t.name === typeName);
      const tones = getChordTones(rootName, chordType);
      return { rootName, chordType, tones };
    }
    function getItemIdsForGroup(groupIndex) {
      const types = SPELLING_GROUPS[groupIndex].types;
      const items = [];
      for (const root of CHORD_ROOTS) {
        for (const type of types) {
          items.push(root + ":" + type.name);
        }
      }
      return items;
    }
    function loadEnabledGroups() {
      const saved = localStorage.getItem(GROUPS_KEY);
      if (saved) {
        try {
          enabledGroups = new Set(JSON.parse(saved));
        } catch {
        }
      }
      updateGroupToggles();
    }
    function saveEnabledGroups() {
      localStorage.setItem(GROUPS_KEY, JSON.stringify([...enabledGroups]));
    }
    function updateGroupToggles() {
      container.querySelectorAll(".distance-toggle").forEach((btn) => {
        const g = parseInt(btn.dataset.group);
        btn.classList.toggle("active", enabledGroups.has(g));
        btn.classList.toggle("recommended", recommendedGroups.has(g));
      });
    }
    const recsOptions = { sortUnstarted: (a, b) => a.string - b.string };
    function getRecommendationResult() {
      const allGroups = SPELLING_GROUPS.map((_, i) => i);
      return computeRecommendations(engine.selector, allGroups, getItemIdsForGroup, DEFAULT_CONFIG, recsOptions);
    }
    function updateRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      updateGroupToggles();
    }
    function applyRecommendations(selector) {
      const result = getRecommendationResult();
      recommendedGroups = result.recommended;
      if (result.enabled) {
        enabledGroups = result.enabled;
        saveEnabledGroups();
      }
      updateGroupToggles();
    }
    function toggleGroup(g) {
      if (enabledGroups.has(g)) {
        if (enabledGroups.size > 1) enabledGroups.delete(g);
      } else {
        enabledGroups.add(g);
      }
      saveEnabledGroups();
      refreshUI();
    }
    let activeTab = "practice";
    function switchTab(tabName) {
      activeTab = tabName;
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });
      container.querySelectorAll(".tab-content").forEach((el) => {
        el.classList.toggle(
          "active",
          tabName === "practice" ? el.classList.contains("tab-practice") : el.classList.contains("tab-progress")
        );
      });
      if (tabName === "progress") {
        statsControls.show(statsControls.mode || "retention");
      } else {
        renderPracticeSummary();
      }
    }
    function refreshUI() {
      updateRecommendations(engine.selector);
      engine.updateIdleMessage();
      renderPracticeSummary();
      renderSessionSummary();
    }
    function renderPracticeSummary() {
      var statusLabel = container.querySelector(".practice-status-label");
      var statusDetail = container.querySelector(".practice-status-detail");
      var recText = container.querySelector(".practice-rec-text");
      var recBtn = container.querySelector(".practice-rec-btn");
      if (!statusLabel) return;
      var items = mode.getEnabledItems();
      var threshold = engine.selector.getConfig().automaticityThreshold;
      var fluent = 0, seen = 0;
      for (var i = 0; i < items.length; i++) {
        var auto = engine.selector.getAutomaticity(items[i]);
        if (auto !== null) {
          seen++;
          if (auto > threshold) fluent++;
        }
      }
      var allFluent = 0;
      for (var j = 0; j < ALL_ITEMS.length; j++) {
        var a2 = engine.selector.getAutomaticity(ALL_ITEMS[j]);
        if (a2 !== null && a2 > threshold) allFluent++;
      }
      if (seen === 0) {
        statusLabel.textContent = "Ready to start";
        statusDetail.textContent = ALL_ITEMS.length + " items to learn";
      } else {
        var pct = ALL_ITEMS.length > 0 ? Math.round(allFluent / ALL_ITEMS.length * 100) : 0;
        var label;
        if (pct >= 80) label = "Strong";
        else if (pct >= 50) label = "Solid";
        else if (pct >= 20) label = "Building";
        else label = "Getting started";
        statusLabel.textContent = "Overall: " + label;
        statusDetail.textContent = allFluent + " of " + ALL_ITEMS.length + " items fluent";
      }
      var result = getRecommendationResult();
      if (result.recommended.size > 0) {
        var parts = [];
        if (result.consolidateIndices.length > 0) {
          var cNames = result.consolidateIndices.sort(function(a, b) {
            return a - b;
          }).map(function(g) {
            return SPELLING_GROUPS[g].label;
          });
          parts.push("solidify " + cNames.join(", ") + " \u2014 " + result.consolidateDueCount + " slow item" + (result.consolidateDueCount !== 1 ? "s" : ""));
        }
        if (result.expandIndex !== null) {
          parts.push("start " + SPELLING_GROUPS[result.expandIndex].label + " \u2014 " + result.expandNewCount + " new item" + (result.expandNewCount !== 1 ? "s" : ""));
        }
        recText.textContent = "Suggestion: " + parts.join("\n");
        recBtn.classList.remove("hidden");
      } else {
        recText.textContent = "";
        recBtn.classList.add("hidden");
      }
    }
    function renderSessionSummary() {
      var el = container.querySelector(".session-summary-text");
      if (!el) return;
      var items = mode.getEnabledItems();
      el.textContent = items.length + " items \xB7 60s";
    }
    let currentItem = null;
    let enteredTones = [];
    function renderSlots() {
      const slotsDiv = container.querySelector(".chord-slots");
      if (!currentItem) {
        slotsDiv.innerHTML = "";
        return;
      }
      let html = "";
      for (let i = 0; i < currentItem.tones.length; i++) {
        let cls = "chord-slot";
        let content = "_";
        if (i < enteredTones.length) {
          content = enteredTones[i].display;
          cls += enteredTones[i].correct ? " correct" : " wrong";
        } else if (i === enteredTones.length) {
          cls += " active";
        }
        html += '<span class="' + cls + '">' + content + "</span>";
      }
      slotsDiv.innerHTML = html;
    }
    function submitTone(input) {
      if (!engine.isActive || engine.isAnswered) return;
      if (!currentItem || enteredTones.length >= currentItem.tones.length) return;
      const idx = enteredTones.length;
      const expected = currentItem.tones[idx];
      const isCorrect = spelledNoteMatchesInput(expected, input);
      enteredTones.push({
        input,
        display: isCorrect ? displayNote(expected) : displayNote(input),
        correct: isCorrect
      });
      renderSlots();
      if (enteredTones.length === currentItem.tones.length) {
        const allCorrect = enteredTones.every((t) => t.correct);
        engine.submitAnswer(allCorrect ? "__correct__" : "__wrong__");
      }
    }
    const statsControls = createStatsControls(container, (mode2, el) => {
      const colLabels = CHORD_TYPES.map((t) => t.symbol || "maj");
      const gridDiv = document.createElement("div");
      gridDiv.className = "stats-grid-wrapper";
      el.appendChild(gridDiv);
      const rootNotes = CHORD_ROOTS.map((r) => ({ name: r, displayName: r }));
      renderStatsGrid(engine.selector, colLabels, (rootName, colIdx) => {
        return rootName + ":" + CHORD_TYPES[colIdx].name;
      }, mode2, gridDiv, rootNotes, engine.baseline);
      const legendDiv = document.createElement("div");
      legendDiv.innerHTML = buildStatsLegend(mode2, engine.baseline);
      el.appendChild(legendDiv);
    });
    const mode = {
      id: "chordSpelling",
      name: "Chord Spelling",
      storageNamespace: "chordSpelling",
      getEnabledItems() {
        const items = [];
        for (const g of enabledGroups) {
          items.push(...getItemIdsForGroup(g));
        }
        return items;
      },
      getPracticingLabel() {
        if (enabledGroups.size === SPELLING_GROUPS.length) return "all chord types";
        const labels = [...enabledGroups].sort((a, b) => a - b).map((g) => SPELLING_GROUPS[g].label);
        return labels.join(", ") + " chords";
      },
      getExpectedResponseCount(itemId) {
        const parsed = parseItem(itemId);
        return parsed.tones.length;
      },
      presentQuestion(itemId) {
        currentItem = parseItem(itemId);
        enteredTones = [];
        const prompt = container.querySelector(".quiz-prompt");
        prompt.textContent = displayNote(currentItem.rootName) + currentItem.chordType.symbol;
        renderSlots();
      },
      checkAnswer(itemId, input) {
        const allCorrect = input === "__correct__";
        const correctAnswer = currentItem.tones.map(displayNote).join(" ");
        return { correct: allCorrect, correctAnswer };
      },
      onStart() {
        noteKeyHandler.reset();
        enteredTones = [];
        if (statsControls.mode) statsControls.hide();
      },
      onStop() {
        noteKeyHandler.reset();
        enteredTones = [];
        const slotsDiv = container.querySelector(".chord-slots");
        slotsDiv.innerHTML = "";
        if (activeTab === "progress") {
          statsControls.show("retention");
        }
        refreshUI();
      },
      handleKey(e, ctx) {
        return noteKeyHandler.handleKey(e);
      },
      getCalibrationButtons() {
        return Array.from(container.querySelectorAll(".answer-btn-note"));
      },
      getCalibrationTrialConfig(buttons, prevBtn) {
        const count = 2 + Math.floor(Math.random() * 3);
        const targets = [];
        let prev = prevBtn;
        for (let i = 0; i < count; i++) {
          const btn = pickCalibrationButton(buttons, prev);
          targets.push(btn);
          prev = btn;
        }
        const labels = targets.map((b) => b.textContent);
        return { prompt: "Press " + labels.join(" "), targetButtons: targets };
      },
      calibrationIntroHint: "We\u2019ll measure your response speed to set personalized targets. Press the notes shown in the prompt, in order \u2014 10 rounds total."
    };
    const engine = createQuizEngine(mode, container);
    engine.storage.preload(ALL_ITEMS);
    const noteKeyHandler = createAdaptiveKeyHandler(
      (input) => submitTone(input),
      () => true
    );
    function init() {
      container.querySelectorAll(".mode-tab").forEach((btn) => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });
      var toggleLabel = container.querySelector(".toggle-group-label");
      if (toggleLabel) toggleLabel.textContent = "Chord types";
      const togglesDiv = container.querySelector(".distance-toggles");
      SPELLING_GROUPS.forEach((group, i) => {
        const btn = document.createElement("button");
        btn.className = "distance-toggle";
        btn.dataset.group = String(i);
        btn.textContent = group.label;
        btn.addEventListener("click", () => toggleGroup(i));
        togglesDiv.appendChild(btn);
      });
      loadEnabledGroups();
      container.querySelectorAll(".answer-btn-note").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (!engine.isActive || engine.isAnswered) return;
          let input = btn.dataset.note;
          if (currentItem && enteredTones.length < currentItem.tones.length) {
            const expected = currentItem.tones[enteredTones.length];
            if (spelledNoteMatchesSemitone(expected, input)) {
              input = expected;
            }
          }
          submitTone(input);
        });
      });
      container.querySelector(".start-btn").addEventListener("click", () => engine.start());
      var recBtn = container.querySelector(".practice-rec-btn");
      if (recBtn) {
        recBtn.addEventListener("click", () => {
          applyRecommendations(engine.selector);
          refreshUI();
        });
      }
      updateRecommendations(engine.selector);
      renderPracticeSummary();
      renderSessionSummary();
    }
    return {
      mode,
      engine,
      init,
      activate() {
        engine.attach();
        refreshNoteButtonLabels(container);
        refreshUI();
      },
      deactivate() {
        if (engine.isRunning) engine.stop();
        engine.detach();
        noteKeyHandler.reset();
      }
    };
  }

  // src/navigation.js
  function createNavigation() {
    const LAST_MODE_KEY = "fretboard_lastMode";
    const modes = {};
    let currentModeId = null;
    const homeScreen = document.getElementById("home-screen");
    function registerMode(id, modeController) {
      modes[id] = modeController;
    }
    function navigateHome() {
      if (currentModeId && modes[currentModeId]) {
        modes[currentModeId].deactivate();
        const currentScreen = document.getElementById("mode-" + currentModeId);
        if (currentScreen) currentScreen.classList.remove("mode-active");
      }
      currentModeId = null;
      if (homeScreen) homeScreen.classList.remove("hidden");
    }
    function switchTo(modeId) {
      if (!modes[modeId]) return;
      if (homeScreen) homeScreen.classList.add("hidden");
      if (currentModeId && modes[currentModeId]) {
        modes[currentModeId].deactivate();
        const currentScreen = document.getElementById("mode-" + currentModeId);
        if (currentScreen) currentScreen.classList.remove("mode-active");
      }
      currentModeId = modeId;
      const newScreen = document.getElementById("mode-" + modeId);
      if (newScreen) newScreen.classList.add("mode-active");
      modes[modeId].activate();
      localStorage.setItem(LAST_MODE_KEY, modeId);
    }
    function init() {
      if (homeScreen) {
        homeScreen.querySelectorAll(".home-mode-btn").forEach(function(btn) {
          btn.addEventListener("click", function() {
            switchTo(btn.dataset.mode);
          });
        });
      }
      document.querySelectorAll(".mode-back-btn").forEach(function(btn) {
        btn.addEventListener("click", function() {
          navigateHome();
        });
      });
      document.addEventListener("keydown", function(e) {
        if (e.key !== "Escape" || !currentModeId) return;
        if (document.querySelector(".settings-overlay.open")) return;
        var modeScreen = document.getElementById("mode-" + currentModeId);
        if (modeScreen && !modeScreen.classList.contains("phase-idle")) return;
        navigateHome();
      });
      for (const id of Object.keys(modes)) {
        modes[id].init();
      }
      const lastMode = localStorage.getItem(LAST_MODE_KEY);
      if (lastMode && modes[lastMode]) {
        switchTo(lastMode);
      } else {
        navigateHome();
      }
    }
    return { registerMode, switchTo, navigateHome, init };
  }

  // src/settings.js
  function createSettingsModal(options) {
    var onNotationChange = options.onNotationChange || function() {
    };
    var overlay = document.createElement("div");
    overlay.className = "settings-overlay";
    var modal = document.createElement("div");
    modal.className = "settings-modal";
    modal.innerHTML = '<div class="settings-header"><span class="settings-title">Settings</span><button class="settings-close-btn" aria-label="Close">\xD7</button></div><div class="settings-body"><div class="settings-field"><div class="settings-label">Note names</div><div class="settings-toggle-group"><button class="settings-toggle-btn" data-notation="letter">A B C</button><button class="settings-toggle-btn" data-notation="solfege">Do Re Mi</button></div></div></div>';
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    var closeBtn = modal.querySelector(".settings-close-btn");
    var toggleBtns = modal.querySelectorAll(".settings-toggle-btn");
    function updateToggleState() {
      var current = getUseSolfege() ? "solfege" : "letter";
      toggleBtns.forEach(function(btn) {
        btn.classList.toggle("active", btn.dataset.notation === current);
      });
    }
    function open() {
      updateToggleState();
      overlay.classList.add("open");
    }
    function close() {
      overlay.classList.remove("open");
    }
    closeBtn.addEventListener("click", close);
    overlay.addEventListener("click", function(e) {
      if (e.target === overlay) close();
    });
    document.addEventListener("keydown", function(e) {
      if (e.key === "Escape" && overlay.classList.contains("open")) {
        close();
      }
    });
    toggleBtns.forEach(function(btn) {
      btn.addEventListener("click", function() {
        var wantSolfege = btn.dataset.notation === "solfege";
        if (wantSolfege !== getUseSolfege()) {
          setUseSolfege(wantSolfege);
          updateToggleState();
          onNotationChange();
        }
      });
    });
    return { open, close };
  }

  // src/app.js
  var nav = createNavigation();
  var guitar = createGuitarFretboardMode();
  nav.registerMode("fretboard", {
    name: "Guitar Fretboard",
    init: guitar.init,
    activate: guitar.activate,
    deactivate: guitar.deactivate
  });
  var ukulele = createUkuleleFretboardMode();
  nav.registerMode("ukulele", {
    name: "Ukulele Fretboard",
    init: ukulele.init,
    activate: ukulele.activate,
    deactivate: ukulele.deactivate
  });
  var speedTap = createSpeedTapMode();
  nav.registerMode("speedTap", {
    name: "Speed Tap",
    init: speedTap.init,
    activate: speedTap.activate,
    deactivate: speedTap.deactivate
  });
  var noteSemitones = createNoteSemitonesMode();
  nav.registerMode("noteSemitones", {
    name: "Note \u2194 Semitones",
    init: noteSemitones.init,
    activate: noteSemitones.activate,
    deactivate: noteSemitones.deactivate
  });
  var intervalSemitones = createIntervalSemitonesMode();
  nav.registerMode("intervalSemitones", {
    name: "Interval \u2194 Semitones",
    init: intervalSemitones.init,
    activate: intervalSemitones.activate,
    deactivate: intervalSemitones.deactivate
  });
  var semitoneMath = createSemitoneMathMode();
  nav.registerMode("semitoneMath", {
    name: "Semitone Math",
    init: semitoneMath.init,
    activate: semitoneMath.activate,
    deactivate: semitoneMath.deactivate
  });
  var intervalMath = createIntervalMathMode();
  nav.registerMode("intervalMath", {
    name: "Interval Math",
    init: intervalMath.init,
    activate: intervalMath.activate,
    deactivate: intervalMath.deactivate
  });
  var keySignatures = createKeySignaturesMode();
  nav.registerMode("keySignatures", {
    name: "Key Signatures",
    init: keySignatures.init,
    activate: keySignatures.activate,
    deactivate: keySignatures.deactivate
  });
  var scaleDegrees = createScaleDegreesMode();
  nav.registerMode("scaleDegrees", {
    name: "Scale Degrees",
    init: scaleDegrees.init,
    activate: scaleDegrees.activate,
    deactivate: scaleDegrees.deactivate
  });
  var diatonicChords = createDiatonicChordsMode();
  nav.registerMode("diatonicChords", {
    name: "Diatonic Chords",
    init: diatonicChords.init,
    activate: diatonicChords.activate,
    deactivate: diatonicChords.deactivate
  });
  var chordSpelling = createChordSpellingMode();
  nav.registerMode("chordSpelling", {
    name: "Chord Spelling",
    init: chordSpelling.init,
    activate: chordSpelling.activate,
    deactivate: chordSpelling.deactivate
  });
  nav.init();
  function refreshVisibleStats() {
    document.querySelectorAll(".mode-screen.mode-active").forEach(function(el) {
      var activeToggle = el.querySelector(".stats-toggle-btn.active");
      if (activeToggle) activeToggle.click();
    });
  }
  var settings = createSettingsModal({
    onNotationChange: function() {
      document.querySelectorAll(".mode-screen.mode-active").forEach(function(el) {
        refreshNoteButtonLabels(el);
        refreshVisibleStats();
      });
      guitar.onNotationChange();
      ukulele.onNotationChange();
    }
  });
  var settingsBtn = document.querySelector(".home-settings-btn");
  if (settingsBtn) {
    settingsBtn.addEventListener("click", function() {
      settings.open();
    });
  }
  if ("serviceWorker" in navigator && !window.Capacitor) {
    navigator.serviceWorker.register("sw.js");
  }
})();

  </script>
</body>
</html>