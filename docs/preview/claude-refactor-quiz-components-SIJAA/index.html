<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Music Reps</title>
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">

  <style>
    :root {
  /* Brand (sage) */
  --color-brand: hsl(90, 35%, 45%);
  --color-brand-dark: hsl(90, 35%, 35%);
  --color-brand-bg: hsl(90, 25%, 94%);

  /* Semantic colors */
  --color-success: #4caf50;
  --color-success-dark: #388e3c;
  --color-success-bg: #e8f5e9;
  --color-success-text: #2e7d32;
  --color-error: #f44336;
  --color-error-bg: #ffebee;
  --color-error-text: #c62828;
  --color-focus: #2196f3;
  --color-focus-bg: #e3f2fd;
  --color-recommended: #ff9800;
  --color-highlight: #ffd700;

  /* UI accents */
  --color-toggle-active: hsl(90, 35%, 42%);
  --color-toggle-recommended: hsl(35, 80%, 55%);

  /* Text (warm neutrals) */
  --color-text: hsl(30, 5%, 20%);
  --color-text-muted: hsl(30, 3%, 40%);
  --color-text-light: hsl(30, 3%, 60%);

  /* Surfaces & backgrounds (warm neutrals) */
  --color-bg: #fff;
  --color-surface: hsl(30, 10%, 96%);
  --color-surface-hover: hsl(30, 8%, 93%);
  --color-surface-alt: hsl(30, 8%, 92%);
  --color-surface-pressed: hsl(30, 5%, 82%);
  --color-surface-accent: hsl(30, 8%, 90%);

  /* Borders (warm neutrals) */
  --color-border: hsl(30, 5%, 60%);
  --color-border-light: hsl(30, 5%, 80%);
  --color-border-lighter: hsl(30, 5%, 86%);

  /* Overlay */
  --color-overlay: rgba(0, 0, 0, 0.35);

  /* Heatmap scale (warm → sage, matches fretboard circle palette) */
  --heatmap-none: hsl(30, 4%, 85%);
  --heatmap-1: hsl(12, 48%, 65%);
  --heatmap-2: hsl(30, 48%, 58%);
  --heatmap-3: hsl(50, 40%, 50%);
  --heatmap-4: hsl(72, 38%, 42%);
  --heatmap-5: hsl(90, 45%, 35%);

  /* Typography scale */
  --text-xs: 0.75rem;
  --text-sm: 0.85rem;
  --text-base: 1rem;
  --text-md: 1.125rem;
  --text-lg: 1.3rem;
  --text-xl: 1.5rem;
  --text-2xl: 2rem;

  /* Spacing scale */
  --space-1: 0.125rem;
  --space-2: 0.25rem;
  --space-3: 0.5rem;
  --space-4: 0.75rem;
  --space-5: 1rem;
  --space-6: 1.5rem;
}

* {
  -webkit-tap-highlight-color: transparent;
}
html {
  background: var(--color-surface);
  overscroll-behavior: none;
}
body {
  font-family: system-ui, -apple-system, sans-serif;
  max-width: 650px;
  margin: 0 auto;
  padding: 0 var(--space-5);
  padding-top: env(safe-area-inset-top, 0);
  padding-bottom: env(safe-area-inset-bottom, 0);
  padding-left: max(var(--space-5), env(safe-area-inset-left, 0));
  padding-right: max(var(--space-5), env(safe-area-inset-right, 0));
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  min-height: 100dvh;
  color: var(--color-text);
  background: var(--color-bg);
  border-left: 1px solid var(--color-border-lighter);
  border-right: 1px solid var(--color-border-lighter);
  overscroll-behavior: none;
}

/* --- Home screen --- */
.home-screen {
  display: flex;
  flex-direction: column;
  min-height: 100dvh;
  padding: var(--space-5);
}
.home-screen.hidden {
  display: none;
}
.home-header {
  text-align: center;
  padding: var(--space-6) 0 var(--space-4);
}
.home-title {
  font-size: var(--text-2xl);
  font-weight: 700;
  color: var(--color-text);
  margin: 0;
}
.home-modes {
  flex: 1;
}
.home-group-label {
  font-size: var(--text-xs);
  font-weight: 600;
  text-transform: uppercase;
  color: var(--color-text-muted);
  letter-spacing: 0.05em;
  margin-top: var(--space-5);
  margin-bottom: var(--space-2);
  padding-left: var(--space-2);
}
.home-group-label:first-child {
  margin-top: 0;
}
.home-mode-btn {
  display: flex;
  flex-direction: column;
  width: 100%;
  text-align: left;
  padding: var(--space-4) var(--space-4);
  background: var(--color-bg);
  border: 1px solid var(--color-border-lighter);
  border-radius: 8px;
  margin-bottom: var(--space-2);
  cursor: pointer;
}
.home-mode-btn:hover {
  background: var(--color-surface);
}
.home-mode-btn:active {
  background: var(--color-surface-pressed);
}
.home-mode-name {
  font-size: var(--text-base);
  font-weight: 600;
  color: var(--color-text);
}
.home-mode-desc {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
}
.home-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-4) 0;
  border-top: 1px solid var(--color-border-lighter);
  margin-top: var(--space-4);
}
.home-settings-btn {
  background: none;
  border: 1px solid var(--color-border-light);
  border-radius: 6px;
  padding: var(--space-2) var(--space-4);
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  cursor: pointer;
  margin: 0;
  min-height: 44px;
  display: flex;
  align-items: center;
}
.home-settings-btn:hover {
  background: var(--color-surface-hover);
}
.home-settings-btn:active {
  background: var(--color-surface-pressed);
}
.version {
  font-size: var(--text-xs);
  color: var(--color-text-light);
}

/* --- Mode top bar --- */
.mode-top-bar {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-3) 0;
  margin-bottom: var(--space-3);
}
.mode-back-btn {
  background: none;
  border: none;
  font-size: var(--text-xl);
  cursor: pointer;
  padding: var(--space-2);
  min-width: 44px;
  min-height: 44px;
  color: var(--color-text-muted);
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
}
.mode-back-btn:hover {
  background: var(--color-surface-hover);
}
.mode-back-btn:active {
  background: var(--color-surface-pressed);
}
.mode-title {
  margin: 0;
  font-size: var(--text-lg);
  font-weight: 600;
  flex: 1;
}
/* Hide back button during active quiz and calibration; keep title visible */
.phase-active .mode-back-btn,
.phase-calibration .mode-back-btn,
.phase-round-complete .mode-back-btn {
  display: none;
}
.phase-active .mode-top-bar,
.phase-calibration .mode-top-bar,
.phase-round-complete .mode-top-bar {
  margin-bottom: 0;
}

/* --- Settings modal --- */
.settings-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--color-overlay);
  z-index: 200;
  justify-content: center;
  align-items: center;
}
.settings-overlay.open {
  display: flex;
}
.settings-modal {
  background: var(--color-bg);
  border-radius: 12px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
  width: 280px;
  max-width: 90vw;
  overflow: hidden;
}
.settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-4) var(--space-5);
  border-bottom: 1px solid var(--color-border);
}
.settings-title {
  font-weight: 600;
  font-size: var(--text-base);
}
.settings-close-btn {
  background: none;
  border: none;
  font-size: var(--text-xl);
  cursor: pointer;
  color: var(--color-text);
  padding: 0;
  line-height: 1;
  opacity: 0.6;
}
.settings-close-btn:hover {
  opacity: 1;
}
.settings-close-btn:active {
  opacity: 0.4;
}
.settings-body {
  padding: var(--space-5);
}
.settings-field {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}
.settings-label {
  font-size: var(--text-sm);
  font-weight: 500;
  color: var(--color-text-muted);
}
.settings-toggle-group {
  display: flex;
  gap: 0;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid var(--color-border);
}
.settings-toggle-btn {
  flex: 1;
  padding: var(--space-3) var(--space-4);
  border: none;
  background: var(--color-surface);
  cursor: pointer;
  font-size: var(--text-sm);
  font-weight: 500;
  color: var(--color-text);
  transition: background 0.15s ease, color 0.15s ease;
}
.settings-toggle-btn + .settings-toggle-btn {
  border-left: 1px solid var(--color-border);
}
.settings-toggle-btn.active {
  background: var(--color-brand);
  color: white;
}
.settings-toggle-btn:hover:not(.active) {
  background: var(--color-surface-hover);
}
.settings-toggle-btn:active {
  opacity: 0.8;
}

/* --- Mode screens --- */
.mode-screen {
  display: none;
  padding-top: var(--space-3);
  flex: 1;
}
.mode-screen.mode-active {
  display: block;
}

/* --- Phase-driven visibility --- */
.quiz-session {
  position: relative;
}
.phase-idle .quiz-session {
  display: none;
}

/* Hide tabs and tab content during non-idle phases */
/* .tab-content.active needs explicit override (higher specificity than .tab-content.active display:block) */
.phase-active .mode-tabs,
.phase-active .tab-content,
.phase-active .tab-content.active,
.phase-calibration .mode-tabs,
.phase-calibration .tab-content,
.phase-calibration .tab-content.active,
.phase-round-complete .mode-tabs,
.phase-round-complete .tab-content,
.phase-round-complete .tab-content.active {
  display: none;
}

/* Element-level visibility (replaces inline style="display: none;") */
.mastery-message {
  display: none;
}
.mastery-message.mastery-visible {
  display: block;
}
.round-complete {
  display: none;
}
.phase-round-complete .round-complete {
  display: block;
}
.stats-container.stats-hidden {
  display: none;
}
.fretboard-wrapper.fretboard-hidden {
  display: none;
}

/* --- Mode tabs (Practice / Progress) --- */
.mode-tabs {
  display: flex;
  gap: 0;
  border-bottom: 2px solid var(--color-border-lighter);
  margin-bottom: var(--space-5);
}
.mode-tab {
  flex: 1;
  padding: var(--space-3) var(--space-5);
  border: none;
  border-bottom: 2px solid transparent;
  margin-bottom: -2px;
  background: none;
  font-size: var(--text-base);
  font-weight: 500;
  color: var(--color-text-muted);
  cursor: pointer;
  transition: color 0.15s ease, border-color 0.15s ease;
}
.mode-tab:hover {
  color: var(--color-text);
}
.mode-tab.active {
  color: var(--color-brand-dark);
  border-bottom-color: var(--color-brand);
  font-weight: 600;
}
.tab-content {
  display: none;
}
.tab-content.active {
  display: block;
}

/* --- Practice card --- */
.practice-card {
  margin-bottom: var(--space-4);
  padding: var(--space-4) var(--space-5);
  background: var(--color-surface);
  border-radius: 8px;
}
.practice-zone + .practice-zone {
  margin-top: var(--space-5);
  padding-top: var(--space-5);
  border-top: 1px solid var(--color-border-lighter);
}
.practice-status {
  margin-bottom: var(--space-3);
}
.practice-status:empty,
.practice-status-label:empty + .practice-status-detail:empty {
  display: none;
}
.practice-status-label {
  font-weight: 600;
  font-size: var(--text-base);
  color: var(--color-text);
}
.practice-status-detail {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-left: var(--space-3);
}
.practice-recommendation {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  flex-wrap: wrap;
}
.practice-recommendation:empty,
.practice-rec-text:empty ~ .practice-rec-btn {
  display: none;
}
.practice-rec-text {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
}
.practice-rec-text:empty {
  display: none;
}
.practice-rec-btn {
  font-size: var(--text-xs);
  font-weight: 500;
  padding: var(--space-2) var(--space-4);
  border: 1px solid var(--color-brand);
  border-radius: 6px;
  background: var(--color-brand-bg);
  color: var(--color-brand-dark);
  cursor: pointer;
  margin: 0;
  transition: background 0.15s ease;
}
.practice-rec-btn:hover {
  background: var(--color-brand);
  color: white;
}
.practice-rec-btn.hidden {
  display: none;
}

/* --- Practice scope (inside practice card) --- */
.practice-scope {
  margin-top: var(--space-4);
}
.practice-scope .settings-row {
  margin-bottom: 0;
}

/* --- Practice action zone (inside practice card) --- */
.practice-zone-action {
  text-align: center;
}
.session-summary-text {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-3);
}
.session-summary-text:empty {
  display: none;
}

/* --- Baseline info (Progress tab) --- */
.baseline-info {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  text-align: center;
  padding: var(--space-3) var(--space-4);
  margin-bottom: var(--space-3);
}
.baseline-info:empty {
  display: none;
}
.baseline-default-tag {
  font-style: italic;
  color: var(--color-text-light);
}
.baseline-rerun-btn {
  background: none;
  border: 1px solid var(--color-border-light);
  border-radius: 6px;
  padding: var(--space-2) var(--space-4);
  font-size: var(--text-xs);
  font-weight: 500;
  color: var(--color-text-muted);
  cursor: pointer;
  margin: 0;
  margin-left: var(--space-2);
  transition: background 0.15s ease, border-color 0.15s ease;
}
.baseline-rerun-btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-border);
}
.baseline-rerun-btn:active {
  background: var(--color-surface-pressed);
}

/* --- Progress tab stats controls (within tab) --- */
.tab-content .stats-controls {
  text-align: center;
  margin: var(--space-3) 0;
  padding-bottom: var(--space-2);
}

/* --- Fretboard --- */
.fretboard-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}
.string-toggles {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  justify-content: center;
}
.string-toggle {
  width: 36px;
  height: 36px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background: var(--color-surface);
  color: var(--color-border);
  font-size: var(--text-sm);
  font-weight: 500;
  cursor: pointer;
  padding: 0;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}
.string-toggle:hover {
  background: var(--color-surface-hover);
}
.string-toggle.active {
  background: var(--color-toggle-active);
  color: white;
  border-color: var(--color-toggle-active);
}
.string-toggle.recommended {
  box-shadow: 0 0 0 2px var(--color-toggle-recommended);
}
.string-toggle.active.recommended {
  border-color: var(--color-toggle-recommended);
}
.distance-toggles {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  justify-content: center;
}
.distance-toggle {
  height: 36px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background: var(--color-surface);
  color: var(--color-border);
  font-size: var(--text-xs);
  font-weight: 500;
  cursor: pointer;
  padding: 0 0.4rem;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}
.distance-toggle:hover {
  background: var(--color-surface-hover);
}
.distance-toggle.active {
  background: var(--color-toggle-active);
  color: white;
  border-color: var(--color-toggle-active);
}
.distance-toggle.recommended {
  box-shadow: 0 0 0 2px var(--color-toggle-recommended);
}
.distance-toggle.active.recommended {
  border-color: var(--color-toggle-recommended);
}
.notes-toggles {
  display: flex;
  flex-direction: row;
  gap: var(--space-1);
  justify-content: center;
}
.notes-toggle {
  height: 36px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background: var(--color-surface);
  color: var(--color-border);
  font-size: var(--text-xs);
  font-weight: 500;
  cursor: pointer;
  padding: 0 0.6rem;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}
.notes-toggle:hover {
  background: var(--color-surface-hover);
}
.notes-toggle.active {
  background: var(--color-toggle-active);
  color: white;
  border-color: var(--color-toggle-active);
}
.fretboard-container {
  position: relative;
  width: 100%;
  min-width: 0;
  max-width: 1200px;
}
.fretboard {
  width: 100%;
  height: auto;
  display: block;
  background: var(--color-bg);
  touch-action: manipulation;
}
/* SVG fretboard — new circle-based design */
.fb-string {
  stroke: hsl(30, 8%, 72%);
}
.fb-fret {
  stroke: hsl(30, 5%, 82%);
}
.fb-nut {
  fill: hsl(30, 8%, 48%);
}
.fb-marker {
  fill: hsl(30, 5%, 62%);
}
.fb-pos {
  fill: hsl(30, 5%, 90%);
  stroke: none;
  cursor: pointer;
  transition: fill 0.15s;
}

/* Hover card */
.hover-card {
  position: absolute;
  pointer-events: none;
  z-index: 10;
  opacity: 0;
  transition: opacity 0.12s;
}
.hover-card.visible {
  opacity: 1;
}
.hc-inner {
  background: var(--color-bg);
  border: 1px solid var(--color-border-light);
  border-radius: 8px;
  padding: 0.35rem 0.5rem;
  min-width: 65px;
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.12);
  text-align: center;
}
.hc-note {
  font-size: var(--text-sm);
  font-weight: 700;
  color: var(--color-text);
}
.hc-string-fret {
  font-size: var(--text-xs);
  color: var(--color-text-muted);
  margin-top: 0.05rem;
}
.hc-detail {
  font-size: var(--text-xs);
  color: var(--color-text-muted);
  margin-top: 0.12rem;
}
.hc-bar {
  height: 3px;
  border-radius: 2px;
  background: hsl(30, 5%, 90%);
  margin-top: 0.25rem;
  overflow: hidden;
}
.hc-bar-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.2s;
}

.settings-row {
  display: flex;
  align-items: center;
  gap: var(--space-5);
  justify-content: center;
  margin-bottom: var(--space-3);
}
button {
  padding: var(--space-3) var(--space-6);
  font-size: var(--text-base);
  cursor: pointer;
  margin: 0 var(--space-3);
}
.mastery-message {
  background: var(--color-success-bg);
  color: var(--color-success-text);
  font-weight: bold;
  font-size: var(--text-base);
  padding: var(--space-3) var(--space-5);
  margin-bottom: var(--space-3);
  border-radius: 6px;
  text-align: center;
}

/* --- Primary CTA (Start Quiz) --- */
.start-btn {
  background: var(--color-brand);
  color: white;
  border: 2px solid var(--color-brand);
  border-radius: 8px;
  font-weight: 600;
  font-size: var(--text-md);
  padding: var(--space-4) var(--space-6);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
  transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.1s ease;
}
.start-btn:hover {
  background: var(--color-brand-dark);
  border-color: var(--color-brand-dark);
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.18);
}
.start-btn:active {
  transform: scale(0.98);
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
}

/* --- Quiz countdown row — bar + timer side by side --- */
.quiz-countdown-row {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  margin-bottom: var(--space-2);
}
.quiz-countdown-bar {
  flex: 1;
  height: 4px;
  background: var(--color-surface-alt);
  margin-left: calc(-1 * var(--space-5));
}
.quiz-countdown-fill {
  height: 100%;
  background: var(--color-brand);
  transition: width 0.2s linear;
  width: 100%;
}
.round-timer-warning .quiz-countdown-fill,
.last-question .quiz-countdown-fill {
  background: var(--color-error);
}
.quiz-info-time {
  font-size: var(--text-xs);
  font-variant-numeric: tabular-nums;
  color: var(--color-text-muted);
  white-space: nowrap;
}

/* --- Quiz session info — single compact row --- */
.quiz-session-info {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  padding: 0 var(--space-6) var(--space-2) 0;
}
.quiz-info-context {
  flex: 1;
}
.quiz-info-count {
  font-variant-numeric: tabular-nums;
}
.quiz-header-close {
  position: absolute;
  top: var(--space-3);
  right: 0;
  background: none;
  border: none;
  font-size: var(--text-xl);
  color: var(--color-text-light);
  cursor: pointer;
  padding: 0 var(--space-2);
  line-height: 1;
  margin: 0;
  border-radius: 4px;
  transition: color 0.15s ease, background 0.15s ease;
  z-index: 1;
}
.quiz-header-close:hover {
  color: var(--color-text);
  background: var(--color-surface-hover);
}

/* --- Progress bar --- */
.progress-bar {
  width: 100%;
  max-width: 300px;
  height: 20px;
  background: var(--color-surface-alt);
  border-radius: 10px;
  margin: 0 auto var(--space-4);
  overflow: hidden;
  position: relative;
}
.phase-active .progress-bar,
.phase-round-complete .progress-bar {
  display: none;
}
.progress-fill {
  height: 100%;
  background: var(--color-success);
  border-radius: 10px;
  transition: width 0.3s ease;
  min-width: 0;
}
.progress-text {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--text-xs);
  font-weight: 600;
  color: var(--color-text);
  pointer-events: none;
}

/* --- Quiz-active visual focus --- */
.phase-active,
.phase-round-complete,
.phase-calibration {
  background: var(--color-surface);
  margin: 0 calc(-1 * var(--space-5));
  padding: 0 var(--space-5);
}
.phase-active .quiz-area.active {
  border: 1px solid var(--color-border-lighter);
  padding: var(--space-3) var(--space-3);
}

/* --- Quiz area (subtle card containment) --- */
.quiz-area {
  display: none;
  text-align: center;
  margin: var(--space-5) 0;
  border: 2px solid transparent;
}
.quiz-area.active {
  display: block;
  background: var(--color-surface);
  border-radius: 12px;
  padding: var(--space-5);
}
/* --- Round complete --- */
.round-complete {
  text-align: center;
  padding: var(--space-6) 0;
}
.round-complete-context {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-bottom: var(--space-4);
}
.round-complete-heading {
  font-size: var(--text-xl);
  font-weight: 700;
  color: var(--color-text);
  margin-bottom: var(--space-3);
}
.round-complete-stats {
  margin: var(--space-3) 0 var(--space-5);
}
.round-stat-line {
  font-size: var(--text-base);
  color: var(--color-text);
  line-height: 1.6;
}
.round-complete-actions {
  display: flex;
  gap: var(--space-3);
  justify-content: center;
}
.round-complete-continue {
  padding: var(--space-3) var(--space-5);
  background: var(--color-brand);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: var(--text-base);
  font-weight: 600;
  cursor: pointer;
}
.round-complete-continue:hover {
  opacity: 0.9;
}
.round-complete-continue:active {
  opacity: 0.8;
  transform: scale(0.98);
}
.round-complete-stop {
  padding: var(--space-3) var(--space-5);
  background: none;
  color: var(--color-text-muted);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  font-size: var(--text-base);
  cursor: pointer;
}
.round-complete-stop:hover {
  background: var(--color-surface-hover);
}
.round-complete-stop:active {
  background: var(--color-surface-pressed);
}
/* Hide quiz prompt, answer buttons, and feedback during round-complete */
.phase-round-complete .quiz-prompt-row,
.phase-round-complete .answer-buttons,
.phase-round-complete .note-buttons,
.phase-round-complete .chord-slots,
.phase-round-complete .feedback,
.phase-round-complete .hint,
.phase-round-complete .time-display,
.phase-round-complete .speed-tap-status,
.phase-round-complete .fretboard-wrapper,
.phase-round-complete .quiz-countdown-row,
.phase-round-complete .quiz-session-info,
.phase-round-complete .quiz-header-close {
  display: none;
}

/* --- Note buttons (piano-style layout) --- */
.note-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  margin: var(--space-3) auto;
}
.note-row-naturals,
.note-row-accidentals {
  display: grid;
  grid-template-columns: repeat(14, 1fr);
  column-gap: 2px; /* sub-column separator; --space-1 too wide for 14-col grid */
}
.note-row-accidentals.hidden {
  display: none;
}
/* Natural notes: each spans 2 of 14 sub-columns */
.note-row-naturals .note-btn:nth-child(1) {
  grid-column: 1 / 3;
}
.note-row-naturals .note-btn:nth-child(2) {
  grid-column: 3 / 5;
}
.note-row-naturals .note-btn:nth-child(3) {
  grid-column: 5 / 7;
}
.note-row-naturals .note-btn:nth-child(4) {
  grid-column: 7 / 9;
}
.note-row-naturals .note-btn:nth-child(5) {
  grid-column: 9 / 11;
}
.note-row-naturals .note-btn:nth-child(6) {
  grid-column: 11 / 13;
}
.note-row-naturals .note-btn:nth-child(7) {
  grid-column: 13 / 15;
}
/* Accidentals: piano black-key positioning between naturals */
.note-row-accidentals .note-btn:nth-child(1) {
  grid-column: 2 / 4;
}
.note-row-accidentals .note-btn:nth-child(2) {
  grid-column: 4 / 6;
}
.note-row-accidentals .note-btn:nth-child(3) {
  grid-column: 8 / 10;
}
.note-row-accidentals .note-btn:nth-child(4) {
  grid-column: 10 / 12;
}
.note-row-accidentals .note-btn:nth-child(5) {
  grid-column: 12 / 14;
}
.note-btn {
  min-width: 0;
  height: 48px;
  font-size: var(--text-md);
  font-weight: 500;
  border: 2px solid var(--color-text-muted);
  border-radius: 8px;
  background: var(--color-bg);
  cursor: pointer;
  padding: 0;
  touch-action: manipulation;
  transition:
    background 0.15s ease,
    border-color 0.15s ease,
    transform 0.1s ease;
}
.note-btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-text);
}
.note-btn.accidental {
  background: var(--color-surface-accent);
}
.note-btn.accidental:hover {
  background: var(--color-surface-pressed);
}
.note-btn:active {
  background: var(--color-surface-pressed);
  transform: scale(0.97);
}
.note-btn:disabled {
  opacity: 0.5;
  cursor: default;
}
.note-btn:disabled:hover {
  background: var(--color-bg);
  border-color: var(--color-text-muted);
  transform: none;
}
.note-btn.hidden {
  display: none;
}

/* --- Quiz prompt (text modes) --- */
.quiz-prompt-row {
  display: flex;
  align-items: baseline;
  justify-content: center;
  gap: var(--space-2);
  margin: var(--space-5) 0;
  min-height: 2.5rem;
}
.quiz-prompt {
  font-size: var(--text-2xl);
  font-weight: 600;
}
.quiz-prompt:empty {
  display: none;
}
.quiz-last-question {
  font-size: var(--text-sm);
  color: var(--color-error);
  font-weight: 500;
}
.quiz-last-question:empty {
  display: none;
}

/* --- Answer buttons grid (shared by new modes) --- */
.answer-buttons {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 0.4rem;
  max-width: 360px;
  margin: var(--space-3) auto;
}
.answer-btn {
  height: 48px;
  font-size: var(--text-md);
  font-weight: 500;
  border: 2px solid var(--color-text-muted);
  border-radius: 8px;
  background: var(--color-bg);
  cursor: pointer;
  padding: 0 var(--space-2);
  touch-action: manipulation;
  transition:
    background 0.15s ease,
    border-color 0.15s ease,
    transform 0.1s ease;
}
.answer-btn:hover {
  background: var(--color-surface-hover);
  border-color: var(--color-text);
}
.answer-btn:active {
  background: var(--color-surface-pressed);
  transform: scale(0.97);
}
.answer-btn:disabled {
  opacity: 0.5;
  cursor: default;
}
.answer-btn:disabled:hover {
  background: var(--color-bg);
  border-color: var(--color-text-muted);
  transform: none;
}
.answer-buttons-intervals {
  grid-template-columns: repeat(3, 1fr);
}

/* --- Answer group visibility (toggled by mode JS for bidirectional questions) --- */
.answer-group-hidden {
  display: none;
}

/* --- Calibration overlay: inside quiz-area, hide non-calibration content --- */
.phase-calibration .answer-buttons:not(.calibration-active),
.phase-calibration .note-buttons:not(.calibration-active) {
  display: none;
}
.phase-calibration .answer-buttons.calibration-active {
  display: grid;
}
.phase-calibration .note-buttons.calibration-active {
  display: flex;
}
.phase-calibration .speed-tap-status,
.phase-calibration .fretboard-wrapper {
  display: none;
}
.phase-calibration .chord-slots {
  display: none;
}
/* Calibration: hide quiz info (progress bar shows trial count instead) */
.phase-calibration .quiz-session-info {
  display: none;
}
/* Intro + results: hide buttons and progress */
.phase-calibration.calibration-intro .calibration-active,
.phase-calibration.calibration-results .calibration-active {
  display: none;
}
.phase-calibration.calibration-intro .progress-bar,
.phase-calibration.calibration-results .progress-bar {
  display: none;
}

/* --- Calibration highlight --- */
.calibration-target {
  background: var(--color-success) !important;
  border-color: var(--color-success-dark) !important;
  color: white !important;
  box-shadow: 0 0 12px rgba(76, 175, 80, 0.6);
}
.calibration-progress {
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  margin-top: var(--space-3);
}
.calibration-action-btn {
  display: block;
  margin: var(--space-6) auto 0;
  padding: var(--space-4) 2.5rem;
  font-size: var(--text-md);
  font-weight: 600;
  background: var(--color-brand);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.15s ease;
}
.calibration-action-btn:hover {
  background: var(--color-brand-dark);
}
.calibration-action-btn:active {
  background: var(--color-brand-dark);
}
.calibration-results {
  text-align: center;
  margin: var(--space-5) auto;
  max-width: 420px;
}
.calibration-baseline {
  font-size: var(--text-md);
  font-weight: 600;
  margin: var(--space-3) 0 var(--space-5);
}
.calibration-thresholds {
  border-collapse: collapse;
  margin: 0 auto var(--space-5);
  font-size: var(--text-sm);
  width: 100%;
}
.calibration-thresholds th,
.calibration-thresholds td {
  border: 1px solid var(--color-border-light);
  padding: 0.35rem var(--space-3);
  text-align: left;
}
.calibration-thresholds th {
  background: var(--color-surface);
  font-weight: 600;
}
.calibration-thresholds td:first-child {
  font-weight: 600;
  white-space: nowrap;
}
.calibration-thresholds td:nth-child(2) {
  white-space: nowrap;
  font-variant-numeric: tabular-nums;
}

/* --- Feedback --- */
.feedback {
  font-size: var(--text-xl);
  margin: var(--space-5) 0;
  min-height: 2rem;
}
.correct {
  color: var(--color-success);
}
.incorrect {
  color: var(--color-error);
}
.time-display {
  color: var(--color-text-muted);
  font-size: var(--text-sm);
  margin-top: var(--space-3);
}
.hint {
  color: var(--color-text-muted);
  font-size: var(--text-base);
  margin-top: var(--space-5);
}
.stats {
  margin-top: var(--space-5);
  font-size: var(--text-sm);
  color: var(--color-text-muted);
}

/* --- Heatmap legends --- */
.heatmap-legend {
  display: none;
  justify-content: center;
  gap: var(--space-3);
  flex-wrap: wrap;
  margin: var(--space-4) 0;
}
.heatmap-legend.active {
  display: flex;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 0.2rem;
  font-size: var(--text-xs);
  color: var(--color-text-muted);
}
.legend-swatch {
  width: 12px;
  height: 12px;
  border-radius: 3px;
  border: 1px solid var(--color-border);
}
.setting-group {
  display: flex;
  align-items: center;
  gap: 0.3rem;
  font-size: var(--text-sm);
  color: var(--color-text-muted);
  cursor: pointer;
}
.toggle-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-1);
}
.toggle-group-label {
  font-size: var(--text-xs);
  color: var(--color-text-muted);
  font-weight: 500;
}

/* --- Stats tables (lookup modes) --- */
.stats-container {
  text-align: center;
  margin: var(--space-3) 0;
}
.stats-table {
  border-collapse: collapse;
  margin: var(--space-3) auto;
  font-size: var(--text-sm);
}
.stats-table th, .stats-table td {
  border: 1px solid var(--color-border-light);
  padding: 0.4rem 0.7rem;
  text-align: center;
}
.stats-table th {
  background: var(--color-surface);
  font-weight: 600;
}
.stats-cell {
  width: 40px;
  height: 28px;
  border-radius: 4px;
  padding: 0;
  box-sizing: border-box;
}

/* --- Stats grids (math modes) --- */
.stats-grid-wrapper {
  overflow-x: auto;
  margin: var(--space-3) 0;
}
.stats-grid {
  border-collapse: collapse;
  margin: 0 auto;
  font-size: var(--text-sm);
}
.stats-grid th, .stats-grid td {
  border: 1px solid var(--color-border-light);
  padding: 0.2rem 0.3rem;
  text-align: center;
}
.stats-grid th {
  background: var(--color-surface);
  font-weight: 600;
  font-size: var(--text-xs);
}
.stats-grid .stats-cell {
  width: 30px;
  height: 24px;
}
.stats-grid-row-label {
  font-weight: 600;
  background: var(--color-surface);
  padding: 0.2rem 0.4rem;
}

/* --- Speed Tap mode --- */
.speed-tap-status {
  display: flex;
  justify-content: center;
  gap: var(--space-6);
  font-size: var(--text-lg);
  margin: var(--space-3) 0;
}
.speed-tap-progress {
  font-weight: 500;
}
.speed-tap-stats {
  font-size: var(--text-xs);
}
.speed-tap-stats th, .speed-tap-stats td {
  padding: 0.2rem 0.3rem;
}
.speed-tap-stats .stats-cell {
  width: 24px;
  height: 20px;
}

/* --- Stats controls (toggle above chart) --- */
.stats-controls {
  text-align: center;
  margin: var(--space-3) 0;
  padding-bottom: var(--space-2);
}

/* --- Stats mode toggle (Recall / Speed) --- */
.stats-toggle {
  display: inline-flex;
  border: 2px solid var(--color-border);
  border-radius: 6px;
  overflow: hidden;
}
.stats-toggle-btn {
  padding: 0.35rem var(--space-5);
  font-size: var(--text-sm);
  font-weight: 500;
  border: none;
  border-radius: 0;
  background: var(--color-bg);
  color: var(--color-text-muted);
  cursor: pointer;
  margin: 0;
  transition: background 0.15s ease, color 0.15s ease;
}
.stats-toggle-btn + .stats-toggle-btn {
  border-left: 1px solid var(--color-border-light);
}
.stats-toggle-btn.active {
  background: var(--color-brand);
  color: white;
}
.stats-toggle-btn:not(.active):hover {
  background: var(--color-surface-hover);
}

/* --- Key signature answer buttons --- */
.answer-buttons-keysig {
  grid-template-columns: repeat(4, 1fr);
}

/* --- Degree answer buttons --- */
.answer-buttons-degrees {
  grid-template-columns: repeat(4, 1fr);
}

/* --- Roman numeral answer buttons --- */
.answer-buttons-numerals {
  grid-template-columns: repeat(4, 1fr);
}

/* --- Chord spelling slots --- */
.chord-slots {
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  margin: var(--space-4) 0;
  min-height: 2.5rem;
}
.chord-slot {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 3rem;
  height: 2.5rem;
  border: 2px solid var(--color-border);
  border-radius: 6px;
  font-size: var(--text-md);
  font-weight: 600;
  background: var(--color-surface);
  transition: border-color 0.15s ease, background 0.15s ease;
}
.chord-slot.active {
  border-color: var(--color-focus);
  background: var(--color-focus-bg);
}
.chord-slot.correct {
  border-color: var(--color-success);
  background: var(--color-success-bg);
  color: var(--color-success-text);
}
.chord-slot.wrong {
  border-color: var(--color-error);
  background: var(--color-error-bg);
  color: var(--color-error-text);
}

/* --- Focus-visible (keyboard navigation) --- */
:focus-visible {
  outline: 2px solid var(--color-brand);
  outline-offset: 2px;
}
/* Remove default outline for mouse/touch users */
:focus:not(:focus-visible) {
  outline: none;
}
/* Specific overrides for elements that need different focus styling */
.start-btn:focus-visible {
  outline-color: var(--color-brand-dark);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12), 0 0 0 4px rgba(209, 147, 27, 0.3);
}
.home-mode-btn:focus-visible {
  outline-offset: -2px;
}

/* --- Reduced motion --- */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Mobile layout */
@media (max-width: 599px) {
  body {
    margin: 0;
    padding: 0 var(--space-1);
    padding-top: env(safe-area-inset-top, 0);
    padding-bottom: env(safe-area-inset-bottom, 0);
    padding-left: max(var(--space-1), env(safe-area-inset-left, 0));
    padding-right: max(var(--space-1), env(safe-area-inset-right, 0));
    border-left: none;
    border-right: none;
  }

  .quiz-countdown-bar {
    margin-left: calc(-1 * var(--space-1));
  }

  .phase-active,
  .phase-round-complete,
  .phase-calibration {
    margin: 0 calc(-1 * var(--space-1));
    padding: 0 var(--space-1);
  }

  .fretboard-container {
    width: 100%;
    max-width: none;
  }

  .answer-buttons {
    grid-template-columns: repeat(3, 1fr);
    max-width: 280px;
  }

  .quiz-prompt {
    font-size: 1.6rem;
  }

  /* Prevent iOS zoom on input focus */
  input, button {
    font-size: 16px;
  }
}

  </style>
</head>
<body>
  <div id="app"></div>

  <script>
(() => {
  // node_modules/preact/dist/preact.module.js
  var n;
  var l;
  var u;
  var t;
  var i;
  var r;
  var o;
  var e;
  var f;
  var c;
  var s;
  var a;
  var h;
  var p = {};
  var v = [];
  var y = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  var d = Array.isArray;
  function w(n2, l3) {
    for (var u4 in l3) n2[u4] = l3[u4];
    return n2;
  }
  function g(n2) {
    n2 && n2.parentNode && n2.parentNode.removeChild(n2);
  }
  function _(l3, u4, t3) {
    var i3, r3, o3, e3 = {};
    for (o3 in u4) "key" == o3 ? i3 = u4[o3] : "ref" == o3 ? r3 = u4[o3] : e3[o3] = u4[o3];
    if (arguments.length > 2 && (e3.children = arguments.length > 3 ? n.call(arguments, 2) : t3), "function" == typeof l3 && null != l3.defaultProps) for (o3 in l3.defaultProps) void 0 === e3[o3] && (e3[o3] = l3.defaultProps[o3]);
    return m(l3, e3, i3, r3, null);
  }
  function m(n2, t3, i3, r3, o3) {
    var e3 = { type: n2, props: t3, key: i3, ref: r3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o3 ? ++u : o3, __i: -1, __u: 0 };
    return null == o3 && null != l.vnode && l.vnode(e3), e3;
  }
  function k(n2) {
    return n2.children;
  }
  function x(n2, l3) {
    this.props = n2, this.context = l3;
  }
  function S(n2, l3) {
    if (null == l3) return n2.__ ? S(n2.__, n2.__i + 1) : null;
    for (var u4; l3 < n2.__k.length; l3++) if (null != (u4 = n2.__k[l3]) && null != u4.__e) return u4.__e;
    return "function" == typeof n2.type ? S(n2) : null;
  }
  function C(n2) {
    if (n2.__P && n2.__d) {
      var u4 = n2.__v, t3 = u4.__e, i3 = [], r3 = [], o3 = w({}, u4);
      o3.__v = u4.__v + 1, l.vnode && l.vnode(o3), z(n2.__P, o3, u4, n2.__n, n2.__P.namespaceURI, 32 & u4.__u ? [t3] : null, i3, null == t3 ? S(u4) : t3, !!(32 & u4.__u), r3), o3.__v = u4.__v, o3.__.__k[o3.__i] = o3, V(i3, o3, r3), u4.__e = u4.__ = null, o3.__e != t3 && M(o3);
    }
  }
  function M(n2) {
    if (null != (n2 = n2.__) && null != n2.__c) return n2.__e = n2.__c.base = null, n2.__k.some(function(l3) {
      if (null != l3 && null != l3.__e) return n2.__e = n2.__c.base = l3.__e;
    }), M(n2);
  }
  function $(n2) {
    (!n2.__d && (n2.__d = true) && i.push(n2) && !I.__r++ || r != l.debounceRendering) && ((r = l.debounceRendering) || o)(I);
  }
  function I() {
    for (var n2, l3 = 1; i.length; ) i.length > l3 && i.sort(e), n2 = i.shift(), l3 = i.length, C(n2);
    I.__r = 0;
  }
  function P(n2, l3, u4, t3, i3, r3, o3, e3, f4, c3, s3) {
    var a3, h3, y3, d3, w3, g2, _2, m3 = t3 && t3.__k || v, b = l3.length;
    for (f4 = A(u4, l3, m3, f4, b), a3 = 0; a3 < b; a3++) null != (y3 = u4.__k[a3]) && (h3 = -1 != y3.__i && m3[y3.__i] || p, y3.__i = a3, g2 = z(n2, y3, h3, i3, r3, o3, e3, f4, c3, s3), d3 = y3.__e, y3.ref && h3.ref != y3.ref && (h3.ref && D(h3.ref, null, y3), s3.push(y3.ref, y3.__c || d3, y3)), null == w3 && null != d3 && (w3 = d3), (_2 = !!(4 & y3.__u)) || h3.__k === y3.__k ? f4 = H(y3, f4, n2, _2) : "function" == typeof y3.type && void 0 !== g2 ? f4 = g2 : d3 && (f4 = d3.nextSibling), y3.__u &= -7);
    return u4.__e = w3, f4;
  }
  function A(n2, l3, u4, t3, i3) {
    var r3, o3, e3, f4, c3, s3 = u4.length, a3 = s3, h3 = 0;
    for (n2.__k = new Array(i3), r3 = 0; r3 < i3; r3++) null != (o3 = l3[r3]) && "boolean" != typeof o3 && "function" != typeof o3 ? ("string" == typeof o3 || "number" == typeof o3 || "bigint" == typeof o3 || o3.constructor == String ? o3 = n2.__k[r3] = m(null, o3, null, null, null) : d(o3) ? o3 = n2.__k[r3] = m(k, { children: o3 }, null, null, null) : void 0 === o3.constructor && o3.__b > 0 ? o3 = n2.__k[r3] = m(o3.type, o3.props, o3.key, o3.ref ? o3.ref : null, o3.__v) : n2.__k[r3] = o3, f4 = r3 + h3, o3.__ = n2, o3.__b = n2.__b + 1, e3 = null, -1 != (c3 = o3.__i = T(o3, u4, f4, a3)) && (a3--, (e3 = u4[c3]) && (e3.__u |= 2)), null == e3 || null == e3.__v ? (-1 == c3 && (i3 > s3 ? h3-- : i3 < s3 && h3++), "function" != typeof o3.type && (o3.__u |= 4)) : c3 != f4 && (c3 == f4 - 1 ? h3-- : c3 == f4 + 1 ? h3++ : (c3 > f4 ? h3-- : h3++, o3.__u |= 4))) : n2.__k[r3] = null;
    if (a3) for (r3 = 0; r3 < s3; r3++) null != (e3 = u4[r3]) && 0 == (2 & e3.__u) && (e3.__e == t3 && (t3 = S(e3)), E(e3, e3));
    return t3;
  }
  function H(n2, l3, u4, t3) {
    var i3, r3;
    if ("function" == typeof n2.type) {
      for (i3 = n2.__k, r3 = 0; i3 && r3 < i3.length; r3++) i3[r3] && (i3[r3].__ = n2, l3 = H(i3[r3], l3, u4, t3));
      return l3;
    }
    n2.__e != l3 && (t3 && (l3 && n2.type && !l3.parentNode && (l3 = S(n2)), u4.insertBefore(n2.__e, l3 || null)), l3 = n2.__e);
    do {
      l3 = l3 && l3.nextSibling;
    } while (null != l3 && 8 == l3.nodeType);
    return l3;
  }
  function T(n2, l3, u4, t3) {
    var i3, r3, o3, e3 = n2.key, f4 = n2.type, c3 = l3[u4], s3 = null != c3 && 0 == (2 & c3.__u);
    if (null === c3 && null == e3 || s3 && e3 == c3.key && f4 == c3.type) return u4;
    if (t3 > (s3 ? 1 : 0)) {
      for (i3 = u4 - 1, r3 = u4 + 1; i3 >= 0 || r3 < l3.length; ) if (null != (c3 = l3[o3 = i3 >= 0 ? i3-- : r3++]) && 0 == (2 & c3.__u) && e3 == c3.key && f4 == c3.type) return o3;
    }
    return -1;
  }
  function j(n2, l3, u4) {
    "-" == l3[0] ? n2.setProperty(l3, null == u4 ? "" : u4) : n2[l3] = null == u4 ? "" : "number" != typeof u4 || y.test(l3) ? u4 : u4 + "px";
  }
  function F(n2, l3, u4, t3, i3) {
    var r3, o3;
    n: if ("style" == l3) if ("string" == typeof u4) n2.style.cssText = u4;
    else {
      if ("string" == typeof t3 && (n2.style.cssText = t3 = ""), t3) for (l3 in t3) u4 && l3 in u4 || j(n2.style, l3, "");
      if (u4) for (l3 in u4) t3 && u4[l3] == t3[l3] || j(n2.style, l3, u4[l3]);
    }
    else if ("o" == l3[0] && "n" == l3[1]) r3 = l3 != (l3 = l3.replace(f, "$1")), o3 = l3.toLowerCase(), l3 = o3 in n2 || "onFocusOut" == l3 || "onFocusIn" == l3 ? o3.slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u4, u4 ? t3 ? u4.u = t3.u : (u4.u = c, n2.addEventListener(l3, r3 ? a : s, r3)) : n2.removeEventListener(l3, r3 ? a : s, r3);
    else {
      if ("http://www.w3.org/2000/svg" == i3) l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" != l3 && "height" != l3 && "href" != l3 && "list" != l3 && "form" != l3 && "tabIndex" != l3 && "download" != l3 && "rowSpan" != l3 && "colSpan" != l3 && "role" != l3 && "popover" != l3 && l3 in n2) try {
        n2[l3] = null == u4 ? "" : u4;
        break n;
      } catch (n3) {
      }
      "function" == typeof u4 || (null == u4 || false === u4 && "-" != l3[4] ? n2.removeAttribute(l3) : n2.setAttribute(l3, "popover" == l3 && 1 == u4 ? "" : u4));
    }
  }
  function O(n2) {
    return function(u4) {
      if (this.l) {
        var t3 = this.l[u4.type + n2];
        if (null == u4.t) u4.t = c++;
        else if (u4.t < t3.u) return;
        return t3(l.event ? l.event(u4) : u4);
      }
    };
  }
  function z(n2, u4, t3, i3, r3, o3, e3, f4, c3, s3) {
    var a3, h3, p3, y3, _2, m3, b, S2, C3, M2, $2, I2, A3, H2, L, T3 = u4.type;
    if (void 0 !== u4.constructor) return null;
    128 & t3.__u && (c3 = !!(32 & t3.__u), o3 = [f4 = u4.__e = t3.__e]), (a3 = l.__b) && a3(u4);
    n: if ("function" == typeof T3) try {
      if (S2 = u4.props, C3 = "prototype" in T3 && T3.prototype.render, M2 = (a3 = T3.contextType) && i3[a3.__c], $2 = a3 ? M2 ? M2.props.value : a3.__ : i3, t3.__c ? b = (h3 = u4.__c = t3.__c).__ = h3.__E : (C3 ? u4.__c = h3 = new T3(S2, $2) : (u4.__c = h3 = new x(S2, $2), h3.constructor = T3, h3.render = G), M2 && M2.sub(h3), h3.state || (h3.state = {}), h3.__n = i3, p3 = h3.__d = true, h3.__h = [], h3._sb = []), C3 && null == h3.__s && (h3.__s = h3.state), C3 && null != T3.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = w({}, h3.__s)), w(h3.__s, T3.getDerivedStateFromProps(S2, h3.__s))), y3 = h3.props, _2 = h3.state, h3.__v = u4, p3) C3 && null == T3.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), C3 && null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
      else {
        if (C3 && null == T3.getDerivedStateFromProps && S2 !== y3 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(S2, $2), u4.__v == t3.__v || !h3.__e && null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(S2, h3.__s, $2)) {
          u4.__v != t3.__v && (h3.props = S2, h3.state = h3.__s, h3.__d = false), u4.__e = t3.__e, u4.__k = t3.__k, u4.__k.some(function(n3) {
            n3 && (n3.__ = u4);
          }), v.push.apply(h3.__h, h3._sb), h3._sb = [], h3.__h.length && e3.push(h3);
          break n;
        }
        null != h3.componentWillUpdate && h3.componentWillUpdate(S2, h3.__s, $2), C3 && null != h3.componentDidUpdate && h3.__h.push(function() {
          h3.componentDidUpdate(y3, _2, m3);
        });
      }
      if (h3.context = $2, h3.props = S2, h3.__P = n2, h3.__e = false, I2 = l.__r, A3 = 0, C3) h3.state = h3.__s, h3.__d = false, I2 && I2(u4), a3 = h3.render(h3.props, h3.state, h3.context), v.push.apply(h3.__h, h3._sb), h3._sb = [];
      else do {
        h3.__d = false, I2 && I2(u4), a3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
      } while (h3.__d && ++A3 < 25);
      h3.state = h3.__s, null != h3.getChildContext && (i3 = w(w({}, i3), h3.getChildContext())), C3 && !p3 && null != h3.getSnapshotBeforeUpdate && (m3 = h3.getSnapshotBeforeUpdate(y3, _2)), H2 = null != a3 && a3.type === k && null == a3.key ? q(a3.props.children) : a3, f4 = P(n2, d(H2) ? H2 : [H2], u4, t3, i3, r3, o3, e3, f4, c3, s3), h3.base = u4.__e, u4.__u &= -161, h3.__h.length && e3.push(h3), b && (h3.__E = h3.__ = null);
    } catch (n3) {
      if (u4.__v = null, c3 || null != o3) if (n3.then) {
        for (u4.__u |= c3 ? 160 : 128; f4 && 8 == f4.nodeType && f4.nextSibling; ) f4 = f4.nextSibling;
        o3[o3.indexOf(f4)] = null, u4.__e = f4;
      } else {
        for (L = o3.length; L--; ) g(o3[L]);
        N(u4);
      }
      else u4.__e = t3.__e, u4.__k = t3.__k, n3.then || N(u4);
      l.__e(n3, u4, t3);
    }
    else null == o3 && u4.__v == t3.__v ? (u4.__k = t3.__k, u4.__e = t3.__e) : f4 = u4.__e = B(t3.__e, u4, t3, i3, r3, o3, e3, c3, s3);
    return (a3 = l.diffed) && a3(u4), 128 & u4.__u ? void 0 : f4;
  }
  function N(n2) {
    n2 && (n2.__c && (n2.__c.__e = true), n2.__k && n2.__k.some(N));
  }
  function V(n2, u4, t3) {
    for (var i3 = 0; i3 < t3.length; i3++) D(t3[i3], t3[++i3], t3[++i3]);
    l.__c && l.__c(u4, n2), n2.some(function(u5) {
      try {
        n2 = u5.__h, u5.__h = [], n2.some(function(n3) {
          n3.call(u5);
        });
      } catch (n3) {
        l.__e(n3, u5.__v);
      }
    });
  }
  function q(n2) {
    return "object" != typeof n2 || null == n2 || n2.__b > 0 ? n2 : d(n2) ? n2.map(q) : w({}, n2);
  }
  function B(u4, t3, i3, r3, o3, e3, f4, c3, s3) {
    var a3, h3, v3, y3, w3, _2, m3, b = i3.props || p, k3 = t3.props, x2 = t3.type;
    if ("svg" == x2 ? o3 = "http://www.w3.org/2000/svg" : "math" == x2 ? o3 = "http://www.w3.org/1998/Math/MathML" : o3 || (o3 = "http://www.w3.org/1999/xhtml"), null != e3) {
      for (a3 = 0; a3 < e3.length; a3++) if ((w3 = e3[a3]) && "setAttribute" in w3 == !!x2 && (x2 ? w3.localName == x2 : 3 == w3.nodeType)) {
        u4 = w3, e3[a3] = null;
        break;
      }
    }
    if (null == u4) {
      if (null == x2) return document.createTextNode(k3);
      u4 = document.createElementNS(o3, x2, k3.is && k3), c3 && (l.__m && l.__m(t3, e3), c3 = false), e3 = null;
    }
    if (null == x2) b === k3 || c3 && u4.data == k3 || (u4.data = k3);
    else {
      if (e3 = e3 && n.call(u4.childNodes), !c3 && null != e3) for (b = {}, a3 = 0; a3 < u4.attributes.length; a3++) b[(w3 = u4.attributes[a3]).name] = w3.value;
      for (a3 in b) w3 = b[a3], "dangerouslySetInnerHTML" == a3 ? v3 = w3 : "children" == a3 || a3 in k3 || "value" == a3 && "defaultValue" in k3 || "checked" == a3 && "defaultChecked" in k3 || F(u4, a3, null, w3, o3);
      for (a3 in k3) w3 = k3[a3], "children" == a3 ? y3 = w3 : "dangerouslySetInnerHTML" == a3 ? h3 = w3 : "value" == a3 ? _2 = w3 : "checked" == a3 ? m3 = w3 : c3 && "function" != typeof w3 || b[a3] === w3 || F(u4, a3, w3, b[a3], o3);
      if (h3) c3 || v3 && (h3.__html == v3.__html || h3.__html == u4.innerHTML) || (u4.innerHTML = h3.__html), t3.__k = [];
      else if (v3 && (u4.innerHTML = ""), P("template" == t3.type ? u4.content : u4, d(y3) ? y3 : [y3], t3, i3, r3, "foreignObject" == x2 ? "http://www.w3.org/1999/xhtml" : o3, e3, f4, e3 ? e3[0] : i3.__k && S(i3, 0), c3, s3), null != e3) for (a3 = e3.length; a3--; ) g(e3[a3]);
      c3 || (a3 = "value", "progress" == x2 && null == _2 ? u4.removeAttribute("value") : null != _2 && (_2 !== u4[a3] || "progress" == x2 && !_2 || "option" == x2 && _2 != b[a3]) && F(u4, a3, _2, b[a3], o3), a3 = "checked", null != m3 && m3 != u4[a3] && F(u4, a3, m3, b[a3], o3));
    }
    return u4;
  }
  function D(n2, u4, t3) {
    try {
      if ("function" == typeof n2) {
        var i3 = "function" == typeof n2.__u;
        i3 && n2.__u(), i3 && null == u4 || (n2.__u = n2(u4));
      } else n2.current = u4;
    } catch (n3) {
      l.__e(n3, t3);
    }
  }
  function E(n2, u4, t3) {
    var i3, r3;
    if (l.unmount && l.unmount(n2), (i3 = n2.ref) && (i3.current && i3.current != n2.__e || D(i3, null, u4)), null != (i3 = n2.__c)) {
      if (i3.componentWillUnmount) try {
        i3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u4);
      }
      i3.base = i3.__P = null;
    }
    if (i3 = n2.__k) for (r3 = 0; r3 < i3.length; r3++) i3[r3] && E(i3[r3], u4, t3 || "function" != typeof n2.type);
    t3 || g(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
  }
  function G(n2, l3, u4) {
    return this.constructor(n2, u4);
  }
  function J(u4, t3, i3) {
    var r3, o3, e3, f4;
    t3 == document && (t3 = document.documentElement), l.__ && l.__(u4, t3), o3 = (r3 = "function" == typeof i3) ? null : i3 && i3.__k || t3.__k, e3 = [], f4 = [], z(t3, u4 = (!r3 && i3 || t3).__k = _(k, null, [u4]), o3 || p, p, t3.namespaceURI, !r3 && i3 ? [i3] : o3 ? null : t3.firstChild ? n.call(t3.childNodes) : null, e3, !r3 && i3 ? i3 : o3 ? o3.__e : t3.firstChild, r3, f4), V(e3, u4, f4);
  }
  n = v.slice, l = { __e: function(n2, l3, u4, t3) {
    for (var i3, r3, o3; l3 = l3.__; ) if ((i3 = l3.__c) && !i3.__) try {
      if ((r3 = i3.constructor) && null != r3.getDerivedStateFromError && (i3.setState(r3.getDerivedStateFromError(n2)), o3 = i3.__d), null != i3.componentDidCatch && (i3.componentDidCatch(n2, t3 || {}), o3 = i3.__d), o3) return i3.__E = i3;
    } catch (l4) {
      n2 = l4;
    }
    throw n2;
  } }, u = 0, t = function(n2) {
    return null != n2 && void 0 === n2.constructor;
  }, x.prototype.setState = function(n2, l3) {
    var u4;
    u4 = null != this.__s && this.__s != this.state ? this.__s : this.__s = w({}, this.state), "function" == typeof n2 && (n2 = n2(w({}, u4), this.props)), n2 && w(u4, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), $(this));
  }, x.prototype.forceUpdate = function(n2) {
    this.__v && (this.__e = true, n2 && this.__h.push(n2), $(this));
  }, x.prototype.render = k, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n2, l3) {
    return n2.__v.__b - l3.__v.__b;
  }, I.__r = 0, f = /(PointerCapture)$|Capture$/i, c = 0, s = O(false), a = O(true), h = 0;

  // node_modules/preact/hooks/dist/hooks.module.js
  var t2;
  var r2;
  var u2;
  var i2;
  var o2 = 0;
  var f2 = [];
  var c2 = l;
  var e2 = c2.__b;
  var a2 = c2.__r;
  var v2 = c2.diffed;
  var l2 = c2.__c;
  var m2 = c2.unmount;
  var s2 = c2.__;
  function p2(n2, t3) {
    c2.__h && c2.__h(r2, n2, o2 || t3), o2 = 0;
    var u4 = r2.__H || (r2.__H = { __: [], __h: [] });
    return n2 >= u4.__.length && u4.__.push({}), u4.__[n2];
  }
  function d2(n2) {
    return o2 = 1, h2(D2, n2);
  }
  function h2(n2, u4, i3) {
    var o3 = p2(t2++, 2);
    if (o3.t = n2, !o3.__c && (o3.__ = [i3 ? i3(u4) : D2(void 0, u4), function(n3) {
      var t3 = o3.__N ? o3.__N[0] : o3.__[0], r3 = o3.t(t3, n3);
      t3 !== r3 && (o3.__N = [r3, o3.__[1]], o3.__c.setState({}));
    }], o3.__c = r2, !r2.__f)) {
      var f4 = function(n3, t3, r3) {
        if (!o3.__c.__H) return true;
        var u5 = o3.__c.__H.__.filter(function(n4) {
          return n4.__c;
        });
        if (u5.every(function(n4) {
          return !n4.__N;
        })) return !c3 || c3.call(this, n3, t3, r3);
        var i4 = o3.__c.props !== n3;
        return u5.some(function(n4) {
          if (n4.__N) {
            var t4 = n4.__[0];
            n4.__ = n4.__N, n4.__N = void 0, t4 !== n4.__[0] && (i4 = true);
          }
        }), c3 && c3.call(this, n3, t3, r3) || i4;
      };
      r2.__f = true;
      var c3 = r2.shouldComponentUpdate, e3 = r2.componentWillUpdate;
      r2.componentWillUpdate = function(n3, t3, r3) {
        if (this.__e) {
          var u5 = c3;
          c3 = void 0, f4(n3, t3, r3), c3 = u5;
        }
        e3 && e3.call(this, n3, t3, r3);
      }, r2.shouldComponentUpdate = f4;
    }
    return o3.__N || o3.__;
  }
  function y2(n2, u4) {
    var i3 = p2(t2++, 3);
    !c2.__s && C2(i3.__H, u4) && (i3.__ = n2, i3.u = u4, r2.__H.__h.push(i3));
  }
  function A2(n2) {
    return o2 = 5, T2(function() {
      return { current: n2 };
    }, []);
  }
  function T2(n2, r3) {
    var u4 = p2(t2++, 7);
    return C2(u4.__H, r3) && (u4.__ = n2(), u4.__H = r3, u4.__h = n2), u4.__;
  }
  function q2(n2, t3) {
    return o2 = 8, T2(function() {
      return n2;
    }, t3);
  }
  function j2() {
    for (var n2; n2 = f2.shift(); ) {
      var t3 = n2.__H;
      if (n2.__P && t3) try {
        t3.__h.some(z2), t3.__h.some(B2), t3.__h = [];
      } catch (r3) {
        t3.__h = [], c2.__e(r3, n2.__v);
      }
    }
  }
  c2.__b = function(n2) {
    r2 = null, e2 && e2(n2);
  }, c2.__ = function(n2, t3) {
    n2 && t3.__k && t3.__k.__m && (n2.__m = t3.__k.__m), s2 && s2(n2, t3);
  }, c2.__r = function(n2) {
    a2 && a2(n2), t2 = 0;
    var i3 = (r2 = n2.__c).__H;
    i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.some(function(n3) {
      n3.__N && (n3.__ = n3.__N), n3.u = n3.__N = void 0;
    })) : (i3.__h.some(z2), i3.__h.some(B2), i3.__h = [], t2 = 0)), u2 = r2;
  }, c2.diffed = function(n2) {
    v2 && v2(n2);
    var t3 = n2.__c;
    t3 && t3.__H && (t3.__H.__h.length && (1 !== f2.push(t3) && i2 === c2.requestAnimationFrame || ((i2 = c2.requestAnimationFrame) || w2)(j2)), t3.__H.__.some(function(n3) {
      n3.u && (n3.__H = n3.u), n3.u = void 0;
    })), u2 = r2 = null;
  }, c2.__c = function(n2, t3) {
    t3.some(function(n3) {
      try {
        n3.__h.some(z2), n3.__h = n3.__h.filter(function(n4) {
          return !n4.__ || B2(n4);
        });
      } catch (r3) {
        t3.some(function(n4) {
          n4.__h && (n4.__h = []);
        }), t3 = [], c2.__e(r3, n3.__v);
      }
    }), l2 && l2(n2, t3);
  }, c2.unmount = function(n2) {
    m2 && m2(n2);
    var t3, r3 = n2.__c;
    r3 && r3.__H && (r3.__H.__.some(function(n3) {
      try {
        z2(n3);
      } catch (n4) {
        t3 = n4;
      }
    }), r3.__H = void 0, t3 && c2.__e(t3, r3.__v));
  };
  var k2 = "function" == typeof requestAnimationFrame;
  function w2(n2) {
    var t3, r3 = function() {
      clearTimeout(u4), k2 && cancelAnimationFrame(t3), setTimeout(n2);
    }, u4 = setTimeout(r3, 35);
    k2 && (t3 = requestAnimationFrame(r3));
  }
  function z2(n2) {
    var t3 = r2, u4 = n2.__c;
    "function" == typeof u4 && (n2.__c = void 0, u4()), r2 = t3;
  }
  function B2(n2) {
    var t3 = r2;
    n2.__c = n2.__(), r2 = t3;
  }
  function C2(n2, t3) {
    return !n2 || n2.length !== t3.length || t3.some(function(t4, r3) {
      return t4 !== n2[r3];
    });
  }
  function D2(n2, t3) {
    return "function" == typeof t3 ? t3(n2) : t3;
  }

  // src/quiz-engine-state.ts
  function initialEngineState() {
    return {
      phase: "idle",
      // 'idle' | 'active' | 'round-complete' | 'calibration-intro' | 'calibrating' | 'calibration-results'
      currentItemId: null,
      answered: false,
      questionStartTime: null,
      // Session tracking
      questionCount: 0,
      quizStartTime: null,
      // Round tracking
      roundNumber: 0,
      roundAnswered: 0,
      roundCorrect: 0,
      roundTimerExpired: false,
      roundResponseTimes: [],
      roundDurationMs: 0,
      // Progress tracking
      masteredCount: 0,
      totalEnabledCount: 0,
      // Feedback
      feedbackText: "",
      feedbackClass: "feedback",
      timeDisplayText: "",
      hintText: "",
      // Mastery message
      masteryText: "",
      showMastery: false,
      // Calibration
      calibrationBaseline: null,
      // UI visibility
      quizActive: false,
      answersEnabled: false
    };
  }
  function engineStart(state) {
    return {
      ...state,
      phase: "active",
      questionCount: 0,
      quizStartTime: Date.now(),
      quizActive: true,
      showMastery: false,
      roundNumber: 1,
      roundAnswered: 0,
      roundCorrect: 0,
      roundTimerExpired: false,
      roundResponseTimes: []
    };
  }
  function engineNextQuestion(state, nextItemId, nowMs) {
    return {
      ...state,
      currentItemId: nextItemId,
      answered: false,
      questionStartTime: nowMs,
      questionCount: state.questionCount + 1,
      feedbackText: "",
      feedbackClass: "feedback",
      timeDisplayText: "",
      hintText: "",
      answersEnabled: true
    };
  }
  function engineSubmitAnswer(state, isCorrect, correctAnswer) {
    return {
      ...state,
      answered: true,
      answersEnabled: false,
      feedbackText: isCorrect ? "Correct!" : "Incorrect \u2014 " + correctAnswer,
      feedbackClass: isCorrect ? "feedback correct" : "feedback incorrect",
      timeDisplayText: "",
      hintText: "Tap anywhere or press Space for next",
      roundAnswered: state.roundAnswered + 1,
      roundCorrect: state.roundCorrect + (isCorrect ? 1 : 0)
    };
  }
  function engineRoundTimerExpired(state) {
    return {
      ...state,
      roundTimerExpired: true
    };
  }
  function engineRoundComplete(state) {
    return {
      ...state,
      phase: "round-complete",
      answered: false,
      answersEnabled: false,
      currentItemId: null,
      feedbackText: "",
      feedbackClass: "feedback",
      hintText: ""
    };
  }
  function engineContinueRound(state) {
    return {
      ...state,
      phase: "active",
      roundNumber: state.roundNumber + 1,
      roundAnswered: 0,
      roundCorrect: 0,
      roundTimerExpired: false,
      roundResponseTimes: []
    };
  }
  function engineUpdateIdleMessage(state, allMastered, needsReview) {
    if (state.phase !== "idle") return state;
    if (allMastered) {
      return {
        ...state,
        masteryText: "Looks like you\u2019ve got this!",
        showMastery: true
      };
    }
    if (needsReview) {
      return { ...state, masteryText: "Time to review?", showMastery: true };
    }
    return { ...state, masteryText: "", showMastery: false };
  }
  function engineUpdateMasteryAfterAnswer(state, allMastered) {
    if (allMastered) {
      return {
        ...state,
        masteryText: "Looks like you\u2019ve got this!",
        showMastery: true
      };
    }
    return { ...state, showMastery: false };
  }
  function engineUpdateProgress(state, masteredCount, totalEnabledCount) {
    return { ...state, masteredCount, totalEnabledCount };
  }
  function engineRouteKey(state, key) {
    if (state.phase === "idle") return { action: "ignore" };
    if (key === "Escape") return { action: "stop" };
    if (state.phase === "round-complete") {
      if (key === " " || key === "Enter") return { action: "continue" };
      return { action: "ignore" };
    }
    if (state.phase !== "active") return { action: "ignore" };
    if ((key === " " || key === "Enter") && state.answered) {
      return { action: "next" };
    }
    if (!state.answered) return { action: "delegate" };
    return { action: "ignore" };
  }

  // src/adaptive.ts
  var DEFAULT_CONFIG = {
    minTime: 1e3,
    unseenBoost: 3,
    ewmaAlpha: 0.3,
    maxStoredTimes: 10,
    maxResponseTime: 9e3,
    // Forgetting model
    initialStability: 4,
    // hours — half-life after first correct answer
    maxStability: 336,
    // hours (14 days) — stability ceiling
    stabilityGrowthBase: 2,
    // multiplier on each correct answer
    stabilityDecayOnWrong: 0.3,
    // multiplier on wrong answer
    recallThreshold: 0.5,
    // P(recall) below this = "due"
    expansionThreshold: 0.7,
    // fraction of seen items that must be retained before suggesting new strings
    speedBonusMax: 1.5,
    // fast answers grow stability up to this extra factor
    selfCorrectionThreshold: 1500,
    // ms — response time below this triggers self-correction
    automaticityTarget: 3e3,
    // ms — response time at which speedScore ≈ 0.5
    automaticityThreshold: 0.8
    // automaticity above this = "automatic" (matches stats heatmap)
  };
  function computeEwma(oldEwma, newTime, alpha) {
    return alpha * newTime + (1 - alpha) * oldEwma;
  }
  function computeRecall(stabilityHours, elapsedHours) {
    if (stabilityHours == null || elapsedHours == null) return null;
    if (stabilityHours <= 0) return 0;
    if (elapsedHours <= 0) return 1;
    return Math.pow(2, -elapsedHours / stabilityHours);
  }
  function computeSpeedScore(ewmaMs, cfg, responseCount = 1) {
    if (ewmaMs == null) return null;
    const effectiveTarget = cfg.automaticityTarget * responseCount;
    const effectiveMin = cfg.minTime * responseCount;
    const k3 = Math.LN2 / (effectiveTarget - effectiveMin);
    return Math.exp(-k3 * Math.max(0, ewmaMs - effectiveMin));
  }
  function computeAutomaticity(recall, speedScore) {
    if (recall == null || speedScore == null) return null;
    return recall * speedScore;
  }
  function computeAutomaticityForDisplay(recall, speedScore, hasSeen) {
    const value = computeAutomaticity(recall, speedScore);
    if (value == null && hasSeen) return 0;
    return value;
  }
  function updateStability(oldStability, responseTimeMs, elapsedHours, cfg) {
    if (oldStability == null) {
      return cfg.initialStability;
    }
    const range = cfg.maxResponseTime - cfg.minTime;
    const clamped = Math.max(
      cfg.minTime,
      Math.min(responseTimeMs, cfg.maxResponseTime)
    );
    const t3 = range > 0 ? (cfg.maxResponseTime - clamped) / range : 0.5;
    const speedFactor = 0.5 + t3 * (cfg.speedBonusMax - 0.5);
    let newStability = oldStability * cfg.stabilityGrowthBase * speedFactor;
    if (elapsedHours !== null && elapsedHours > 0 && responseTimeMs < cfg.selfCorrectionThreshold) {
      newStability = Math.max(newStability, elapsedHours * 1.5);
    }
    return Math.min(newStability, cfg.maxStability);
  }
  function computeStabilityAfterWrong(oldStability, cfg) {
    if (oldStability == null) return cfg.initialStability;
    return Math.max(
      cfg.initialStability,
      oldStability * cfg.stabilityDecayOnWrong
    );
  }
  function computeWeight(stats, cfg) {
    if (!stats) {
      return cfg.unseenBoost;
    }
    const speedWeight = Math.max(stats.ewma, cfg.minTime) / cfg.minTime;
    if (stats.stability != null && stats.lastCorrectAt != null) {
      const elapsedHours = (Date.now() - stats.lastCorrectAt) / 36e5;
      const recall = computeRecall(stats.stability, elapsedHours);
      const recallWeight = recall != null ? 1 + (1 - recall) : 1;
      return speedWeight * recallWeight;
    }
    return speedWeight;
  }
  function selectWeighted(items, weights, rand) {
    const totalWeight = weights.reduce((sum, w3) => sum + w3, 0);
    if (totalWeight === 0) {
      return items[Math.floor(rand * items.length)];
    }
    let remaining = rand * totalWeight;
    for (let i3 = 0; i3 < items.length; i3++) {
      remaining -= weights[i3];
      if (remaining <= 0) return items[i3];
    }
    return items[items.length - 1];
  }
  function deriveScaledConfig(motorBaseline, baseCfg = DEFAULT_CONFIG) {
    const scale = motorBaseline / 1e3;
    return {
      ...baseCfg,
      minTime: Math.round(baseCfg.minTime * scale),
      automaticityTarget: Math.round(baseCfg.automaticityTarget * scale),
      selfCorrectionThreshold: Math.round(
        baseCfg.selfCorrectionThreshold * scale
      ),
      maxResponseTime: Math.round(baseCfg.maxResponseTime * scale)
    };
  }
  function createAdaptiveSelector(storage, cfg = DEFAULT_CONFIG, randomFn = Math.random, responseCountFn = null) {
    function getResponseCount(itemId) {
      return responseCountFn ? responseCountFn(itemId) : 1;
    }
    function scaledConfig(itemId) {
      const rc = getResponseCount(itemId);
      if (rc <= 1) return cfg;
      return {
        ...cfg,
        minTime: cfg.minTime * rc,
        automaticityTarget: cfg.automaticityTarget * rc,
        maxResponseTime: cfg.maxResponseTime * rc,
        selfCorrectionThreshold: cfg.selfCorrectionThreshold * rc
      };
    }
    function recordResponse(itemId, timeMs, correct = true) {
      const itemCfg = scaledConfig(itemId);
      const clamped = Math.min(timeMs, itemCfg.maxResponseTime);
      const existing = storage.getStats(itemId);
      const now = Date.now();
      if (correct) {
        const elapsedHours = existing && existing.lastCorrectAt ? (now - existing.lastCorrectAt) / 36e5 : null;
        if (existing) {
          const newEwma = computeEwma(existing.ewma, clamped, cfg.ewmaAlpha);
          const newTimes = [...existing.recentTimes, clamped].slice(
            -cfg.maxStoredTimes
          );
          const newStability = updateStability(
            existing.stability ?? null,
            clamped,
            elapsedHours,
            itemCfg
          );
          storage.saveStats(itemId, {
            recentTimes: newTimes,
            ewma: newEwma,
            sampleCount: existing.sampleCount + 1,
            lastSeen: now,
            stability: newStability,
            lastCorrectAt: now
          });
        } else {
          storage.saveStats(itemId, {
            recentTimes: [clamped],
            ewma: clamped,
            sampleCount: 1,
            lastSeen: now,
            stability: cfg.initialStability,
            lastCorrectAt: now
          });
        }
      } else {
        if (existing) {
          const newStability = computeStabilityAfterWrong(
            existing.stability ?? null,
            cfg
          );
          storage.saveStats(itemId, {
            ...existing,
            lastSeen: now,
            stability: newStability
          });
        } else {
          storage.saveStats(itemId, {
            recentTimes: [],
            ewma: itemCfg.maxResponseTime,
            sampleCount: 0,
            lastSeen: now,
            stability: cfg.initialStability,
            lastCorrectAt: null
          });
        }
      }
    }
    function getWeight(itemId) {
      return computeWeight(storage.getStats(itemId), scaledConfig(itemId));
    }
    function getStats(itemId) {
      return storage.getStats(itemId);
    }
    function selectNext(validItems) {
      if (validItems.length === 0) {
        throw new Error("validItems cannot be empty");
      }
      if (validItems.length === 1) {
        storage.setLastSelected(validItems[0]);
        return validItems[0];
      }
      const lastSelected = storage.getLastSelected();
      const weights = validItems.map(
        (id) => id === lastSelected ? 0 : getWeight(id)
      );
      const selected = selectWeighted(validItems, weights, randomFn());
      storage.setLastSelected(selected);
      return selected;
    }
    function getRecall(itemId) {
      const stats = storage.getStats(itemId);
      if (!stats || stats.stability == null || stats.lastCorrectAt == null) {
        return null;
      }
      const elapsedHours = (Date.now() - stats.lastCorrectAt) / 36e5;
      return computeRecall(stats.stability, elapsedHours);
    }
    function getAutomaticity(itemId) {
      const stats = storage.getStats(itemId);
      if (!stats) return null;
      const recall = getRecall(itemId);
      const speed = computeSpeedScore(stats.ewma, scaledConfig(itemId));
      return computeAutomaticityForDisplay(recall, speed, true);
    }
    function getStringRecommendations(stringIndices, getItemIds) {
      const results = stringIndices.map((s3) => {
        const items = getItemIds(s3);
        let dueCount = 0;
        let unseenCount = 0;
        let masteredCount = 0;
        for (const id of items) {
          const recall = getRecall(id);
          if (recall === null) {
            unseenCount++;
          } else if (recall < cfg.recallThreshold) {
            dueCount++;
          } else {
            masteredCount++;
          }
        }
        return {
          string: s3,
          dueCount,
          unseenCount,
          masteredCount,
          totalCount: items.length
        };
      });
      results.sort(
        (a3, b) => b.dueCount + b.unseenCount - (a3.dueCount + a3.unseenCount)
      );
      return results;
    }
    function checkAllMastered(items) {
      for (const id of items) {
        const recall = getRecall(id);
        if (recall === null || recall < cfg.recallThreshold) return false;
      }
      return items.length > 0;
    }
    function checkAllAutomatic(items) {
      for (const id of items) {
        const auto = getAutomaticity(id);
        if (auto === null || auto <= cfg.automaticityThreshold) return false;
      }
      return items.length > 0;
    }
    function checkNeedsReview(items) {
      if (items.length === 0) return false;
      let hasDueItem = false;
      for (const id of items) {
        const stats = storage.getStats(id);
        if (!stats || stats.lastCorrectAt == null || stats.sampleCount < 2) {
          return false;
        }
        const rc = getResponseCount(id);
        const speed = computeSpeedScore(stats.ewma, cfg, rc);
        if (speed == null || speed < 0.5) return false;
        const recall = getRecall(id);
        if (recall !== null && recall < cfg.recallThreshold) hasDueItem = true;
      }
      return hasDueItem;
    }
    function updateConfig(newCfg) {
      cfg = { ...cfg, ...newCfg };
    }
    function getConfig() {
      return cfg;
    }
    return {
      recordResponse,
      selectNext,
      getStats,
      getWeight,
      getRecall,
      getAutomaticity,
      getStringRecommendations,
      checkAllMastered,
      checkAllAutomatic,
      checkNeedsReview,
      updateConfig,
      getConfig
    };
  }
  function createLocalStorageAdapter(namespace) {
    const cache = {};
    const mkKey = (itemId) => `adaptive_${namespace}_${itemId}`;
    const dlKey = (itemId) => `deadline_${namespace}_${itemId}`;
    const lastKey = `adaptive_${namespace}_lastSelected`;
    return {
      getStats(itemId) {
        const k3 = mkKey(itemId);
        if (!(k3 in cache)) {
          const data = localStorage.getItem(k3);
          try {
            cache[k3] = data ? JSON.parse(data) : null;
          } catch {
            cache[k3] = null;
          }
        }
        return cache[k3];
      },
      saveStats(itemId, stats) {
        const k3 = mkKey(itemId);
        cache[k3] = stats;
        localStorage.setItem(k3, JSON.stringify(stats));
      },
      getLastSelected() {
        return localStorage.getItem(lastKey);
      },
      setLastSelected(itemId) {
        localStorage.setItem(lastKey, itemId);
      },
      getDeadline(itemId) {
        const k3 = dlKey(itemId);
        if (!(k3 in cache)) {
          const data = localStorage.getItem(k3);
          cache[k3] = data ? Number(data) : null;
        }
        return cache[k3];
      },
      saveDeadline(itemId, deadline) {
        const k3 = dlKey(itemId);
        cache[k3] = deadline;
        localStorage.setItem(k3, String(deadline));
      },
      /** Pre-populate cache to avoid localStorage reads during gameplay. */
      preload(itemIds) {
        for (const itemId of itemIds) {
          this.getStats(itemId);
        }
      }
    };
  }

  // src/use-quiz-engine.ts
  var ROUND_DURATION_MS = 6e4;
  function formatRoundTime(ms) {
    const totalSec = Math.max(0, Math.ceil(ms / 1e3));
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;
    return min + ":" + (sec < 10 ? "0" : "") + sec;
  }
  function useQuizEngine(def, scope) {
    const [engineState, setEngineState] = d2(
      initialEngineState
    );
    const [countdown, setCountdown] = d2({
      pct: 100,
      time: "",
      warning: false,
      lastQuestion: false
    });
    const [baseline, setBaseline] = d2(null);
    const stateRef = A2(engineState);
    stateRef.current = engineState;
    const scopeRef = A2(scope);
    scopeRef.current = scope;
    const defRef = A2(def);
    defRef.current = def;
    const storageRef = A2(null);
    const selectorRef = A2(null);
    const keyHandlerRef = A2(null);
    const roundTimerRef = A2(null);
    const roundStartRef = A2(null);
    const autoAdvanceRef = A2(null);
    if (!storageRef.current) {
      storageRef.current = createLocalStorageAdapter(def.storageNamespace);
      selectorRef.current = createAdaptiveSelector(
        storageRef.current,
        DEFAULT_CONFIG,
        Math.random,
        def.getExpectedResponseCount ? (id) => def.getExpectedResponseCount(id) : null
      );
      const provider = def.calibrationProvider || "button";
      const baselineKey = "motorBaseline_" + provider;
      const stored = localStorage.getItem(baselineKey);
      if (stored) {
        const parsed = parseInt(stored, 10);
        if (parsed > 0) {
          setBaseline(parsed);
          selectorRef.current.updateConfig(
            deriveScaledConfig(parsed, DEFAULT_CONFIG)
          );
        }
      }
    }
    const selector = selectorRef.current;
    const storage = storageRef.current;
    const setState = q2((updater) => {
      setEngineState((prev) => {
        const next = updater(prev);
        stateRef.current = next;
        return next;
      });
    }, []);
    const computeProgress = q2(() => {
      const items = defRef.current.getEnabledItems(scopeRef.current);
      let mastered = 0;
      const threshold = selector.getConfig().automaticityThreshold;
      for (const id of items) {
        const auto = selector.getAutomaticity(id);
        if (auto !== null && auto > threshold) mastered++;
      }
      return { masteredCount: mastered, totalEnabledCount: items.length };
    }, [selector]);
    const stopRoundTimer = q2(() => {
      if (roundTimerRef.current) {
        clearInterval(roundTimerRef.current);
        roundTimerRef.current = null;
      }
      roundStartRef.current = null;
      setCountdown({ pct: 100, time: "", warning: false, lastQuestion: false });
    }, []);
    const nextQuestionRef = A2(() => {
    });
    const transitionToRoundCompleteRef = A2(() => {
    });
    const transitionToRoundComplete = q2(() => {
      const durationMs = roundStartRef.current ? Date.now() - roundStartRef.current : 0;
      stopRoundTimer();
      setState((s3) => ({
        ...engineRoundComplete(s3),
        roundDurationMs: durationMs
      }));
    }, [stopRoundTimer, setState]);
    transitionToRoundCompleteRef.current = transitionToRoundComplete;
    const startRoundTimer = q2(() => {
      if (roundTimerRef.current) clearInterval(roundTimerRef.current);
      roundStartRef.current = Date.now();
      setCountdown({
        pct: 100,
        time: formatRoundTime(ROUND_DURATION_MS),
        warning: false,
        lastQuestion: false
      });
      roundTimerRef.current = setInterval(() => {
        const elapsed = Date.now() - roundStartRef.current;
        const remaining = ROUND_DURATION_MS - elapsed;
        const pct = Math.max(0, remaining / ROUND_DURATION_MS * 100);
        const warning = remaining <= 1e4 && remaining > 0;
        setCountdown((prev) => ({
          ...prev,
          pct,
          time: formatRoundTime(remaining),
          warning
        }));
        if (remaining <= 0) {
          if (roundTimerRef.current) clearInterval(roundTimerRef.current);
          roundTimerRef.current = null;
          setCountdown((prev) => ({
            ...prev,
            pct: 0,
            time: "0:00",
            warning: false
          }));
          const s3 = stateRef.current;
          if (s3.phase !== "active") return;
          setState((st) => engineRoundTimerExpired(st));
          if (s3.answered) {
            transitionToRoundCompleteRef.current();
          } else {
            setCountdown((prev) => ({ ...prev, lastQuestion: true }));
          }
        }
      }, 200);
    }, [setState]);
    const nextQuestion = q2(() => {
      if (autoAdvanceRef.current) {
        clearTimeout(autoAdvanceRef.current);
        autoAdvanceRef.current = null;
      }
      if (stateRef.current.roundTimerExpired) {
        transitionToRoundCompleteRef.current();
        return;
      }
      const items = defRef.current.getEnabledItems(scopeRef.current);
      if (items.length === 0) return;
      const nextItemId = selector.selectNext(items);
      setState((s3) => engineNextQuestion(s3, nextItemId, Date.now()));
    }, [selector, setState]);
    nextQuestionRef.current = nextQuestion;
    const submitAnswer = q2(
      (input) => {
        const s3 = stateRef.current;
        if (s3.phase !== "active" || s3.answered) return;
        const responseTime = Date.now() - s3.questionStartTime;
        const result = defRef.current.checkAnswer(s3.currentItemId, input);
        selector.recordResponse(s3.currentItemId, responseTime, result.correct);
        setState((st) => {
          let next = engineSubmitAnswer(st, result.correct, result.correctAnswer);
          next = {
            ...next,
            roundResponseTimes: [...next.roundResponseTimes, responseTime]
          };
          const items = defRef.current.getEnabledItems(scopeRef.current);
          const allMastered = selector.checkAllAutomatic(items);
          next = engineUpdateMasteryAfterAnswer(next, allMastered);
          const progress = computeProgress();
          next = engineUpdateProgress(
            next,
            progress.masteredCount,
            progress.totalEnabledCount
          );
          return next;
        });
        if (stateRef.current.roundTimerExpired) {
          autoAdvanceRef.current = setTimeout(() => {
            if (stateRef.current.phase === "active") {
              transitionToRoundCompleteRef.current();
            }
          }, 600);
        } else {
          autoAdvanceRef.current = setTimeout(() => {
            if (stateRef.current.phase === "active" && stateRef.current.answered) {
              nextQuestionRef.current();
            }
          }, 1e3);
        }
        return result;
      },
      [selector, setState, computeProgress]
    );
    const start = q2(() => {
      setState((s3) => {
        let next = engineStart(s3);
        const progress = computeProgress();
        next = engineUpdateProgress(
          next,
          progress.masteredCount,
          progress.totalEnabledCount
        );
        return next;
      });
      startRoundTimer();
      setTimeout(() => nextQuestionRef.current(), 0);
    }, [setState, startRoundTimer, computeProgress]);
    const stop = q2(() => {
      if (autoAdvanceRef.current) {
        clearTimeout(autoAdvanceRef.current);
        autoAdvanceRef.current = null;
      }
      stopRoundTimer();
      keyHandlerRef.current?.reset();
      setState(() => initialEngineState());
    }, [stopRoundTimer, setState]);
    const continueQuiz = q2(() => {
      setState((s3) => engineContinueRound(s3));
      startRoundTimer();
      setTimeout(() => nextQuestionRef.current(), 0);
    }, [setState, startRoundTimer]);
    const updateIdleMessage = q2(() => {
      if (stateRef.current.phase !== "idle") return;
      const items = defRef.current.getEnabledItems(scopeRef.current);
      setState(
        (s3) => engineUpdateIdleMessage(
          s3,
          selector.checkAllAutomatic(items),
          selector.checkNeedsReview(items)
        )
      );
    }, [selector, setState]);
    const setKeyHandler = q2((handler) => {
      keyHandlerRef.current = handler;
    }, []);
    y2(() => {
      function handleKeydown(e3) {
        const routed = engineRouteKey(stateRef.current, e3.key);
        switch (routed.action) {
          case "stop":
            e3.stopImmediatePropagation();
            stop();
            break;
          case "next":
            e3.preventDefault();
            if (autoAdvanceRef.current) {
              clearTimeout(autoAdvanceRef.current);
              autoAdvanceRef.current = null;
            }
            nextQuestionRef.current();
            break;
          case "continue":
            e3.preventDefault();
            continueQuiz();
            break;
          case "delegate":
            keyHandlerRef.current?.handleKey(e3);
            break;
          case "ignore":
            break;
        }
      }
      document.addEventListener("keydown", handleKeydown);
      return () => document.removeEventListener("keydown", handleKeydown);
    }, [stop, continueQuiz]);
    y2(() => {
      return () => {
        if (roundTimerRef.current) clearInterval(roundTimerRef.current);
        if (autoAdvanceRef.current) clearTimeout(autoAdvanceRef.current);
      };
    }, []);
    return {
      state: engineState,
      countdown,
      baseline,
      selector,
      storage,
      start,
      stop,
      submitAnswer,
      nextQuestion,
      continueQuiz,
      updateIdleMessage,
      computeProgress,
      setKeyHandler
    };
  }

  // src/fretboard.ts
  var fretPositions = [
    0,
    65,
    126,
    183,
    237,
    288,
    336,
    381,
    423,
    463,
    500,
    535,
    568,
    600
  ];
  var MAX_FRET_COUNT = fretPositions.length - 1;
  var PAD_Y = 18;
  var STRING_GAP = 38;
  function stringY(stringIndex) {
    return PAD_Y + stringIndex * STRING_GAP;
  }
  function noteX(fret) {
    return fret === 0 ? (fretPositions[0] + fretPositions[1]) / 2 : (fretPositions[fret] + fretPositions[fret + 1]) / 2;
  }
  function svgHeight(stringCount) {
    return (stringCount - 1) * STRING_GAP + PAD_Y * 2;
  }

  // src/music-data.ts
  var NOTES = [
    { name: "C", displayName: "C", num: 0, accepts: ["c"] },
    { name: "C#", displayName: "C#/Db", num: 1, accepts: ["c#", "db"] },
    { name: "D", displayName: "D", num: 2, accepts: ["d"] },
    { name: "D#", displayName: "D#/Eb", num: 3, accepts: ["d#", "eb"] },
    { name: "E", displayName: "E", num: 4, accepts: ["e"] },
    { name: "F", displayName: "F", num: 5, accepts: ["f"] },
    { name: "F#", displayName: "F#/Gb", num: 6, accepts: ["f#", "gb"] },
    { name: "G", displayName: "G", num: 7, accepts: ["g"] },
    { name: "G#", displayName: "G#/Ab", num: 8, accepts: ["g#", "ab"] },
    { name: "A", displayName: "A", num: 9, accepts: ["a"] },
    { name: "A#", displayName: "A#/Bb", num: 10, accepts: ["a#", "bb"] },
    { name: "B", displayName: "B", num: 11, accepts: ["b"] }
  ];
  var NATURAL_NOTES = ["C", "D", "E", "F", "G", "A", "B"];
  function noteByNum(num) {
    return NOTES[(num % 12 + 12) % 12];
  }
  function noteAdd(noteNum, semitones) {
    return noteByNum(noteNum + semitones);
  }
  function noteSub(noteNum, semitones) {
    return noteByNum(noteNum - semitones);
  }
  function pickAccidentalName(displayName, useFlats) {
    if (!displayName.includes("/")) return displayName;
    const [sharp, flat] = displayName.split("/");
    return useFlats ? flat : sharp;
  }
  function pickRandomAccidental(displayName) {
    if (!displayName.includes("/")) return displayName;
    const [sharp, flat] = displayName.split("/");
    return Math.random() < 0.5 ? sharp : flat;
  }
  function noteMatchesInput(note, input) {
    return note.accepts.includes(input.toLowerCase());
  }
  var DIATONIC_CHORDS = [
    { degree: 1, numeral: "I", quality: "major", qualityLabel: "" },
    { degree: 2, numeral: "ii", quality: "minor", qualityLabel: "m" },
    { degree: 3, numeral: "iii", quality: "minor", qualityLabel: "m" },
    { degree: 4, numeral: "IV", quality: "major", qualityLabel: "" },
    { degree: 5, numeral: "V", quality: "major", qualityLabel: "" },
    { degree: 6, numeral: "vi", quality: "minor", qualityLabel: "m" },
    {
      degree: 7,
      numeral: "vii\xB0",
      quality: "diminished",
      qualityLabel: "dim"
    }
  ];
  var ROMAN_NUMERALS = DIATONIC_CHORDS.map((c3) => c3.numeral);
  var GUITAR = {
    id: "fretboard",
    // mode ID (preserved for backward compat)
    name: "Guitar Fretboard",
    storageNamespace: "fretboard",
    stringCount: 6,
    fretCount: 13,
    // frets 0–12
    stringNames: ["e", "B", "G", "D", "A", "E"],
    stringOffsets: [4, 11, 7, 2, 9, 4],
    // semitones from C per string
    defaultString: 5,
    // low E
    fretMarkers: [3, 5, 7, 9, 12]
  };
  var STRING_NAMES = GUITAR.stringNames;
  var STRING_OFFSETS = GUITAR.stringOffsets;
  var SOLFEGE_MAP = {
    C: "Do",
    D: "Re",
    E: "Mi",
    F: "Fa",
    G: "Sol",
    A: "La",
    B: "Si"
  };
  var _useSolfege = false;
  function getUseSolfege() {
    return _useSolfege;
  }
  function setUseSolfege(v3) {
    _useSolfege = v3;
    try {
      localStorage.setItem("fretboard_notation", v3 ? "solfege" : "letter");
    } catch (_2) {
    }
  }
  try {
    _useSolfege = localStorage.getItem("fretboard_notation") === "solfege";
  } catch (_2) {
  }
  function displayNote(name) {
    if (!name) return name;
    const letter = name[0].toUpperCase();
    const acc = name.slice(1).replace(/#/g, "\u266F").replace(/b/g, "\u266D");
    if (!_useSolfege) {
      return name[0] + acc;
    }
    const syl = SOLFEGE_MAP[letter];
    if (!syl) return name[0] + acc;
    const out = name[0] === name[0].toLowerCase() ? syl.toLowerCase() : syl;
    return out + acc;
  }

  // node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
  var f3 = 0;
  function u3(e3, t3, n2, o3, i3, u4) {
    t3 || (t3 = {});
    var a3, c3, p3 = t3;
    if ("ref" in p3) for (c3 in p3 = {}, t3) "ref" == c3 ? a3 = t3[c3] : p3[c3] = t3[c3];
    var l3 = { type: e3, props: p3, key: n2, ref: a3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --f3, __i: -1, __u: 0, __source: i3, __self: u4 };
    if ("function" == typeof e3 && (a3 = e3.defaultProps)) for (c3 in a3) void 0 === p3[c3] && (p3[c3] = a3[c3]);
    return l.vnode && l.vnode(l3), l3;
  }

  // src/ui-shared.tsx
  function FretboardSVG({
    stringCount = 6,
    fretCount = 13,
    markers = [3, 5, 7, 9, 12],
    highlights,
    onCircleClick
  }) {
    const height = svgHeight(stringCount);
    return /* @__PURE__ */ u3("div", { class: "fretboard-wrapper", children: /* @__PURE__ */ u3("svg", { viewBox: `0 0 600 ${height}`, class: "fretboard-svg", children: [
      /* @__PURE__ */ u3(
        "line",
        {
          class: "fb-nut",
          x1: fretPositions[1],
          y1: 0,
          x2: fretPositions[1],
          y2: height,
          "stroke-width": 3
        }
      ),
      fretPositions.slice(2).map((x2) => /* @__PURE__ */ u3(
        "line",
        {
          class: "fb-fret",
          x1: x2,
          y1: 0,
          x2,
          y2: height,
          "stroke-width": 1
        },
        x2
      )),
      Array.from({ length: stringCount }, (_2, i3) => /* @__PURE__ */ u3(
        "line",
        {
          class: "fb-string",
          x1: 0,
          y1: stringY(i3),
          x2: 600,
          y2: stringY(i3),
          "stroke-width": 1 + i3 * 0.4
        },
        i3
      )),
      markers.filter((f4) => f4 < fretCount).map((fret) => {
        const cx = noteX(fret);
        if (fret === 12) {
          const y1 = stringCount <= 4 ? stringY(1) : (stringY(1) + stringY(2)) / 2;
          const y22 = stringCount <= 4 ? stringY(stringCount - 2) : (stringY(stringCount - 3) + stringY(stringCount - 2)) / 2;
          return /* @__PURE__ */ u3("g", { children: [
            /* @__PURE__ */ u3("circle", { class: "fb-marker", cx, cy: y1, r: 4 }),
            /* @__PURE__ */ u3("circle", { class: "fb-marker", cx, cy: y22, r: 4 })
          ] }, fret);
        }
        return /* @__PURE__ */ u3(
          "circle",
          {
            class: "fb-marker",
            cx,
            cy: height / 2,
            r: 4
          },
          fret
        );
      }),
      Array.from({ length: stringCount }, (_2, s3) => Array.from({ length: fretCount }, (_3, f4) => {
        const key = `${s3}-${f4}`;
        const fill = highlights?.get(key);
        return /* @__PURE__ */ u3(
          "circle",
          {
            class: "fb-pos",
            "data-string": s3,
            "data-fret": f4,
            cx: noteX(f4),
            cy: stringY(s3),
            r: 10,
            style: fill ? { fill } : void 0,
            onClick: onCircleClick ? () => onCircleClick(s3, f4) : void 0
          },
          key
        );
      }))
    ] }) });
  }
  function NoteButtons({
    onAnswer,
    disabled,
    useFlats,
    hideAccidentals
  }) {
    const naturals = NOTES.filter((n2) => !n2.name.includes("#"));
    const accidentals = NOTES.filter((n2) => n2.name.includes("#"));
    const label = q2(
      (name) => {
        if (useFlats) {
          const note = NOTES.find((n2) => n2.name === name);
          if (note && note.displayName !== name) {
            return displayNote(note.displayName);
          }
        }
        return displayNote(name);
      },
      [useFlats]
    );
    return /* @__PURE__ */ u3("div", { class: "note-buttons", children: [
      /* @__PURE__ */ u3("div", { class: "note-row-naturals", children: naturals.map((n2) => /* @__PURE__ */ u3(
        "button",
        {
          type: "button",
          class: "answer-btn answer-btn-note note-btn",
          "data-note": n2.name,
          disabled,
          onClick: () => onAnswer(n2.name),
          children: label(n2.name)
        },
        n2.name
      )) }),
      /* @__PURE__ */ u3(
        "div",
        {
          class: `note-row-accidentals${hideAccidentals ? " hidden" : ""}`,
          children: accidentals.map((n2) => /* @__PURE__ */ u3(
            "button",
            {
              type: "button",
              class: "answer-btn answer-btn-note note-btn",
              "data-note": n2.name,
              disabled,
              onClick: () => onAnswer(n2.name),
              children: label(n2.name)
            },
            n2.name
          ))
        }
      )
    ] });
  }
  function NumberButtons({
    min,
    max,
    onAnswer,
    disabled
  }) {
    const nums = Array.from({ length: max - min + 1 }, (_2, i3) => min + i3);
    return /* @__PURE__ */ u3("div", { class: "answer-buttons answer-buttons-numbers", children: nums.map((n2) => /* @__PURE__ */ u3(
      "button",
      {
        type: "button",
        class: "answer-btn",
        "data-num": n2,
        disabled,
        onClick: () => onAnswer(String(n2)),
        children: n2
      },
      n2
    )) });
  }
  function CountdownBar({
    pct,
    warning
  }) {
    return /* @__PURE__ */ u3(
      "div",
      {
        class: `quiz-countdown-bar${warning ? " round-timer-warning" : ""}`,
        children: /* @__PURE__ */ u3("div", { class: "quiz-countdown-fill", style: { width: pct + "%" } })
      }
    );
  }
  function RoundComplete({
    state,
    practicingLabel,
    onContinue,
    onStop
  }) {
    const durationSec = Math.round((state.roundDurationMs || 0) / 1e3);
    const fluencyText = state.masteredCount + " / " + state.totalEnabledCount + " fluent";
    const contextText = practicingLabel ? practicingLabel + " \xB7 " + fluencyText : fluencyText;
    let medianText = "";
    if (state.roundResponseTimes.length > 0) {
      const sorted = state.roundResponseTimes.slice().sort((a3, b) => a3 - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
      medianText = (median / 1e3).toFixed(1) + "s median response time";
    }
    return /* @__PURE__ */ u3("div", { class: "round-complete", children: [
      /* @__PURE__ */ u3("div", { class: "round-complete-context", children: contextText }),
      /* @__PURE__ */ u3("div", { class: "round-complete-heading", children: "Round complete" }),
      /* @__PURE__ */ u3("div", { class: "round-stat-line round-stat-correct", children: [
        state.roundCorrect,
        " / ",
        state.roundAnswered,
        " correct \xB7",
        " ",
        durationSec,
        "s"
      ] }),
      /* @__PURE__ */ u3("div", { class: "round-stat-line round-stat-median", children: medianText }),
      /* @__PURE__ */ u3("div", { class: "round-complete-actions", children: [
        /* @__PURE__ */ u3(
          "button",
          {
            type: "button",
            class: "round-complete-continue",
            onClick: onContinue,
            children: "Keep going"
          }
        ),
        /* @__PURE__ */ u3("button", { type: "button", class: "round-complete-stop", onClick: onStop, children: "Stop" })
      ] })
    ] });
  }
  function ProgressBar({
    masteredCount,
    totalEnabledCount
  }) {
    const pct = totalEnabledCount > 0 ? Math.round(masteredCount / totalEnabledCount * 100) : 0;
    return /* @__PURE__ */ u3("div", { class: "progress-bar", children: [
      /* @__PURE__ */ u3("div", { class: "progress-fill", style: { width: pct + "%" } }),
      /* @__PURE__ */ u3("div", { class: "progress-text", children: [
        masteredCount,
        " / ",
        totalEnabledCount,
        " fluent"
      ] })
    ] });
  }

  // src/ui-mode.tsx
  function loadScope(def) {
    const spec = def.scopeSpec;
    if (spec.kind === "none") return { kind: "none" };
    if (spec.kind === "groups") {
      const stored = localStorage.getItem(spec.storageKey);
      if (stored) {
        try {
          const arr = JSON.parse(stored);
          return { kind: "groups", enabledGroups: new Set(arr) };
        } catch {
        }
      }
      return { kind: "groups", enabledGroups: new Set(spec.defaultEnabled) };
    }
    if (spec.kind === "fretboard") {
      const inst = spec.instrument;
      const key = "scope_" + inst.id;
      const stored = localStorage.getItem(key);
      if (stored) {
        try {
          const obj = JSON.parse(stored);
          return {
            kind: "fretboard",
            enabledStrings: new Set(obj.strings || [inst.defaultString]),
            noteFilter: obj.noteFilter || "all"
          };
        } catch {
        }
      }
      return {
        kind: "fretboard",
        enabledStrings: /* @__PURE__ */ new Set([inst.defaultString]),
        noteFilter: "all"
      };
    }
    if (spec.kind === "note-filter") {
      const stored = localStorage.getItem(spec.storageKey);
      return {
        kind: "note-filter",
        noteFilter: stored || "all"
      };
    }
    return { kind: "none" };
  }
  function saveScope(def, scope) {
    const spec = def.scopeSpec;
    if (spec.kind === "groups" && scope.kind === "groups") {
      localStorage.setItem(
        spec.storageKey,
        JSON.stringify([...scope.enabledGroups])
      );
    }
    if (spec.kind === "fretboard" && scope.kind === "fretboard") {
      const inst = spec.instrument;
      localStorage.setItem(
        "scope_" + inst.id,
        JSON.stringify({
          strings: [...scope.enabledStrings],
          noteFilter: scope.noteFilter
        })
      );
    }
    if (spec.kind === "note-filter" && scope.kind === "note-filter") {
      localStorage.setItem(spec.storageKey, scope.noteFilter);
    }
  }
  function ModeView({
    def,
    onHome
  }) {
    const [scope, setScope] = d2(() => loadScope(def));
    const [activeTab, setActiveTab] = d2(
      "practice"
    );
    const [highlights, setHighlights] = d2(
      /* @__PURE__ */ new Map()
    );
    const [lastResult, setLastResult] = d2(null);
    const engine = useQuizEngine(def, scope);
    const { state, countdown } = engine;
    y2(() => {
      saveScope(def, scope);
    }, [scope, def]);
    y2(() => {
      engine.updateIdleMessage();
    }, [scope]);
    const question = T2(() => {
      if (!state.currentItemId) return null;
      return def.getQuestion(state.currentItemId);
    }, [state.currentItemId, def]);
    y2(() => {
      if (!question || !state.currentItemId) {
        setHighlights(/* @__PURE__ */ new Map());
        return;
      }
      const q3 = question;
      if (q3.currentString !== void 0 && q3.currentFret !== void 0) {
        setHighlights(
          /* @__PURE__ */ new Map([[
            `${q3.currentString}-${q3.currentFret}`,
            "hsl(50, 100%, 50%)"
          ]])
        );
      }
    }, [question, state.currentItemId]);
    y2(() => {
      if (!lastResult || !state.currentItemId) return;
      const q3 = question;
      if (q3?.currentString !== void 0 && q3?.currentFret !== void 0) {
        const color = lastResult.correct ? "hsl(140, 70%, 45%)" : "hsl(0, 80%, 55%)";
        setHighlights(
          /* @__PURE__ */ new Map([[`${q3.currentString}-${q3.currentFret}`, color]])
        );
      }
      setLastResult(null);
    }, [lastResult]);
    y2(() => {
      const response = def.response;
      if (response.kind === "buttons" || response.kind === "bidirectional") {
        const handler = response.createKeyHandler(
          (input) => {
            const result = engine.submitAnswer(input);
            if (result) setLastResult(result);
          },
          () => scope
        );
        engine.setKeyHandler(handler);
        return () => {
          handler.reset();
          engine.setKeyHandler(null);
        };
      }
    }, [def, scope]);
    const handleAnswer = q2(
      (input) => {
        const result = engine.submitAnswer(input);
        if (result) setLastResult(result);
      },
      [engine]
    );
    const handleTapAdvance = q2(
      (e3) => {
        if (state.phase !== "active" || !state.answered) return;
        if (e3.target.closest(".answer-btn, .note-btn")) return;
        engine.nextQuestion();
      },
      [state.phase, state.answered, engine]
    );
    const phaseClass = state.phase === "active" ? "phase-active" : state.phase === "round-complete" ? "phase-round-complete" : "phase-idle";
    const promptText = T2(() => {
      if (!question) return "";
      if (def.prompt.kind === "text") {
        return def.prompt.getText(question);
      }
      const q3 = question;
      if (q3.questionText) return q3.questionText;
      const fq = question;
      if (fq.currentString !== void 0) return "What note is this?";
      return "";
    }, [question, def]);
    const useFlats = T2(() => {
      const q3 = question;
      return q3?.useFlats ?? false;
    }, [question]);
    const hideAccidentals = T2(() => {
      if (scope.kind === "fretboard") return scope.noteFilter === "natural";
      return false;
    }, [scope]);
    const activeGroup = T2(() => {
      if (def.response.kind !== "bidirectional" || !question) return null;
      return def.response.getActiveGroup(question);
    }, [def, question]);
    const practicingLabel = T2(
      () => def.getPracticingLabel(scope),
      [def, scope]
    );
    const sessionSummary = T2(
      () => def.getSessionSummary(scope),
      [def, scope]
    );
    const isFretboard = def.scopeSpec.kind === "fretboard";
    const fretboardConfig = isFretboard ? {
      stringCount: def.scopeSpec.instrument.stringCount,
      fretCount: def.scopeSpec.instrument.fretCount,
      markers: def.scopeSpec.instrument.fretMarkers
    } : null;
    y2(() => {
      function handleEscape(e3) {
        if (e3.key === "Escape" && state.phase === "idle") {
          onHome();
        }
      }
      document.addEventListener("keydown", handleEscape);
      return () => document.removeEventListener("keydown", handleEscape);
    }, [state.phase, onHome]);
    return /* @__PURE__ */ u3(
      "div",
      {
        class: `mode-screen mode-active ${phaseClass}`,
        id: `mode-${def.id}`,
        onClick: handleTapAdvance,
        children: [
          state.phase === "idle" && /* @__PURE__ */ u3(k, { children: [
            /* @__PURE__ */ u3("div", { class: "mode-tabs", children: [
              /* @__PURE__ */ u3(
                "button",
                {
                  type: "button",
                  class: `mode-tab${activeTab === "practice" ? " active" : ""}`,
                  "data-tab": "practice",
                  onClick: () => setActiveTab("practice"),
                  children: "Practice"
                }
              ),
              /* @__PURE__ */ u3(
                "button",
                {
                  type: "button",
                  class: `mode-tab${activeTab === "progress" ? " active" : ""}`,
                  "data-tab": "progress",
                  onClick: () => setActiveTab("progress"),
                  children: "Progress"
                }
              )
            ] }),
            activeTab === "practice" && /* @__PURE__ */ u3("div", { class: "tab-content tab-practice active", children: [
              /* @__PURE__ */ u3("div", { class: "mode-name", children: def.name }),
              /* @__PURE__ */ u3(ScopeControls, { def, scope, setScope }),
              /* @__PURE__ */ u3(
                PracticeSummary,
                {
                  def,
                  scope,
                  selector: engine.selector
                }
              ),
              /* @__PURE__ */ u3("div", { class: "session-summary-text", children: sessionSummary }),
              state.showMastery && /* @__PURE__ */ u3("div", { class: "mastery-message mastery-visible", children: state.masteryText }),
              /* @__PURE__ */ u3("button", { type: "button", class: "start-btn", onClick: engine.start, children: "Start Quiz" }),
              /* @__PURE__ */ u3(BaselineInfo, { baseline: engine.baseline })
            ] }),
            activeTab === "progress" && /* @__PURE__ */ u3("div", { class: "tab-content tab-progress", style: { display: "block" }, children: /* @__PURE__ */ u3(
              StatsView,
              {
                def,
                selector: engine.selector
              }
            ) })
          ] }),
          state.phase === "active" && /* @__PURE__ */ u3("div", { class: "quiz-session", children: [
            /* @__PURE__ */ u3(CountdownBar, { pct: countdown.pct, warning: countdown.warning }),
            /* @__PURE__ */ u3("div", { class: "quiz-session-info", children: [
              /* @__PURE__ */ u3("span", { class: "quiz-info-context", children: practicingLabel }),
              /* @__PURE__ */ u3("span", { class: "quiz-info-time", children: countdown.time }),
              /* @__PURE__ */ u3("span", { class: "quiz-info-count", children: [
                state.roundAnswered,
                state.roundAnswered === 1 ? " answer" : " answers"
              ] })
            ] }),
            countdown.lastQuestion && /* @__PURE__ */ u3("div", { class: "quiz-last-question", children: "Last question" }),
            /* @__PURE__ */ u3(
              ProgressBar,
              {
                masteredCount: state.masteredCount,
                totalEnabledCount: state.totalEnabledCount
              }
            ),
            /* @__PURE__ */ u3("div", { class: `quiz-area${state.quizActive ? " active" : ""}`, children: [
              /* @__PURE__ */ u3(
                "button",
                {
                  type: "button",
                  class: "quiz-header-close",
                  onClick: engine.stop,
                  children: "\xD7"
                }
              ),
              /* @__PURE__ */ u3("div", { class: "quiz-prompt", children: promptText }),
              isFretboard && fretboardConfig && /* @__PURE__ */ u3(
                FretboardSVG,
                {
                  stringCount: fretboardConfig.stringCount,
                  fretCount: fretboardConfig.fretCount,
                  markers: fretboardConfig.markers,
                  highlights
                }
              ),
              /* @__PURE__ */ u3(
                AnswerArea,
                {
                  def,
                  activeGroup,
                  onAnswer: handleAnswer,
                  disabled: !state.answersEnabled,
                  useFlats,
                  hideAccidentals
                }
              ),
              /* @__PURE__ */ u3("div", { class: state.feedbackClass, children: state.feedbackText }),
              state.timeDisplayText && /* @__PURE__ */ u3("div", { class: "time-display", children: state.timeDisplayText }),
              /* @__PURE__ */ u3("div", { class: "hint", children: state.hintText })
            ] })
          ] }),
          state.phase === "round-complete" && /* @__PURE__ */ u3("div", { class: "quiz-session", children: /* @__PURE__ */ u3(
            RoundComplete,
            {
              state,
              practicingLabel,
              onContinue: engine.continueQuiz,
              onStop: engine.stop
            }
          ) })
        ]
      }
    );
  }
  function AnswerArea({
    def,
    activeGroup,
    onAnswer,
    disabled,
    useFlats,
    hideAccidentals
  }) {
    const response = def.response;
    if (response.kind === "buttons") {
      return /* @__PURE__ */ u3(
        NoteButtons,
        {
          onAnswer,
          disabled,
          useFlats,
          hideAccidentals
        }
      );
    }
    if (response.kind === "bidirectional") {
      return /* @__PURE__ */ u3(k, { children: response.groups.map((group) => /* @__PURE__ */ u3(
        "div",
        {
          class: `answer-group${activeGroup === group.id ? " active" : ""}`,
          style: { display: activeGroup === group.id ? "block" : "none" },
          children: [
            group.id === "notes" && /* @__PURE__ */ u3(
              NoteButtons,
              {
                onAnswer,
                disabled,
                useFlats,
                hideAccidentals
              }
            ),
            group.id === "numbers" && /* @__PURE__ */ u3(
              NumberButtons,
              {
                min: 0,
                max: 11,
                onAnswer,
                disabled
              }
            )
          ]
        },
        group.id
      )) });
    }
    return /* @__PURE__ */ u3(
      NoteButtons,
      {
        onAnswer,
        disabled,
        useFlats,
        hideAccidentals
      }
    );
  }
  function ScopeControls({
    def,
    scope,
    setScope
  }) {
    const spec = def.scopeSpec;
    if (spec.kind === "fretboard" && scope.kind === "fretboard") {
      const inst = spec.instrument;
      return /* @__PURE__ */ u3("div", { class: "toggle-group", children: [
        /* @__PURE__ */ u3("span", { class: "toggle-group-label", children: "Strings" }),
        /* @__PURE__ */ u3("div", { class: "string-toggles", children: inst.stringNames.map((name, i3) => /* @__PURE__ */ u3(
          "button",
          {
            type: "button",
            class: `string-toggle${scope.enabledStrings.has(i3) ? " active" : ""}`,
            "data-string": i3,
            "data-string-note": name,
            onClick: () => {
              const next = new Set(scope.enabledStrings);
              if (next.has(i3)) {
                if (next.size > 1) next.delete(i3);
              } else {
                next.add(i3);
              }
              setScope({ ...scope, enabledStrings: next });
            },
            children: name
          },
          i3
        )) })
      ] });
    }
    if (spec.kind === "groups" && scope.kind === "groups") {
      return /* @__PURE__ */ u3("div", { class: "toggle-group", children: [
        /* @__PURE__ */ u3("span", { class: "toggle-group-label", children: spec.label || "Groups" }),
        /* @__PURE__ */ u3("div", { class: "distance-toggles", children: spec.groups.map((g2) => /* @__PURE__ */ u3(
          "button",
          {
            type: "button",
            class: `distance-toggle${scope.enabledGroups.has(g2.index) ? " active" : ""}`,
            "data-group": g2.index,
            onClick: () => {
              const next = new Set(scope.enabledGroups);
              if (next.has(g2.index)) {
                if (next.size > 1) next.delete(g2.index);
              } else {
                next.add(g2.index);
              }
              setScope({ ...scope, enabledGroups: next });
            },
            children: g2.label
          },
          g2.index
        )) })
      ] });
    }
    return null;
  }
  function PracticeSummary({
    def,
    scope,
    selector
  }) {
    const items = def.getEnabledItems(scope);
    const threshold = selector.getConfig().automaticityThreshold;
    let mastered = 0;
    let seen = 0;
    for (const id of items) {
      const a3 = selector.getAutomaticity(id);
      if (a3 !== null) {
        seen++;
        if (a3 > threshold) mastered++;
      }
    }
    const total = items.length;
    const remaining = total - mastered;
    const statusLabel = total === 0 ? "No items" : mastered === total ? "All mastered" : seen === 0 ? "Getting started" : "Practicing";
    const statusDetail = total === 0 ? "Select some items to practice" : mastered === total ? "All " + total + " items fluent" : mastered + " / " + total + " fluent \xB7 " + remaining + " to go";
    return /* @__PURE__ */ u3("div", { class: "practice-card", children: /* @__PURE__ */ u3("div", { class: "practice-status", children: [
      /* @__PURE__ */ u3("span", { class: "practice-status-label", children: statusLabel }),
      /* @__PURE__ */ u3("span", { class: "practice-status-detail", children: statusDetail })
    ] }) });
  }
  function BaselineInfo({ baseline }) {
    if (baseline) {
      return /* @__PURE__ */ u3("div", { class: "baseline-info", children: /* @__PURE__ */ u3("span", { children: [
        "Response time baseline: ",
        (baseline / 1e3).toFixed(1),
        "s",
        " "
      ] }) });
    }
    return /* @__PURE__ */ u3("div", { class: "baseline-info", children: /* @__PURE__ */ u3("span", { children: "Response time baseline: 1s (default)" }) });
  }
  function StatsView({
    def,
    selector
  }) {
    const [statsMode, setStatsMode] = d2(
      "retention"
    );
    return /* @__PURE__ */ u3("div", { class: "stats-container", children: [
      /* @__PURE__ */ u3("div", { class: "stats-controls", children: [
        /* @__PURE__ */ u3(
          "button",
          {
            type: "button",
            class: `stats-toggle-btn${statsMode === "retention" ? " active" : ""}`,
            onClick: () => setStatsMode("retention"),
            children: "Recall"
          }
        ),
        /* @__PURE__ */ u3(
          "button",
          {
            type: "button",
            class: `stats-toggle-btn${statsMode === "speed" ? " active" : ""}`,
            onClick: () => setStatsMode("speed"),
            children: "Speed"
          }
        )
      ] }),
      /* @__PURE__ */ u3("span", { class: "stats", children: (() => {
        const items = def.allItemIds;
        const threshold = 0.8;
        let fluent = 0;
        for (const id of items) {
          const a3 = selector.getAutomaticity(id);
          if (a3 !== null && a3 > threshold) fluent++;
        }
        return fluent + " / " + items.length + " items fluent";
      })() })
    ] });
  }

  // src/quiz-engine.ts
  function createNoteKeyHandler(submitAnswer, allowAccidentals = () => true) {
    let pendingNote = null;
    let pendingTimeout = null;
    function reset() {
      if (pendingTimeout) clearTimeout(pendingTimeout);
      pendingNote = null;
      pendingTimeout = null;
    }
    function handleKey(e3) {
      const key = e3.key.toUpperCase();
      if (pendingNote && allowAccidentals()) {
        if (e3.key === "#" || e3.key === "s" || e3.key === "S" || e3.shiftKey && e3.key === "3") {
          e3.preventDefault();
          if (pendingTimeout) clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "#");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
        if (e3.key === "b" || e3.key === "B") {
          e3.preventDefault();
          if (pendingTimeout) clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "b");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
      }
      if ("CDEFGAB".includes(key)) {
        e3.preventDefault();
        if (pendingTimeout) clearTimeout(pendingTimeout);
        if (!allowAccidentals()) {
          submitAnswer(key);
        } else {
          pendingNote = key;
          pendingTimeout = setTimeout(() => {
            submitAnswer(pendingNote);
            pendingNote = null;
            pendingTimeout = null;
          }, 400);
        }
        return true;
      }
      return false;
    }
    return { handleKey, reset };
  }
  function createSolfegeKeyHandler(submitAnswer, allowAccidentals = () => true) {
    const SOLFEGE_TO_NOTE = {
      "do": "C",
      "re": "D",
      "mi": "E",
      "fa": "F",
      "so": "G",
      "la": "A",
      "si": "B"
    };
    const FIRST_CHARS = /* @__PURE__ */ new Set(["d", "r", "m", "f", "s", "l"]);
    let buffer = "";
    let pendingNote = null;
    let pendingTimeout = null;
    function reset() {
      buffer = "";
      if (pendingTimeout) clearTimeout(pendingTimeout);
      pendingTimeout = null;
      pendingNote = null;
    }
    function submitPending() {
      if (pendingNote) {
        if (pendingTimeout) clearTimeout(pendingTimeout);
        submitAnswer(pendingNote);
        pendingNote = null;
        pendingTimeout = null;
      }
    }
    function handleKey(e3) {
      const key = e3.key.toLowerCase();
      if (pendingNote && allowAccidentals()) {
        if (e3.key === "#" || e3.shiftKey && e3.key === "3") {
          e3.preventDefault();
          if (pendingTimeout) clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "#");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
        if (key === "b") {
          e3.preventDefault();
          if (pendingTimeout) clearTimeout(pendingTimeout);
          submitAnswer(pendingNote + "b");
          pendingNote = null;
          pendingTimeout = null;
          return true;
        }
      }
      if (pendingNote && FIRST_CHARS.has(key)) {
        submitPending();
      }
      if (buffer.length > 0) {
        e3.preventDefault();
        buffer += key;
        const note = SOLFEGE_TO_NOTE[buffer];
        if (note) {
          buffer = "";
          if (!allowAccidentals()) {
            submitAnswer(note);
          } else {
            pendingNote = note;
            pendingTimeout = setTimeout(() => {
              submitAnswer(pendingNote);
              pendingNote = null;
              pendingTimeout = null;
            }, 400);
          }
        } else if (buffer.length >= 2) {
          buffer = "";
        }
        return true;
      }
      if (FIRST_CHARS.has(key)) {
        e3.preventDefault();
        submitPending();
        buffer = key;
        return true;
      }
      return false;
    }
    return { handleKey, reset };
  }
  function createAdaptiveKeyHandler(submitAnswer, allowAccidentals = () => true) {
    const letterHandler = createNoteKeyHandler(submitAnswer, allowAccidentals);
    const solfegeHandler = createSolfegeKeyHandler(
      submitAnswer,
      allowAccidentals
    );
    return {
      handleKey(e3) {
        return getUseSolfege() ? solfegeHandler.handleKey(e3) : letterHandler.handleKey(e3);
      },
      reset() {
        letterHandler.reset();
        solfegeHandler.reset();
      }
    };
  }
  function refreshNoteButtonLabels(container) {
    container.querySelectorAll(".answer-btn-note").forEach(
      function(btn) {
        const note = NOTES.find(function(n2) {
          return n2.name === btn.dataset.note;
        });
        if (note) btn.textContent = displayNote(note.name);
      }
    );
    container.querySelectorAll(".note-btn").forEach(
      function(btn) {
        const noteName = btn.dataset.note;
        if (noteName) btn.textContent = displayNote(noteName);
      }
    );
    container.querySelectorAll(".string-toggle").forEach(
      function(btn) {
        const stringNote = btn.dataset.stringNote;
        if (stringNote) btn.textContent = displayNote(stringNote);
      }
    );
  }

  // src/stats-display.ts
  var _heatmapColors = null;
  function cssVar(name) {
    try {
      const val = getComputedStyle(document.documentElement).getPropertyValue(
        name
      ).trim();
      if (val) return val;
    } catch (_2) {
    }
    return "";
  }
  function heatmapColors() {
    if (!_heatmapColors) {
      _heatmapColors = {
        none: cssVar("--heatmap-none") || "hsl(30, 4%, 85%)",
        level: [
          cssVar("--heatmap-1") || "hsl(12, 48%, 65%)",
          cssVar("--heatmap-2") || "hsl(30, 48%, 58%)",
          cssVar("--heatmap-3") || "hsl(50, 40%, 50%)",
          cssVar("--heatmap-4") || "hsl(72, 38%, 42%)",
          cssVar("--heatmap-5") || "hsl(90, 45%, 35%)"
        ]
      };
    }
    return _heatmapColors;
  }
  var RETENTION_LABELS = [
    "Needs work (&lt;20%)",
    "Fading (&gt;20%)",
    "Getting there (&gt;40%)",
    "Solid (&gt;60%)",
    "Automatic (&gt;80%)"
  ];
  function getAutomaticityColor(auto) {
    const c3 = heatmapColors();
    if (auto === null) return c3.none;
    if (auto > 0.8) return c3.level[4];
    if (auto > 0.6) return c3.level[3];
    if (auto > 0.4) return c3.level[2];
    if (auto > 0.2) return c3.level[1];
    return c3.level[0];
  }
  function getSpeedHeatmapColor(ms, baseline) {
    const c3 = heatmapColors();
    if (ms === null) return c3.none;
    const b = baseline || 1e3;
    if (ms < b * 1.5) return c3.level[4];
    if (ms < b * 3) return c3.level[3];
    if (ms < b * 4.5) return c3.level[2];
    if (ms < b * 6) return c3.level[1];
    return c3.level[0];
  }
  function formatThreshold(ms) {
    const s3 = ms / 1e3;
    return s3 % 1 === 0 ? s3 + "s" : s3.toFixed(1) + "s";
  }
  function legendItem(color, label) {
    return '<div class="legend-item"><div class="legend-swatch" style="background:' + color + '"></div>' + label + "</div>";
  }
  function buildStatsLegend(statsMode, baseline) {
    const c3 = heatmapColors();
    let html = '<div class="heatmap-legend active">';
    html += legendItem(c3.none, "No data");
    if (statsMode === "retention") {
      for (let i3 = c3.level.length - 1; i3 >= 0; i3--) {
        html += legendItem(c3.level[i3], RETENTION_LABELS[i3]);
      }
    } else {
      const b = baseline || 1e3;
      const t1 = formatThreshold(b * 1.5);
      const t22 = formatThreshold(b * 3);
      const t3 = formatThreshold(b * 4.5);
      const t4 = formatThreshold(b * 6);
      html += legendItem(c3.level[4], "&lt; " + t1);
      html += legendItem(c3.level[3], t1 + "\u2013" + t22);
      html += legendItem(c3.level[2], t22 + "\u2013" + t3);
      html += legendItem(c3.level[1], t3 + "\u2013" + t4);
      html += legendItem(c3.level[0], "&ge; " + t4);
    }
    html += "</div>";
    return html;
  }

  // src/quiz-fretboard-state.ts
  function createFretboardHelpers(musicData) {
    const noteNames = musicData.notes.map((n2) => n2.name);
    const fretCount = musicData.fretCount || 13;
    function getNoteAtPosition(string, fret) {
      const offset = musicData.stringOffsets[string];
      return noteNames[(offset + fret) % 12];
    }
    function parseFretboardItem(itemId) {
      const [s3, f4] = itemId.split("-").map(Number);
      return {
        currentString: s3,
        currentFret: f4,
        currentNote: getNoteAtPosition(s3, f4)
      };
    }
    function checkFretboardAnswer(currentNote, input) {
      const note = musicData.notes.find((n2) => n2.name === currentNote);
      const correct = !!(note && musicData.noteMatchesInput(note, input));
      return { correct, correctAnswer: displayNote(currentNote) };
    }
    function notePassesFilter(note, noteFilter) {
      if (noteFilter === "all") return true;
      const isNatural = musicData.naturalNotes.includes(note);
      return noteFilter === "natural" ? isNatural : !isNatural;
    }
    function getFretboardEnabledItems(enabledStrings, noteFilter) {
      const items = [];
      for (const s3 of enabledStrings) {
        for (let f4 = 0; f4 < fretCount; f4++) {
          const note = getNoteAtPosition(s3, f4);
          if (notePassesFilter(note, noteFilter)) {
            items.push(s3 + "-" + f4);
          }
        }
      }
      return items;
    }
    function getItemIdsForString(string, noteFilter) {
      const items = [];
      for (let f4 = 0; f4 < fretCount; f4++) {
        const note = getNoteAtPosition(string, f4);
        if (notePassesFilter(note, noteFilter)) {
          items.push(string + "-" + f4);
        }
      }
      return items;
    }
    return {
      fretCount,
      getNoteAtPosition,
      parseFretboardItem,
      checkFretboardAnswer,
      getFretboardEnabledItems,
      getItemIdsForString
    };
  }
  function computeNotePrioritization(naturalStats, threshold) {
    let totalSeen = 0;
    let totalMastered = 0;
    for (const r3 of naturalStats) {
      totalSeen += r3.masteredCount + r3.dueCount;
      totalMastered += r3.masteredCount;
    }
    const ratio = totalSeen > 0 ? totalMastered / totalSeen : 0;
    if (totalSeen === 0 || ratio < threshold) {
      return { suggestedFilter: "natural", naturalMasteryRatio: ratio };
    }
    return { suggestedFilter: "all", naturalMasteryRatio: ratio };
  }

  // src/modes/fretboard.ts
  var FB_QUIZ_HL = "hsl(50, 100%, 50%)";
  function setCircleFill(root2, string, fret, color) {
    const circle = root2.querySelector(
      'circle.fb-pos[data-string="' + string + '"][data-fret="' + fret + '"]'
    );
    if (circle) circle.style.fill = color;
  }
  function clearAll(root2) {
    root2.querySelectorAll(".fb-pos").forEach((c3) => {
      c3.style.fill = "";
    });
  }
  function fretboardDefinition(instrument) {
    const fb = createFretboardHelpers({
      notes: NOTES,
      naturalNotes: NATURAL_NOTES,
      stringOffsets: instrument.stringOffsets,
      fretCount: instrument.fretCount,
      noteMatchesInput
    });
    const allStrings = Array.from(
      { length: instrument.stringCount },
      (_2, i3) => i3
    );
    const ALL_ITEMS = [];
    for (const s3 of allStrings) {
      for (let f4 = 0; f4 < instrument.fretCount; f4++) {
        ALL_ITEMS.push(s3 + "-" + f4);
      }
    }
    return {
      id: instrument.id,
      name: instrument.name,
      storageNamespace: instrument.storageNamespace,
      allItemIds: ALL_ITEMS,
      getEnabledItems(scope) {
        if (scope.kind !== "fretboard") {
          return fb.getFretboardEnabledItems(
            new Set(allStrings),
            "natural"
          );
        }
        return fb.getFretboardEnabledItems(
          scope.enabledStrings,
          scope.noteFilter
        );
      },
      scopeSpec: {
        kind: "fretboard",
        instrument
      },
      getQuestion(itemId) {
        return fb.parseFretboardItem(itemId);
      },
      checkAnswer(_itemId, input) {
        const q3 = fb.parseFretboardItem(_itemId);
        return fb.checkFretboardAnswer(q3.currentNote, input);
      },
      prompt: {
        kind: "custom",
        render(q3, els) {
          if (els.fretboardWrapper) {
            clearAll(els.fretboardWrapper);
            setCircleFill(
              els.fretboardWrapper,
              q3.currentString,
              q3.currentFret,
              FB_QUIZ_HL
            );
          }
          els.promptEl.textContent = "Name this note.";
        },
        clear(els) {
          if (els.fretboardWrapper) {
            clearAll(els.fretboardWrapper);
          }
        },
        onAnswer(q3, result, els) {
          if (els.fretboardWrapper) {
            const color = result.correct ? "var(--color-success)" : "var(--color-error)";
            setCircleFill(
              els.fretboardWrapper,
              q3.currentString,
              q3.currentFret,
              color
            );
          }
        }
      },
      response: {
        kind: "buttons",
        answerButtonsHTML: "",
        // already in build-template
        createKeyHandler(submitAnswer, getScope) {
          return createAdaptiveKeyHandler(submitAnswer, () => {
            const scope = getScope();
            return scope.kind === "fretboard" && scope.noteFilter !== "natural";
          });
        },
        getButtonAnswer(btn) {
          return btn.dataset.note ?? null;
        }
      },
      stats: {
        kind: "custom",
        render(statsMode, statsEl, selector, baseline, modeContainer) {
          statsEl.innerHTML = buildStatsLegend(
            statsMode,
            baseline ?? void 0
          );
          const progressFb = modeContainer.querySelector(
            ".tab-progress .fretboard-wrapper"
          );
          if (!progressFb) return;
          for (const s3 of allStrings) {
            for (let f4 = 0; f4 < instrument.fretCount; f4++) {
              const itemId = s3 + "-" + f4;
              if (statsMode === "retention") {
                const auto = selector.getAutomaticity(itemId);
                setCircleFill(progressFb, s3, f4, getAutomaticityColor(auto));
              } else {
                const stats = selector.getStats(itemId);
                const ewma = stats ? stats.ewma : null;
                setCircleFill(
                  progressFb,
                  s3,
                  f4,
                  getSpeedHeatmapColor(ewma, baseline ?? void 0)
                );
              }
            }
          }
        }
      },
      getPracticingLabel(scope) {
        if (scope.kind !== "fretboard") return "all strings";
        const parts = [];
        if (scope.enabledStrings.size < instrument.stringCount) {
          const names = Array.from(scope.enabledStrings).sort((a3, b) => b - a3).map((s3) => displayNote(instrument.stringNames[s3]));
          parts.push(
            names.join(", ") + " string" + (names.length === 1 ? "" : "s")
          );
        } else {
          parts.push("all strings");
        }
        const noteLabel = noteFilterLabel(scope.noteFilter);
        if (scope.noteFilter !== "all") parts.push(noteLabel);
        return parts.join(", ");
      },
      getSessionSummary(scope) {
        if (scope.kind !== "fretboard") {
          return "1 string \xB7 natural notes \xB7 60s";
        }
        const count = scope.enabledStrings.size;
        return count + " string" + (count !== 1 ? "s" : "") + " \xB7 " + noteFilterLabel(scope.noteFilter) + " \xB7 60s";
      },
      getRecommendationContext(rec, selector) {
        const naturalStats = selector.getStringRecommendations(
          [...rec.recommended],
          (s3) => fb.getItemIdsForString(s3, "natural")
        );
        const pri = computeNotePrioritization(
          naturalStats,
          DEFAULT_CONFIG.expansionThreshold
        );
        const extraParts = pri.suggestedFilter === "natural" ? ["naturals first"] : ["add sharps & flats"];
        const noteFilter = pri.suggestedFilter === "natural" ? "natural" : "all";
        return { extraParts, noteFilter };
      }
    };
  }
  function noteFilterLabel(filter) {
    if (filter === "natural") return "natural notes";
    if (filter === "sharps-flats") return "sharps and flats";
    return "all notes";
  }

  // src/modes/semitone-math.ts
  var DISTANCE_GROUPS = [
    { distances: [1, 2], label: "\xB11\u20132" },
    { distances: [3, 4], label: "\xB13\u20134" },
    { distances: [5, 6], label: "\xB15\u20136" },
    { distances: [7, 8], label: "\xB17\u20138" },
    { distances: [9, 10], label: "\xB19\u201310" },
    { distances: [11], label: "\xB111" }
  ];
  function getItemIdsForGroup(groupIndex) {
    const distances = DISTANCE_GROUPS[groupIndex].distances;
    const items = [];
    for (const note of NOTES) {
      for (const d3 of distances) {
        items.push(note.name + "+" + d3);
        items.push(note.name + "-" + d3);
      }
    }
    return items;
  }
  function semitoneMathDefinition() {
    const ALL_ITEMS = [];
    for (const note of NOTES) {
      for (let s3 = 1; s3 <= 11; s3++) {
        ALL_ITEMS.push(note.name + "+" + s3);
        ALL_ITEMS.push(note.name + "-" + s3);
      }
    }
    const groups = DISTANCE_GROUPS.map((g2, i3) => ({
      index: i3,
      label: g2.label,
      itemIds: getItemIdsForGroup(i3)
    }));
    let currentQuestion = null;
    return {
      id: "semitoneMath",
      name: "Semitone Math",
      storageNamespace: "semitoneMath",
      allItemIds: ALL_ITEMS,
      getEnabledItems(scope) {
        if (scope.kind !== "groups") return ALL_ITEMS;
        const items = [];
        for (const g2 of scope.enabledGroups) {
          items.push(...getItemIdsForGroup(g2));
        }
        return items;
      },
      scopeSpec: {
        kind: "groups",
        groups,
        defaultEnabled: [0],
        storageKey: "semitoneMath_enabledGroups",
        label: "Distances",
        sortUnstarted: (a3, b) => a3.string - b.string
      },
      getQuestion(itemId) {
        const match = itemId.match(/^([A-G]#?)([+-])(\d+)$/);
        const noteName = match[1];
        const op = match[2];
        const semitones = parseInt(match[3]);
        const note = NOTES.find((n2) => n2.name === noteName);
        const answer = op === "+" ? noteAdd(note.num, semitones) : noteSub(note.num, semitones);
        const useFlats = op === "-";
        const promptNoteName = displayNote(
          pickAccidentalName(note.displayName, useFlats)
        );
        currentQuestion = {
          note,
          op,
          semitones,
          answer,
          useFlats,
          promptText: promptNoteName + " " + op + " " + semitones
        };
        return currentQuestion;
      },
      checkAnswer(_itemId, input) {
        const q3 = currentQuestion;
        const correct = noteMatchesInput(q3.answer, input);
        return {
          correct,
          correctAnswer: displayNote(
            pickAccidentalName(q3.answer.displayName, q3.useFlats)
          )
        };
      },
      prompt: {
        kind: "custom",
        render(q3, els) {
          els.promptEl.textContent = q3.promptText;
          els.container.querySelectorAll(".answer-btn-note").forEach((btn) => {
            const note = NOTES.find((n2) => n2.name === btn.dataset.note);
            if (note) {
              btn.textContent = displayNote(
                pickAccidentalName(note.displayName, q3.useFlats)
              );
            }
          });
        },
        clear(els) {
          refreshNoteButtonLabels(els.container);
        }
      },
      response: {
        kind: "buttons",
        answerButtonsHTML: "",
        // already in build-template
        createKeyHandler(submitAnswer, _getScope) {
          return createAdaptiveKeyHandler(submitAnswer, () => true);
        },
        getButtonAnswer(btn) {
          return btn.dataset.note ?? null;
        }
      },
      stats: {
        kind: "grid",
        colLabels: Array.from({ length: 11 }, (_2, i3) => String(i3 + 1)),
        getItemId(noteName, colIdx) {
          const n2 = colIdx + 1;
          return [noteName + "+" + n2, noteName + "-" + n2];
        }
      },
      getPracticingLabel(scope) {
        if (scope.kind !== "groups") return "all distances";
        if (scope.enabledGroups.size === DISTANCE_GROUPS.length) {
          return "all distances";
        }
        const labels = [...scope.enabledGroups].sort((a3, b) => a3 - b).map((g2) => DISTANCE_GROUPS[g2].label);
        return labels.join(", ") + " semitones";
      },
      getSessionSummary(scope) {
        const count = this.getEnabledItems(scope).length;
        return count + " items \xB7 60s";
      },
      calibrationSpec: {
        getButtons(container) {
          return Array.from(container.querySelectorAll(".answer-btn-note"));
        }
      }
    };
  }

  // src/modes/note-semitones.ts
  function noteSemitonesDefinition() {
    const ALL_ITEMS = [];
    for (const note of NOTES) {
      ALL_ITEMS.push(note.name + ":fwd");
      ALL_ITEMS.push(note.name + ":rev");
    }
    let currentQuestion = null;
    return {
      id: "noteSemitones",
      name: "Note \u2194 Semitones",
      storageNamespace: "noteSemitones",
      allItemIds: ALL_ITEMS,
      getEnabledItems(_scope) {
        return ALL_ITEMS;
      },
      scopeSpec: { kind: "none" },
      getQuestion(itemId) {
        const [noteName, dir] = itemId.split(":");
        const note = NOTES.find((n2) => n2.name === noteName);
        const accidentalChoice = pickRandomAccidental(note.displayName);
        currentQuestion = {
          note,
          dir,
          accidentalChoice
        };
        return currentQuestion;
      },
      checkAnswer(_itemId, input) {
        const q3 = currentQuestion;
        if (q3.dir === "fwd") {
          const correct = parseInt(input, 10) === q3.note.num;
          return { correct, correctAnswer: String(q3.note.num) };
        } else {
          const correct = noteMatchesInput(q3.note, input);
          return {
            correct,
            correctAnswer: displayNote(q3.accidentalChoice)
          };
        }
      },
      prompt: {
        kind: "text",
        getText(q3) {
          return q3.dir === "fwd" ? displayNote(q3.accidentalChoice) : String(q3.note.num);
        }
      },
      response: {
        kind: "bidirectional",
        groups: [
          {
            id: "notes",
            html: "",
            // already in build-template
            getButtonAnswer(btn) {
              return btn.dataset.note ?? null;
            }
          },
          {
            id: "numbers",
            html: "",
            // already in build-template
            getButtonAnswer(btn) {
              return btn.dataset.num ?? null;
            }
          }
        ],
        getActiveGroup(question) {
          const q3 = question;
          return q3.dir === "fwd" ? "numbers" : "notes";
        },
        createKeyHandler(submitAnswer, _getScope) {
          const noteHandler = createAdaptiveKeyHandler(
            submitAnswer,
            () => true
          );
          let pendingDigit = null;
          let pendingDigitTimeout = null;
          return {
            handleKey(e3) {
              if (currentQuestion?.dir === "rev") {
                return noteHandler.handleKey(e3);
              }
              if (e3.key >= "0" && e3.key <= "9") {
                e3.preventDefault();
                if (pendingDigit !== null) {
                  const num = pendingDigit * 10 + parseInt(e3.key);
                  clearTimeout(pendingDigitTimeout);
                  pendingDigit = null;
                  pendingDigitTimeout = null;
                  if (num <= 11) submitAnswer(String(num));
                  return true;
                }
                const d3 = parseInt(e3.key);
                if (d3 >= 2) {
                  submitAnswer(String(d3));
                } else {
                  pendingDigit = d3;
                  pendingDigitTimeout = setTimeout(() => {
                    submitAnswer(String(pendingDigit));
                    pendingDigit = null;
                    pendingDigitTimeout = null;
                  }, 400);
                }
                return true;
              }
              return false;
            },
            reset() {
              noteHandler.reset();
              if (pendingDigitTimeout) clearTimeout(pendingDigitTimeout);
              pendingDigit = null;
              pendingDigitTimeout = null;
            }
          };
        }
      },
      stats: {
        kind: "table",
        fwdHeader: "N\u2192#",
        revHeader: "#\u2192N",
        getRows() {
          return NOTES.map((note) => ({
            label: displayNote(note.name),
            sublabel: String(note.num),
            _colHeader: "Note",
            fwdItemId: note.name + ":fwd",
            revItemId: note.name + ":rev"
          }));
        }
      },
      getPracticingLabel(_scope) {
        return "all items";
      },
      getSessionSummary(_scope) {
        return ALL_ITEMS.length + " items \xB7 60s";
      },
      calibrationSpec: {
        getButtons(container) {
          return Array.from(container.querySelectorAll(".answer-btn-note"));
        }
      }
    };
  }

  // src/build-template.ts
  var VERSION = "v6.21";
  var HOME_SCREEN_HTML = `  <div class="home-screen" id="home-screen">
    <div class="home-header">
      <h1 class="home-title">Music Reps</h1>
    </div>
    <div class="home-modes">
      <div class="home-group-label">Fretboard</div>
      <button data-mode="fretboard" class="home-mode-btn">
        <span class="home-mode-name">Guitar Fretboard</span>
        <span class="home-mode-desc">Name notes on the guitar neck</span>
      </button>
      <button data-mode="ukulele" class="home-mode-btn">
        <span class="home-mode-name">Ukulele Fretboard</span>
        <span class="home-mode-desc">Name notes on the ukulele</span>
      </button>
      <button data-mode="speedTap" class="home-mode-btn">
        <span class="home-mode-name">Speed Tap</span>
        <span class="home-mode-desc">Find all positions of a note</span>
      </button>
      <div class="home-group-label">Theory Lookup</div>
      <button data-mode="noteSemitones" class="home-mode-btn">
        <span class="home-mode-name">Note \u2194 Semitones</span>
        <span class="home-mode-desc">Convert between notes and semitone numbers</span>
      </button>
      <button data-mode="intervalSemitones" class="home-mode-btn">
        <span class="home-mode-name">Interval \u2194 Semitones</span>
        <span class="home-mode-desc">Convert between intervals and semitone counts</span>
      </button>
      <div class="home-group-label">Calculation</div>
      <button data-mode="semitoneMath" class="home-mode-btn">
        <span class="home-mode-name">Semitone Math</span>
        <span class="home-mode-desc">Add or subtract semitones from a note</span>
      </button>
      <button data-mode="intervalMath" class="home-mode-btn">
        <span class="home-mode-name">Interval Math</span>
        <span class="home-mode-desc">Apply intervals up or down from a note</span>
      </button>
      <div class="home-group-label">Keys &amp; Chords</div>
      <button data-mode="keySignatures" class="home-mode-btn">
        <span class="home-mode-name">Key Signatures</span>
        <span class="home-mode-desc">Match keys to their sharps and flats</span>
      </button>
      <button data-mode="scaleDegrees" class="home-mode-btn">
        <span class="home-mode-name">Scale Degrees</span>
        <span class="home-mode-desc">Name notes by scale degree in any key</span>
      </button>
      <button data-mode="diatonicChords" class="home-mode-btn">
        <span class="home-mode-name">Diatonic Chords</span>
        <span class="home-mode-desc">Identify chords built on each scale degree</span>
      </button>
      <button data-mode="chordSpelling" class="home-mode-btn">
        <span class="home-mode-name">Chord Spelling</span>
        <span class="home-mode-desc">Spell out the notes in any chord</span>
      </button>
    </div>
    <div class="home-footer">
      <button class="home-settings-btn" type="button">Settings</button>
      <span class="version">${VERSION}</span>
    </div>
  </div>`;

  // src/ui-app.tsx
  var MODE_ENTRIES = [
    {
      id: "fretboard",
      name: "Guitar Fretboard",
      desc: "Name notes on the guitar neck",
      group: "Fretboard",
      factory: () => fretboardDefinition(GUITAR)
    },
    {
      id: "noteSemitones",
      name: "Note \u2194 Semitones",
      desc: "Convert between notes and semitone numbers",
      group: "Theory Lookup",
      factory: noteSemitonesDefinition
    },
    {
      id: "semitoneMath",
      name: "Semitone Math",
      desc: "Add or subtract semitones from a note",
      group: "Calculation",
      factory: semitoneMathDefinition
    }
  ];
  function groupedEntries() {
    const groups = /* @__PURE__ */ new Map();
    for (const entry of MODE_ENTRIES) {
      let list = groups.get(entry.group);
      if (!list) {
        list = [];
        groups.set(entry.group, list);
      }
      list.push(entry);
    }
    return [...groups.entries()];
  }
  var modeDefCache = /* @__PURE__ */ new Map();
  function getModeDefinition(id) {
    let def = modeDefCache.get(id);
    if (!def) {
      const entry = MODE_ENTRIES.find((e3) => e3.id === id);
      if (!entry) throw new Error("Unknown mode: " + id);
      def = entry.factory();
      modeDefCache.set(id, def);
    }
    return def;
  }
  function App() {
    const [activeMode, setActiveMode] = d2(null);
    const [settingsOpen, setSettingsOpen] = d2(false);
    const [, forceUpdate] = d2(0);
    y2(() => {
      const last = localStorage.getItem("lastMode");
      if (last && MODE_ENTRIES.some((e3) => e3.id === last)) {
        setActiveMode(last);
      }
    }, []);
    y2(() => {
      if (activeMode) localStorage.setItem("lastMode", activeMode);
    }, [activeMode]);
    const handleHome = q2(() => setActiveMode(null), []);
    const handleNotationChange = q2(() => {
      forceUpdate((n2) => n2 + 1);
    }, []);
    if (activeMode) {
      const def = getModeDefinition(activeMode);
      return /* @__PURE__ */ u3(k, { children: [
        /* @__PURE__ */ u3(ModeView, { def, onHome: handleHome }),
        settingsOpen && /* @__PURE__ */ u3(
          SettingsModal,
          {
            onClose: () => setSettingsOpen(false),
            onNotationChange: handleNotationChange
          }
        )
      ] });
    }
    return /* @__PURE__ */ u3(k, { children: [
      /* @__PURE__ */ u3(
        HomeScreen,
        {
          onSelectMode: setActiveMode,
          onSettings: () => setSettingsOpen(true)
        }
      ),
      settingsOpen && /* @__PURE__ */ u3(
        SettingsModal,
        {
          onClose: () => setSettingsOpen(false),
          onNotationChange: handleNotationChange
        }
      )
    ] });
  }
  function HomeScreen({
    onSelectMode,
    onSettings
  }) {
    return /* @__PURE__ */ u3("div", { class: "home-screen", id: "home-screen", children: [
      /* @__PURE__ */ u3("div", { class: "home-header", children: /* @__PURE__ */ u3("h1", { class: "home-title", children: "Music Reps" }) }),
      /* @__PURE__ */ u3("div", { class: "home-modes", children: groupedEntries().map(([group, entries]) => /* @__PURE__ */ u3("div", { children: [
        /* @__PURE__ */ u3("div", { class: "home-group-label", children: group }),
        entries.map((entry) => /* @__PURE__ */ u3(
          "button",
          {
            type: "button",
            "data-mode": entry.id,
            class: "home-mode-btn",
            onClick: () => onSelectMode(entry.id),
            children: [
              /* @__PURE__ */ u3("span", { class: "home-mode-name", children: entry.name }),
              /* @__PURE__ */ u3("span", { class: "home-mode-desc", children: entry.desc })
            ]
          },
          entry.id
        ))
      ] }, group)) }),
      /* @__PURE__ */ u3("div", { class: "home-footer", children: [
        /* @__PURE__ */ u3("button", { type: "button", class: "home-settings-btn", onClick: onSettings, children: "Settings" }),
        /* @__PURE__ */ u3("span", { class: "version", children: VERSION })
      ] })
    ] });
  }
  function SettingsModal({
    onClose,
    onNotationChange
  }) {
    const [useSolfege, setUseSolfegeState] = d2(getUseSolfege());
    const toggle = q2(
      (want) => {
        if (want !== useSolfege) {
          setUseSolfege(want);
          setUseSolfegeState(want);
          onNotationChange();
        }
      },
      [useSolfege, onNotationChange]
    );
    y2(() => {
      function handleKey(e3) {
        if (e3.key === "Escape") onClose();
      }
      document.addEventListener("keydown", handleKey);
      return () => document.removeEventListener("keydown", handleKey);
    }, [onClose]);
    return /* @__PURE__ */ u3(
      "div",
      {
        class: "settings-overlay open",
        onClick: (e3) => {
          if (e3.target === e3.currentTarget) onClose();
        },
        children: /* @__PURE__ */ u3("div", { class: "settings-modal", children: [
          /* @__PURE__ */ u3("div", { class: "settings-header", children: [
            /* @__PURE__ */ u3("span", { class: "settings-title", children: "Settings" }),
            /* @__PURE__ */ u3(
              "button",
              {
                type: "button",
                class: "settings-close-btn",
                "aria-label": "Close",
                onClick: onClose,
                children: "\xD7"
              }
            )
          ] }),
          /* @__PURE__ */ u3("div", { class: "settings-body", children: /* @__PURE__ */ u3("div", { class: "settings-field", children: [
            /* @__PURE__ */ u3("div", { class: "settings-label", children: "Note names" }),
            /* @__PURE__ */ u3("div", { class: "settings-toggle-group", children: [
              /* @__PURE__ */ u3(
                "button",
                {
                  type: "button",
                  class: `settings-toggle-btn${!useSolfege ? " active" : ""}`,
                  onClick: () => toggle(false),
                  children: "A B C"
                }
              ),
              /* @__PURE__ */ u3(
                "button",
                {
                  type: "button",
                  class: `settings-toggle-btn${useSolfege ? " active" : ""}`,
                  onClick: () => toggle(true),
                  children: "Do Re Mi"
                }
              )
            ] })
          ] }) })
        ] })
      }
    );
  }

  // src/app.tsx
  var root = document.getElementById("app");
  if (root) {
    J(/* @__PURE__ */ u3(App, {}), root);
  }
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("/sw.js").catch(() => {
    });
  }
})();

  </script>
</body>
</html>