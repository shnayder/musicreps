# Development

Day-to-day workflow reference for building, testing, and deploying.

## Prerequisites

- **Deno** (preferred) or **Node.js** with `npx`
- `npm install` required for esbuild (dev dependency)
- Playwright required for screenshots only: `npx playwright install chromium`. Only works locally, when `CLAUDE_CODE_REMOTE` is not set to `true`.

## Commands

```bash
# Dev server (serves index.html + sw.js on localhost:8001)
deno run --allow-net --allow-read --allow-run main.ts

# Build for GitHub Pages (Deno)
deno run --allow-write --allow-read --allow-run main.ts --build

# Build for GitHub Pages (Node — when Deno is unavailable)
npx tsx build.ts

# Run all tests
npx tsx --test src/*_test.ts

# Take screenshots of all modes (starts dev server automatically)
npx tsx scripts/take-screenshots.ts
```

## Build System

The HTML template, version number, and page structure live in
`src/build-template.ts` — the single source of truth. Source files are ES
modules bundled by esbuild into a single IIFE `<script>` block:

- `build.ts` (Node): uses `esbuild.buildSync()` JS API
- `main.ts` (Deno): shells out to esbuild CLI via `Deno.Command`

To add a new source file, just create it with proper `import`/`export`
statements and import it from where it's needed. esbuild resolves the
module graph automatically from the entry point (`src/app.js`).

## Testing

### What to test
- Pure functions: state transitions, data helpers, algorithms
- Edge cases: empty sets, boundary values, single-element collections
- Enharmonic equivalence where relevant to music theory
- New modules with logic should always have a `_test.ts` file

### What NOT to test
- `render()` functions — they are declarative and tested visually
- DOM event wiring — tested by manual interaction
- CSS styling

### Infrastructure
- Framework: `node:test` (`describe`, `it`, `assert`)
- Runner: `npx tsx --test`
- Dependency injection: `Map` for storage, imported music data, seeded RNG
- No global state pollution — each test creates its own selector/helpers

Write tests as you go, not just at the end.

## Versioning

A version number is displayed on the home screen (`<span class="version">`).
**Always bump the version with every change** — even tiny bug fixes or label
tweaks. The user needs to confirm they're testing the latest build; a stale
version number makes that impossible. The version lives in one place:
`VERSION` in `src/build-template.ts`. Bump by 1 for normal changes (v3.13 →
v3.14 → v3.15) and bump the major version for large overhauls (v3.x → v4.0).

## Branching

Always start from the latest `main` branch unless told otherwise. Fetch and
merge/rebase from `origin/main` after the feature design is finalized, before
beginning implementation.


## Deployment

Build output goes to `docs/` (GitHub Pages source directory):
- `docs/index.html` — the single-page app
- `docs/sw.js` — service worker (network-first cache strategy)
- `docs/favicon-32x32.png` — browser tab icon
- `docs/apple-touch-icon.png` — iOS home screen icon
- `docs/design/` — design reference pages (copied from `guides/design/`)

After building, commit the changed files. The service worker ensures users get
the latest version on next load.

### Design reference pages

The build copies all `.html` files from `guides/design/` to `docs/design/`,
rewriting the stylesheet path for co-located access. One of these pages is
itself build-generated:

- `guides/design/moments.html` — **generated by `buildMoments()` in `build.ts`**.
  Uses the same `modeScreen()`, `fretboardSVG()`, and button helpers as the
  production app, then injects phase classes and content via string replacement.
  To add or modify a moment, edit the `buildMoments()` function.

- `guides/design/colors.html`, `components.html` — hand-written reference pages.

All three link to `../../src/styles.css` so CSS changes are visible on refresh
(no rebuild needed for hand-written pages; rebuild required for moments).

**If you add new files to `docs/`**, no workflow changes are needed — the preview
deploy workflow copies all files from `docs/` automatically.

## Preview Deploys

Pushes to `claude/*` branches automatically deploy a preview build via GitHub
Actions. The workflow (`.github/workflows/deploy-preview.yml`) builds the app
and commits the output to `docs/preview/<branch-name>/` on main.

- **Preview URL:** `shnayder.github.io/musicreps/preview/<branch-name>/`
- **Cleanup:** `.github/workflows/cleanup-preview.yml` removes the preview
  directory when the branch is deleted or PR is closed.
- **PR comment:** the deploy workflow posts the preview URL on any associated PR.

## iOS App (Capacitor)

The iOS app is a Capacitor wrapper around the same `docs/index.html` build.
The Xcode project lives in `ios/App/`.

### Prerequisites

- Xcode 16+ with iOS Simulator runtime installed
- Capacitor deps already in `package.json` — just `npm install` if needed

### Build and run in Simulator

```bash
# 1. Build web content + copy into Xcode project
npx tsx build.ts && npx cap copy ios

# 2. Build the iOS app for Simulator
xcodebuild -project ios/App/App.xcodeproj \
  -scheme App -configuration Debug \
  -destination 'platform=iOS Simulator,name=iPhone 16' build

# 3. Boot a simulator (skip if already running)
xcrun simctl boot "iPhone 16"

# 4. Install the app
xcrun simctl install booted \
  ~/Library/Developer/Xcode/DerivedData/App-*/Build/Products/Debug-iphonesimulator/App.app

# 5. Launch the app
xcrun simctl launch booted com.musicreps.app
```

Or do it all in one shot:

```bash
npx tsx build.ts && npx cap copy ios && \
xcodebuild -project ios/App/App.xcodeproj \
  -scheme App -configuration Debug \
  -destination 'platform=iOS Simulator,name=iPhone 16' build && \
xcrun simctl install booted \
  ~/Library/Developer/Xcode/DerivedData/App-*/Build/Products/Debug-iphonesimulator/App.app && \
xcrun simctl launch booted com.musicreps.app
```

### Opening in Xcode

```bash
npx cap open ios
```

This opens the Xcode project where you can run/debug with the play button,
inspect the view hierarchy, or manage signing for device builds.

### Useful Simulator commands

```bash
# List available simulators
xcrun simctl list devices available

# Take a screenshot
xcrun simctl io booted screenshot /tmp/screenshot.png

# Open a URL in the simulator's browser
xcrun simctl openurl booted "https://example.com"

# View app logs (useful for JS console.log output)
xcrun simctl spawn booted log stream --predicate 'process == "App"' --level debug

# Shut down the simulator
xcrun simctl shutdown booted
```

### Resetting app state

localStorage persists between launches. To start fresh:

```bash
# Uninstall and reinstall the app (clears all data)
xcrun simctl uninstall booted com.musicreps.app
xcrun simctl install booted \
  ~/Library/Developer/Xcode/DerivedData/App-*/Build/Products/Debug-iphonesimulator/App.app
xcrun simctl launch booted com.musicreps.app
```

Or reset the entire simulator to factory state:

```bash
xcrun simctl erase booted
```

### Iterating on changes

After editing JS/CSS/HTML, you only need to rebuild web content and copy it
into the Xcode project — no native rebuild needed unless you changed Swift
code:

```bash
npx tsx build.ts && npx cap copy ios
```

Then relaunch the app in the Simulator (or kill and reopen it — Capacitor
loads from local files, so the new content appears on next launch).

If you changed Swift code or Capacitor config, you need a full rebuild:

```bash
xcodebuild -project ios/App/App.xcodeproj \
  -scheme App -configuration Debug \
  -destination 'platform=iOS Simulator,name=iPhone 16' build
```

### Key paths

| Path | Contents |
|------|----------|
| `capacitor.config.ts` | App name, bundle ID, web dir |
| `ios/App/App/AppDelegate.swift` | Native app lifecycle |
| `ios/App/App/Info.plist` | iOS app configuration |
| `ios/App/App/Assets.xcassets/` | App icon and launch images |
| `ios/App/App/public/` | Web content (copied, gitignored) |

## Code Review & PR

Every branch that changes code follows these steps before merging:

1. **Run `/review`** — catches template sync issues, architecture violations,
   missing tests, and convention drift. Fix any critical findings and re-run
   until approved.
2. **Push the branch** — `git push -u origin <branch-name>`
3. **Create a PR** — `gh pr create` with a summary of changes and a test plan.

`/review` is not optional — it's the gate before pushing. Use the `/review`
slash command to run the code-reviewer subagent, which applies the checklist in
`.claude/commands/review-checklist.md`.

Review scopes:
- `/review` — review working tree diff (default)
- `/review 42` — review PR #42
- `/review main..HEAD` — review a commit range

## GitHub API Access (Web Environment)

`gh` CLI is not authenticated in the Claude Code web environment. Use `curl`
through the egress proxy:

```bash
PROXY_URL="$GLOBAL_AGENT_HTTP_PROXY"

# List open PRs
curl -sS --proxy "$PROXY_URL" \
  -H "Accept: application/vnd.github.v3+json" \
  "https://api.github.com/repos/shnayder/musicreps/pulls?state=open"

# Get PR review comments
curl -sS --proxy "$PROXY_URL" \
  -H "Accept: application/vnd.github.v3+json" \
  "https://api.github.com/repos/shnayder/musicreps/pulls/{PR_NUMBER}/comments"

# Get issue/PR conversation comments
curl -sS --proxy "$PROXY_URL" \
  -H "Accept: application/vnd.github.v3+json" \
  "https://api.github.com/repos/shnayder/musicreps/issues/{PR_NUMBER}/comments"
```

The proxy authenticates automatically via the JWT in `GLOBAL_AGENT_HTTP_PROXY`.
No `GH_TOKEN` needed. Git push/pull work normally via the `origin` remote.
